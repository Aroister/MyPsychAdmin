# ================================================================
#  MOJ LEAVE FORM PAGE — Leave Application for Restricted Patient
#  Mental Health Casework Section (MHCS) Leave Application
#  Based exactly on MHCS_Leave_Application_Form.docx structure
#  Restructured with card-based layout (like tribunal report)
# ================================================================

from __future__ import annotations
import re
from datetime import datetime
from PySide6.QtCore import Qt, Signal, QDate, QEvent
from PySide6.QtWidgets import (
    QGraphicsDropShadowEffect,
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QFrame,
    QScrollArea, QLineEdit, QTextEdit, QDateEdit,
    QCheckBox, QPushButton, QFileDialog, QMessageBox, QToolButton,
    QGridLayout, QRadioButton, QButtonGroup, QComboBox, QSlider,
    QSplitter, QSpinBox, QSizePolicy, QStackedWidget, QCompleter,
    QTableWidget, QHeaderView, QApplication
)
from PySide6.QtGui import QColor
from background_history_popup import CollapsibleSection, ResizableSection

# ICD-10 data
try:
    from icd10_dict import load_icd10_dict
    ICD10_DICT = load_icd10_dict()
except:
    ICD10_DICT = {}

from utils.resource_path import resource_path
from mha_form_toolbar import MHAFormToolbar
from mypsy_richtext_editor import MyPsychAdminRichTextEditor


# ================================================================
# NO-WHEEL SLIDER (prevents scroll from changing value)
# ================================================================
class NoWheelSlider(QSlider):
    def wheelEvent(self, event):
        event.ignore()


# ================================================================
# NO-WHEEL DATE EDIT (prevents scroll from changing date)
# ================================================================
class NoWheelDateEdit(QDateEdit):
    def wheelEvent(self, event):
        event.ignore()


# ================================================================
# PRONOUN HELPER
# ================================================================
def pronouns_from_gender(g):
    """Return pronoun dictionary based on gender."""
    g = (g or "").lower().strip()
    if g == "male":
        return {"subj": "He", "subj_l": "he", "obj": "him", "pos": "his", "have": "has", "are": "is", "do": "does"}
    if g == "female":
        return {"subj": "She", "subj_l": "she", "obj": "her", "pos": "her", "have": "has", "are": "is", "do": "does"}
    return {"subj": "They", "subj_l": "they", "obj": "them", "pos": "their", "have": "have", "are": "are", "do": "do"}


# ================================================================
# ZOOM HELPER FUNCTION
# ================================================================

def create_zoom_row(text_edit: QTextEdit, base_size: int = 12) -> QHBoxLayout:
    """Create a zoom controls row for any QTextEdit."""
    zoom_row = QHBoxLayout()
    zoom_row.setSpacing(2)
    zoom_row.addStretch()

    text_edit._font_size = base_size

    zoom_out_btn = QPushButton("−")
    zoom_out_btn.setFixedSize(16, 16)
    zoom_out_btn.setCursor(Qt.CursorShape.PointingHandCursor)
    zoom_out_btn.setToolTip("Decrease font size")
    zoom_out_btn.setStyleSheet("""
        QPushButton {
            background: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
            border-radius: 3px;
            font-size: 14px;
            font-weight: bold;
        }
        QPushButton:hover { background: #e5e7eb; }
    """)
    zoom_row.addWidget(zoom_out_btn)

    zoom_in_btn = QPushButton("+")
    zoom_in_btn.setFixedSize(16, 16)
    zoom_in_btn.setCursor(Qt.CursorShape.PointingHandCursor)
    zoom_in_btn.setToolTip("Increase font size")
    zoom_in_btn.setStyleSheet("""
        QPushButton {
            background: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
            border-radius: 3px;
            font-size: 14px;
            font-weight: bold;
        }
        QPushButton:hover { background: #e5e7eb; }
    """)
    zoom_row.addWidget(zoom_in_btn)

    current_style = text_edit.styleSheet()

    def zoom_in():
        text_edit._font_size = min(text_edit._font_size + 2, 28)
        new_style = re.sub(r'font-size:\s*\d+px', f'font-size: {text_edit._font_size}px', current_style)
        text_edit.setStyleSheet(new_style)

    def zoom_out():
        text_edit._font_size = max(text_edit._font_size - 2, 8)
        new_style = re.sub(r'font-size:\s*\d+px', f'font-size: {text_edit._font_size}px', current_style)
        text_edit.setStyleSheet(new_style)

    zoom_in_btn.clicked.connect(zoom_in)
    zoom_out_btn.clicked.connect(zoom_out)

    return zoom_row


# ================================================================
# MOJ LEAVE CARD WIDGET
# ================================================================

class MOJLeaveCardWidget(QFrame):
    """Card widget for MOJ Leave Form sections (similar to TribunalCardWidget)."""

    clicked = Signal(str)

    STYLE_NORMAL = """
        QFrame#mojCard {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
        }
        QFrame#mojCard:hover {
            border: 1px solid #fca5a5;
            background: #fef2f2;
        }
        QLabel {
            background: transparent;
            border: none;
        }
        QRadioButton, QCheckBox {
            background: transparent;
            border: none;
        }
    """
    STYLE_SELECTED = """
        QFrame#mojCard {
            background: #fef2f2;
            border: 2px solid #dc2626;
            border-radius: 12px;
        }
        QLabel {
            background: transparent;
            border: none;
        }
        QRadioButton, QCheckBox {
            background: transparent;
            border: none;
        }
    """

    def __init__(self, title: str, key: str, parent=None):
        super().__init__(parent)
        self.title = title
        self.key = key
        self._selected = False
        self.setObjectName("mojCard")
        self.setStyleSheet(self.STYLE_NORMAL)
        self.setCursor(Qt.CursorShape.PointingHandCursor)

        # Add drop shadow effect
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(22)
        shadow.setYOffset(3)
        shadow.setColor(QColor(0, 0, 0, 40))
        self.setGraphicsEffect(shadow)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 16, 20, 16)
        layout.setSpacing(8)

        # Title
        title_lbl = QLabel(title)
        title_lbl.setStyleSheet("""
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
        """)
        layout.addWidget(title_lbl)

        # Editor (preview/edit area)
        self.editor = MyPsychAdminRichTextEditor()
        self.editor.setPlaceholderText("Click to edit...")
        self.editor.setReadOnly(False)
        self._editor_height = 200
        self.editor.setFixedHeight(self._editor_height)
        self.editor.setStyleSheet("""
            QTextEdit {
                background: #f9fafb;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
                padding: 8px;
                font-size: 15px;
                color: #374151;
            }
        """)
        editor_zoom = create_zoom_row(self.editor, base_size=12)
        layout.addLayout(editor_zoom)
        layout.addWidget(self.editor)

        # Expand/resize bar
        self.expand_bar = QFrame()
        self.expand_bar.setFixedHeight(12)
        self.expand_bar.setCursor(Qt.CursorShape.SizeVerCursor)
        self.expand_bar.setStyleSheet("""
            QFrame {
                background: #e5e7eb;
                border-radius: 2px;
                margin: 4px 40px;
            }
            QFrame:hover {
                background: #dc2626;
            }
        """)
        self.expand_bar.installEventFilter(self)
        self._dragging = False
        self._drag_start_y = 0
        self._drag_start_height = 0
        layout.addWidget(self.expand_bar)

    def eventFilter(self, obj, event):
        """Handle drag events on the expand bar."""
        if obj == self.expand_bar:
            if event.type() == QEvent.Type.MouseButtonPress:
                self._dragging = True
                self._drag_start_y = event.globalPosition().y()
                self._drag_start_height = self._editor_height
                return True
            elif event.type() == QEvent.Type.MouseMove and self._dragging:
                delta = event.globalPosition().y() - self._drag_start_y
                new_height = max(80, min(500, self._drag_start_height + delta))
                self._editor_height = int(new_height)
                self.editor.setFixedHeight(self._editor_height)
                return True
            elif event.type() == QEvent.Type.MouseButtonRelease:
                self._dragging = False
                return True
        return super().eventFilter(obj, event)

    def mousePressEvent(self, event):
        if not self.editor.geometry().contains(event.pos()) and not self.expand_bar.geometry().contains(event.pos()):
            self.clicked.emit(self.key)
        super().mousePressEvent(event)

    def setSelected(self, selected: bool):
        if self._selected != selected:
            self._selected = selected
            self.setStyleSheet(self.STYLE_SELECTED if selected else self.STYLE_NORMAL)

    def isSelected(self) -> bool:
        return self._selected


# ================================================================
# MOJ LEAVE FORM PAGE
# ================================================================

class MOJLeaveFormPage(QWidget):
    """Page for completing MOJ Leave Application for Restricted Patients."""

    go_back = Signal()

    # Sections based on MHCS Leave Application Form
    SECTIONS = [
        ("1. Patient Details", "patient_details"),
        ("2. Responsible Clinician Details", "rc_details"),
        ("3a. Type of Leave Requested", "leave_type"),
        ("3b. Documents Reviewed", "documents"),
        ("3c. Purpose of Leave", "purpose"),
        ("3d. Unescorted Overnight Leave", "overnight"),
        ("3e. Escorted Overnight Leave", "escorted_overnight"),
        ("3f. Compassionate Leave", "compassionate"),
        ("3g. Leave Report", "leave_report"),
        ("3h. Proposed Management", "procedures"),
        ("4a. Past Psychiatric History", "hospital_admissions"),
        ("4b. Index Offence and Forensic History", "index_offence"),
        ("4c. Current Mental Disorder", "mental_disorder"),
        ("4d. Attitude and Behaviour", "attitude_behaviour"),
        ("4e. Risk Factors", "risk_factors"),
        ("4f. Medication", "medication"),
        ("4g. Risks and Psychology", "psychology"),
        ("4h. Extremism", "extremism"),
        ("4i. Absconding", "absconding"),
        ("5. MAPPA", "mappa"),
        ("6. Victims", "victims"),
        ("7. Transferred Prisoners", "transferred_prisoners"),
        ("8. Fitness to Plead", "fitness_to_plead"),
        ("9. Additional Comments", "additional_comments"),
        ("Signature", "signature"),
    ]

    def __init__(self, db=None, parent=None):
        super().__init__(parent)
        self.db = db
        self.cards = {}
        self.popups = {}
        self.popup_previews = {}  # Preview labels for each popup
        self.popup_send_buttons = {}  # Send buttons for each popup
        self.popup_generators = {}  # Generator functions for each popup
        self._selected_card_key = None
        self._my_details = self._load_my_details()
        self._extracted_raw_notes = []
        self._extracted_categories = {}
        self._data_extractor_overlay = None
        self._last_generated_text = {}  # Track generated text for preservation
        self._data_processed_id = None   # Signature of last processed extracted data (prevents reprocessing)
        self._notes_processed_id = None  # Signature of last processed notes (prevents reprocessing)
        self._auto_fill_phase = True     # True during initial automated fill — allows all card updates
        self._setup_ui()
        self._prefill()
        self._connect_shared_store()

    def _connect_shared_store(self):
        """Connect to SharedDataStore for cross-report data sharing."""
        try:
            from shared_data_store import get_shared_store
            shared_store = get_shared_store()
            shared_store.notes_changed.connect(self._on_notes_changed)
            shared_store.extracted_data_changed.connect(self._on_extracted_data_changed)
            shared_store.patient_info_changed.connect(self._on_patient_info_changed)
            print("[MOJ-LEAVE] Connected to SharedDataStore signals (notes, extracted_data, patient_info)")

            # Check if there's already data in the store
            self._check_shared_store_for_existing_data()
        except Exception as e:
            print(f"[MOJ-LEAVE] Failed to connect to SharedDataStore: {e}")

    def _update_text_preserving_additions(self, text_widget, new_generated: str, tracking_key: str):
        """Update a text widget with new generated content while preserving user additions.
        After initial auto-fill, only the currently active popup can update its own card,
        unless a gender update is in progress.

        Args:
            text_widget: The QTextEdit widget to update
            new_generated: The newly generated text
            tracking_key: Key to track the last generated text
        """
        # After auto-fill phase, block cross-card updates (except gender updates)
        if not self._auto_fill_phase and tracking_key != self._selected_card_key:
            if not getattr(self, '_gender_update_in_progress', False):
                return
        current_text = text_widget.toPlainText()
        last_generated = self._last_generated_text.get(tracking_key, "")

        # Check for import markers that should be preserved
        import_marker = "\n\n--- Imported Notes ---\n"
        imported_section = ""
        if import_marker in current_text:
            imported_section = import_marker + current_text.split(import_marker)[1]
            current_text = current_text.split(import_marker)[0]
            if last_generated and import_marker in last_generated:
                last_generated = last_generated.split(import_marker)[0]

        if not current_text or current_text.strip() == last_generated.strip():
            # No user additions - just replace
            text_widget.setPlainText(new_generated + imported_section)
        elif last_generated and last_generated.strip() in current_text:
            # User added text - preserve additions
            last_gen_stripped = last_generated.strip()
            idx = current_text.find(last_gen_stripped)
            if idx == 0:
                user_additions = current_text[len(last_gen_stripped):]
                text_widget.setPlainText(new_generated + user_additions + imported_section)
            elif idx > 0:
                before = current_text[:idx]
                after = current_text[idx + len(last_gen_stripped):]
                text_widget.setPlainText(before + new_generated + after + imported_section)
            else:
                text_widget.setPlainText(new_generated + imported_section)
        else:
            # Last generated not found - user heavily modified
            # Just replace but preserve imported section
            text_widget.setPlainText(new_generated + imported_section)

        self._last_generated_text[tracking_key] = new_generated

    def _check_shared_store_for_existing_data(self):
        """Check SharedDataStore for existing data when page is created."""
        try:
            from shared_data_store import get_shared_store
            shared_store = get_shared_store()

            # Check for existing patient info
            patient_info = shared_store.patient_info
            if patient_info and any(patient_info.values()):
                print(f"[MOJ-LEAVE] Found existing patient info in SharedDataStore")
                self._on_patient_info_changed(patient_info)

            # Check for existing notes
            notes = shared_store.notes
            if notes:
                print(f"[MOJ-LEAVE] Found {len(notes)} existing notes in SharedDataStore")
                self._on_notes_changed(notes)

            # Check for existing extracted data
            extracted_data = shared_store.extracted_data
            if extracted_data:
                print(f"[MOJ-LEAVE] Found existing extracted data in SharedDataStore")
                self._on_extracted_data_changed(extracted_data)
        except Exception as e:
            print(f"[MOJ-LEAVE] Error checking shared store: {e}")

    def _on_patient_info_changed(self, patient_info: dict):
        """Handle patient info updates from SharedDataStore."""
        if patient_info and any(patient_info.values()):
            print(f"[MOJ-LEAVE] Received patient info from SharedDataStore")

    def _on_notes_changed(self, notes: list):
        """Handle notes updates from SharedDataStore."""
        if notes:
            print(f"[MOJ-LEAVE] Received {len(notes)} notes from SharedDataStore")
            self._extracted_raw_notes = notes

    def _on_extracted_data_changed(self, data: dict):
        """Handle extracted data updates from SharedDataStore."""
        if not data:
            return
        print(f"[MOJ-LEAVE] Received extracted data from SharedDataStore: {list(data.keys())}")
        categories = data.get("categories", data)
        self._extracted_categories = categories

    def _load_my_details(self) -> dict:
        if not self.db:
            return {}
        details = self.db.get_clinician_details()
        if not details:
            return {}
        return dict(details)

    def _prefill(self):
        # Pre-fill RC details from database
        pass  # Will be handled in popup

    def set_notes(self, notes: list):
        """
        Set notes from shared data store.
        Called by MainWindow when notes are available from another section.
        """
        if not notes:
            return

        # Skip if these exact notes were already processed
        notes_sig = (len(notes), id(notes))
        if self._notes_processed_id == notes_sig:
            print(f"[MOJ-LEAVE] Skipping set_notes - notes already processed ({len(notes)} notes)")
            return
        self._notes_processed_id = notes_sig

        # Store raw notes at page level for use in sections
        self._extracted_raw_notes = notes

        # If data extractor exists, update its notes too
        if hasattr(self, '_data_extractor') and self._data_extractor:
            if hasattr(self._data_extractor, 'set_notes'):
                self._data_extractor.set_notes(notes)

        # Run 4a timeline analysis for detected admissions and clerking notes
        if hasattr(self, '_4a_detected_table'):
            self._run_4a_timeline_analysis(notes)
        else:
            print(f"[MOJ-Leave] 4a popup not created yet - timeline analysis will run when popup opens")

        print(f"[MOJ-Leave] Received {len(notes)} notes from shared store")

    def _get_pronouns(self):
        """Get pronouns based on gender selection."""
        # Gender radio buttons are defined on self, not on the popup
        if hasattr(self, 'gender_male') and self.gender_male.isChecked():
            return {"subj": "He", "subj_l": "he", "obj": "him", "pos": "His", "pos_l": "his", "self": "himself", "has": "has", "have": "has", "is": "is", "are": "is", "do": "does"}
        elif hasattr(self, 'gender_female') and self.gender_female.isChecked():
            return {"subj": "She", "subj_l": "she", "obj": "her", "pos": "Her", "pos_l": "her", "self": "herself", "has": "has", "have": "has", "is": "is", "are": "is", "do": "does"}
        return {"subj": "They", "subj_l": "they", "obj": "them", "pos": "Their", "pos_l": "their", "self": "themselves", "has": "have", "have": "have", "is": "are", "are": "are", "do": "do"}

    def _on_gender_changed(self, button):
        """Update all previews when gender is changed."""
        print(f"[MOJ-LEAVE] Gender changed to: {button.text()}")
        self._update_all_previews_for_gender()

    def _update_all_previews_for_gender(self):
        """Update ALL previews and cards when gender changes. Called from both button click and programmatic set."""
        gender = self._get_patient_gender()
        print(f"[MOJ-LEAVE] Updating all previews for gender: {gender or 'They/Them'}")

        # Allow cross-card updates during gender change
        self._gender_update_in_progress = True

        try:
            # Update all popup previews that use pronouns
            # Wrap in try-except to handle deleted widget references
            preview_funcs = [
                '_update_mha_preview',
                '_update_mental_disorder_preview',
                '_update_attitude_behaviour_preview',
                '_update_risk_factors_preview',
                '_update_medication_preview',
                '_update_leave_report_preview',
                '_update_forensic_preview',
                '_update_psych_preview',
            ]
            for func_name in preview_funcs:
                if hasattr(self, func_name):
                    try:
                        getattr(self, func_name)()
                    except RuntimeError as e:
                        # Widget was deleted, skip this preview update
                        print(f"[MOJ-LEAVE] Skipping {func_name}: {e}")
                        continue

            if hasattr(self, '_update_preview'):
                # Generic preview update for various popups
                for key in ['mental_health_act', 'mental_disorder', 'risk_factors', 'attitude_behaviour',
                            'medication', 'leave', 'forensic_history', 'past_psych']:
                    try:
                        self._update_preview(key)
                    except:
                        pass

            # Update all cards that might have pronoun-based text
            if hasattr(self, '_update_all_card_previews'):
                try:
                    self._update_all_card_previews()
                except:
                    pass
        finally:
            self._gender_update_in_progress = False

    def _setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        # Header
        header = QFrame()
        header.setFixedHeight(60)
        header.setStyleSheet("background: #991b1b; border-bottom: 1px solid rgba(0,0,0,0.1);")
        header_layout = QHBoxLayout(header)
        header_layout.setContentsMargins(24, 0, 24, 0)

        back_btn = QPushButton("< Back")
        back_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        back_btn.setStyleSheet("""
            QPushButton {
                background: rgba(255,255,255,0.15);
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 6px;
                font-size: 17px;
                font-weight: 600;
            }
            QPushButton:hover { background: rgba(255,255,255,0.25); }
        """)
        back_btn.clicked.connect(self.go_back.emit)
        header_layout.addWidget(back_btn)

        title = QLabel("MOJ Leave Application — Restricted Patient")
        title.setStyleSheet("font-size: 22px; font-weight: 700; color: white;")
        header_layout.addWidget(title)
        header_layout.addStretch()

        # Clear Form button
        clear_btn = QPushButton("Clear Form")
        clear_btn.setFixedSize(220, 36)
        clear_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        clear_btn.setStyleSheet("""
            QPushButton {
                background: #991b1b;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 6px;
                font-weight: 600;
                font-size: 15px;
            }
            QPushButton:hover {
                background: #7f1d1d;
            }
            QPushButton:pressed {
                background: #450a0a;
            }
        """)
        clear_btn.clicked.connect(self._clear_form)
        header_layout.addWidget(clear_btn)

        main_layout.addWidget(header)

        # Full Toolbar with formatting options
        self.toolbar = MHAFormToolbar()
        self.toolbar.export_docx.connect(self._export_docx)

        self._active_editor = None

        def get_active_editor():
            return self._active_editor

        def safe_call(method_name):
            editor = get_active_editor()
            if editor and hasattr(editor, method_name):
                getattr(editor, method_name)()

        self.toolbar.set_font_family.connect(
            lambda family: get_active_editor().set_font_family(family) if get_active_editor() else None
        )
        self.toolbar.set_font_size.connect(
            lambda size: get_active_editor().set_font_size(size) if get_active_editor() else None
        )
        self.toolbar.toggle_bold.connect(lambda: safe_call("toggle_bold"))
        self.toolbar.toggle_italic.connect(lambda: safe_call("toggle_italic"))
        self.toolbar.toggle_underline.connect(lambda: safe_call("toggle_underline"))
        self.toolbar.set_text_color.connect(
            lambda c: get_active_editor().set_text_color(c) if get_active_editor() else None
        )
        self.toolbar.set_highlight_color.connect(
            lambda c: get_active_editor().set_highlight_color(c) if get_active_editor() else None
        )
        self.toolbar.set_align_left.connect(lambda: safe_call("align_left"))
        self.toolbar.set_align_center.connect(lambda: safe_call("align_center"))
        self.toolbar.set_align_right.connect(lambda: safe_call("align_right"))
        self.toolbar.set_align_justify.connect(lambda: safe_call("align_justify"))
        self.toolbar.bullet_list.connect(lambda: safe_call("bullet_list"))
        self.toolbar.numbered_list.connect(lambda: safe_call("numbered_list"))
        self.toolbar.indent.connect(lambda: safe_call("indent"))
        self.toolbar.outdent.connect(lambda: safe_call("outdent"))
        self.toolbar.undo.connect(lambda: safe_call("undo"))
        self.toolbar.redo.connect(lambda: safe_call("redo"))
        self.toolbar.insert_date.connect(lambda: safe_call("insert_date"))
        self.toolbar.insert_section_break.connect(lambda: safe_call("insert_section_break"))

        def check_spelling():
            editor = get_active_editor()
            if editor and hasattr(editor, 'jump_to_next_error'):
                if not editor.jump_to_next_error():
                    QMessageBox.information(self, "Spell Check", "No spelling errors found.")

        self.toolbar.check_spelling.connect(check_spelling)

        main_layout.addWidget(self.toolbar)

        # Content area with splitter
        content = QWidget()
        content_layout = QHBoxLayout(content)
        content_layout.setContentsMargins(0, 0, 0, 0)
        content_layout.setSpacing(0)

        self.main_splitter = QSplitter(Qt.Orientation.Horizontal)
        self.main_splitter.setHandleWidth(6)
        self.main_splitter.setStyleSheet("""
            QSplitter::handle {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #e5e7eb, stop:0.5 #9ca3af, stop:1 #e5e7eb);
                border-radius: 3px;
                margin: 40px 2px;
            }
            QSplitter::handle:hover {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #d1d5db, stop:0.5 #6b7280, stop:1 #d1d5db);
            }
        """)
        content_layout.addWidget(self.main_splitter)

        # Left: Cards in scroll area
        self.cards_holder = QScrollArea()
        self.cards_holder.setWidgetResizable(True)
        self.cards_holder.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.cards_holder.setStyleSheet("""
            QScrollArea {
                background: #f9fafb;
                border: none;
            }
        """)
        self.main_splitter.addWidget(self.cards_holder)

        self.cards_root = QWidget()
        self.cards_root.setStyleSheet("background: #f9fafb;")
        self.cards_layout = QVBoxLayout(self.cards_root)
        self.cards_layout.setContentsMargins(32, 24, 32, 24)
        self.cards_layout.setSpacing(16)
        self.cards_holder.setWidget(self.cards_root)

        # Right: Panel with popup stack
        self.editor_panel = QFrame()
        self.editor_panel.setMinimumWidth(380)
        self.editor_panel.setMaximumWidth(800)
        self.editor_panel.setStyleSheet("""
            QFrame#editorPanel {
                background: white;
                border-left: 1px solid #e5e7eb;
            }
            QLabel {
                background: transparent;
                border: none;
            }
            QCheckBox, QRadioButton {
                background: transparent;
                border: none;
            }
        """)
        self.editor_panel.setObjectName("editorPanel")
        self.main_splitter.addWidget(self.editor_panel)
        self.main_splitter.setStretchFactor(0, 1)
        self.main_splitter.setStretchFactor(1, 0)
        self.main_splitter.setSizes([600, 450])

        panel_layout = QVBoxLayout(self.editor_panel)
        panel_layout.setContentsMargins(20, 20, 20, 20)
        panel_layout.setSpacing(12)

        self.panel_title = QLabel("Select a section")
        self.panel_title.setWordWrap(True)
        self.panel_title.setStyleSheet("""
            font-size: 25px;
            font-weight: 700;
            color: #1f2937;
            background: white;
            padding: 12px 18px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        """)
        panel_layout.addWidget(self.panel_title)

        # Popup stack
        self.popup_stack = QStackedWidget()
        panel_layout.addWidget(self.popup_stack, 1)

        main_layout.addWidget(content)

        # Create all cards
        self._create_cards()

    def _register_active_editor(self, editor):
        self._active_editor = editor

    def _hook_editor_focus(self, editor):
        original_focus_in = editor.focusInEvent
        page = self
        def focus_handler(event):
            page._register_active_editor(editor)
            original_focus_in(event)
        editor.focusInEvent = focus_handler

    def _create_cards(self):
        """Create all section cards."""
        for title, key in self.SECTIONS:
            card = MOJLeaveCardWidget(title, key, parent=self.cards_root)
            card.clicked.connect(self._on_card_clicked)
            self.cards[key] = card
            self.cards_layout.addWidget(card)
            self._hook_editor_focus(card.editor)

        self.cards_layout.addStretch()

    def _on_card_clicked(self, key: str):
        """Handle card click - show appropriate popup."""
        title = next((t for t, k in self.SECTIONS if k == key), key)
        self.panel_title.setText(title)

        # Update card selection highlighting
        if self._selected_card_key and self._selected_card_key in self.cards:
            self.cards[self._selected_card_key].setSelected(False)
        if key in self.cards:
            self.cards[key].setSelected(True)
        self._selected_card_key = key

        # Create popup if not exists
        if key not in self.popups:
            popup = self._create_popup(key)
            if popup:
                self.popups[key] = popup
                self.popup_stack.addWidget(popup)

        # Show popup
        if key in self.popups:
            self.popup_stack.setCurrentWidget(self.popups[key])

    def _create_popup(self, key: str) -> QWidget:
        """Create popup widget for the given section key."""
        if key == "patient_details":
            return self._create_patient_details_popup()
        elif key == "rc_details":
            return self._create_rc_details_popup()
        elif key == "leave_type":
            return self._create_leave_type_popup()
        elif key == "documents":
            return self._create_documents_popup()
        elif key == "purpose":
            return self._create_purpose_popup()
        elif key == "overnight":
            return self._create_overnight_popup()
        elif key == "escorted_overnight":
            return self._create_escorted_overnight_popup()
        elif key == "compassionate":
            return self._create_compassionate_popup()
        elif key == "leave_report":
            return self._create_leave_report_popup()
        elif key == "procedures":
            return self._create_procedures_popup()
        elif key == "hospital_admissions":
            return self._create_hospital_admissions_popup()
        elif key == "index_offence":
            return self._create_index_offence_popup()
        elif key == "mental_disorder":
            return self._create_mental_disorder_popup()
        elif key == "attitude_behaviour":
            return self._create_attitude_behaviour_popup()
        elif key == "risk_factors":
            return self._create_risk_factors_popup()
        elif key == "medication":
            return self._create_medication_popup()
        elif key == "psychology":
            return self._create_psychology_popup()
        elif key == "extremism":
            return self._create_extremism_popup()
        elif key == "absconding":
            return self._create_absconding_popup()
        elif key == "mappa":
            return self._create_mappa_popup()
        elif key == "victims":
            return self._create_victims_popup()
        elif key == "transferred_prisoners":
            return self._create_transferred_prisoners_popup()
        elif key == "fitness_to_plead":
            return self._create_fitness_to_plead_popup()
        elif key == "additional_comments":
            return self._create_additional_comments_popup()
        elif key == "signature":
            return self._create_signature_popup()
        return None

    # ================================================================
    # POPUP CONTAINER HELPER (Input layout only - auto-syncs to cards)
    # ================================================================

    def _create_popup_container(self, key: str) -> tuple:
        """Create popup with input section only (no preview).
        Returns (main_widget, input_layout) for adding input fields.
        Inputs auto-sync to cards via _update_card_from_popup."""
        main_widget = QWidget()
        main_widget.setStyleSheet("background: white;")
        main_layout = QVBoxLayout(main_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        # === INPUT SECTION (scrollable) ===
        input_scroll = QScrollArea()
        input_scroll.setWidgetResizable(True)
        input_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        input_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        input_scroll.setStyleSheet("QScrollArea { background: white; border: none; }")

        input_content = QWidget()
        input_content.setStyleSheet("""
            background: white;
            QLabel { font-size: 19px; color: #374151; }
            QLineEdit { font-size: 19px; padding: 8px; }
            QTextEdit { font-size: 19px; }
            QComboBox { font-size: 19px; padding: 8px; }
            QCheckBox { font-size: 19px; spacing: 8px; }
            QRadioButton { font-size: 19px; spacing: 8px; }
            QDateEdit { font-size: 19px; padding: 8px; }
            QSpinBox { font-size: 19px; padding: 8px; }
        """)
        input_layout = QVBoxLayout(input_content)
        input_layout.setContentsMargins(4, 8, 4, 8)
        input_layout.setSpacing(10)

        input_scroll.setWidget(input_content)
        main_layout.addWidget(input_scroll)

        return main_widget, input_layout

    def _setup_popup_preview(self, key: str, generate_func):
        """Register generator function and auto-sync to card."""
        self.popup_generators[key] = generate_func
        # Initial card update
        self._update_card_from_popup(key)

    def _update_preview(self, key: str):
        """Alias for _update_card_from_popup for compatibility."""
        self._update_card_from_popup(key)

    def _update_card_from_popup(self, key: str):
        """Auto-sync popup content to card.
        After initial auto-fill, only the currently active popup can update its own card."""
        # After auto-fill phase, block cross-card updates
        if not self._auto_fill_phase and key != self._selected_card_key:
            return
        if key in self.popup_generators and key in self.cards:
            try:
                text = self.popup_generators[key]()
                if text:
                    self.cards[key].editor.setPlainText(text)
                else:
                    self.cards[key].editor.setPlainText("")
            except Exception as e:
                self.cards[key].editor.setPlainText(f"(Error: {e})")


    def _styled_label(self, text: str) -> QLabel:
        """Create a QLabel with larger font for popup input sections."""
        lbl = QLabel(text)
        lbl.setStyleSheet("font-size: 22px; color: #374151;")
        lbl.setWordWrap(True)
        return lbl

    def _connect_preview_updates(self, key: str, widgets: list):
        """Connect widgets to trigger preview updates when changed."""
        for widget in widgets:
            if isinstance(widget, QLineEdit):
                widget.textChanged.connect(lambda _, k=key: self._update_preview(k))
            elif isinstance(widget, QTextEdit):
                widget.textChanged.connect(lambda k=key: self._update_preview(k))
            elif isinstance(widget, QComboBox):
                widget.currentTextChanged.connect(lambda _, k=key: self._update_preview(k))
            elif isinstance(widget, QCheckBox):
                widget.stateChanged.connect(lambda _, k=key: self._update_preview(k))
            elif isinstance(widget, QRadioButton):
                widget.toggled.connect(lambda _, k=key: self._update_preview(k))
            elif isinstance(widget, QDateEdit):
                widget.dateChanged.connect(lambda _, k=key: self._update_preview(k))
            elif isinstance(widget, QSlider):
                widget.valueChanged.connect(lambda _, k=key: self._update_preview(k))
            elif isinstance(widget, QSpinBox):
                widget.valueChanged.connect(lambda _, k=key: self._update_preview(k))

    # ================================================================
    # POPUP CREATORS
    # ================================================================

    def _create_patient_details_popup(self) -> QWidget:
        """Create patient details popup with preview panel and form fields."""
        key = "patient_details"
        popup, layout = self._create_popup_container(key)

        # Input field styling
        field_style = "background: white; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 17px;"

        # Patient Name
        layout.addWidget(self._styled_label("Patient Name:"))
        self.patient_name = QLineEdit()
        self.patient_name.setPlaceholderText("Full name")
        self.patient_name.setStyleSheet(field_style)
        layout.addWidget(self.patient_name)

        # DOB
        layout.addWidget(self._styled_label("Date of Birth:"))
        self.patient_dob = NoWheelDateEdit()
        self.patient_dob.setCalendarPopup(True)
        self.patient_dob.setDisplayFormat("dd/MM/yyyy")
        self.patient_dob.setStyleSheet(field_style)
        layout.addWidget(self.patient_dob)

        # Gender
        layout.addWidget(self._styled_label("Gender:"))
        gender_row = QHBoxLayout()
        self.gender_group = QButtonGroup(self)
        self.gender_male = QRadioButton("Male")
        self.gender_female = QRadioButton("Female")
        self.gender_other = QRadioButton("Other")
        self.gender_male.setStyleSheet("""
            QRadioButton {
                font-size: 17px;
                background: transparent;
            }
            QRadioButton::indicator {
                width: 18px;
                height: 18px;
            }
        """)
        self.gender_female.setStyleSheet("""
            QRadioButton {
                font-size: 17px;
                background: transparent;
            }
            QRadioButton::indicator {
                width: 18px;
                height: 18px;
            }
        """)
        self.gender_other.setStyleSheet("""
            QRadioButton {
                font-size: 17px;
                background: transparent;
            }
            QRadioButton::indicator {
                width: 18px;
                height: 18px;
            }
        """)
        self.gender_group.addButton(self.gender_male)
        self.gender_group.addButton(self.gender_female)
        self.gender_group.addButton(self.gender_other)
        gender_row.addWidget(self.gender_male)
        gender_row.addWidget(self.gender_female)
        gender_row.addWidget(self.gender_other)
        gender_row.addStretch()
        layout.addLayout(gender_row)

        # Connect gender changes to update all previews
        self.gender_group.buttonClicked.connect(self._on_gender_changed)

        # Hospital Number
        layout.addWidget(self._styled_label("Hospital Number:"))
        self.hospital_number = QLineEdit()
        self.hospital_number.setPlaceholderText("Hospital/NHS number")
        self.hospital_number.setStyleSheet(field_style)
        layout.addWidget(self.hospital_number)

        # Hospital Name
        layout.addWidget(self._styled_label("Hospital Name:"))
        self.hospital_name = QLineEdit()
        self.hospital_name.setPlaceholderText("Name of hospital")
        self.hospital_name.setStyleSheet(field_style)
        layout.addWidget(self.hospital_name)

        # Ward
        layout.addWidget(self._styled_label("Ward:"))
        self.ward = QLineEdit()
        self.ward.setPlaceholderText("Ward name")
        self.ward.setStyleSheet(field_style)
        layout.addWidget(self.ward)

        # MHA Section
        layout.addWidget(self._styled_label("Section of Mental Health Act:"))
        self.mha_section = QComboBox()
        self.mha_section.addItems(["", "37/41", "47/49", "48/49", "45A", "Other"])
        self.mha_section.setStyleSheet(field_style)
        self.mha_section.setEditable(True)
        self.mha_section.lineEdit().setPlaceholderText("Select or type section")
        layout.addWidget(self.mha_section)

        # Ministry of Justice Reference
        layout.addWidget(self._styled_label("Ministry of Justice Reference:"))
        self.moj_reference = QLineEdit()
        self.moj_reference.setPlaceholderText("MOJ reference number")
        self.moj_reference.setStyleSheet(field_style)
        layout.addWidget(self.moj_reference)

        layout.addStretch()

        # Setup preview generator and connect widgets
        def generate_patient_details():
            name = self.patient_name.text().strip()
            dob = self.patient_dob.date().toString("dd/MM/yyyy")
            gender = "Male" if self.gender_male.isChecked() else "Female" if self.gender_female.isChecked() else "Other" if self.gender_other.isChecked() else ""
            hosp_num = self.hospital_number.text().strip()
            hosp_name = self.hospital_name.text().strip()
            ward = self.ward.text().strip()
            section = self.mha_section.currentText().strip()
            moj_ref = self.moj_reference.text().strip()

            parts = []
            if name:
                parts.append(f"Patient: {name}")
            if dob and dob != QDate.currentDate().toString("dd/MM/yyyy"):
                parts.append(f"DOB: {dob}")
            if gender:
                parts.append(f"Gender: {gender}")
            if hosp_num:
                parts.append(f"Hospital No: {hosp_num}")
            if hosp_name:
                parts.append(f"Hospital: {hosp_name}")
            if ward:
                parts.append(f"Ward: {ward}")
            if section:
                parts.append(f"MHA Section: {section}")
            if moj_ref:
                parts.append(f"MOJ Ref: {moj_ref}")

            return "\n".join(parts) if parts else ""

        self._setup_popup_preview(key, generate_patient_details)
        self._connect_preview_updates(key, [
            self.patient_name, self.patient_dob, self.gender_male, self.gender_female,
            self.gender_other, self.hospital_number, self.hospital_name, self.ward,
            self.mha_section, self.moj_reference
        ])

        # Apply any stored patient details from import (delayed to ensure widgets are ready)
        from PySide6.QtCore import QTimer
        QTimer.singleShot(0, self._apply_extracted_patient_details)

        return popup

    def _create_rc_details_popup(self) -> QWidget:
        """Create RC details popup with preview panel."""
        key = "rc_details"
        popup, layout = self._create_popup_container(key)
        field_style = "background: white; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 17px;"

        # RC Name
        layout.addWidget(self._styled_label("Responsible Clinician Name:"))
        self.rc_name = QLineEdit()
        self.rc_name.setPlaceholderText("Full name")
        self.rc_name.setStyleSheet(field_style)
        layout.addWidget(self.rc_name)

        # Pre-fill from database
        if self._my_details.get("full_name"):
            self.rc_name.setText(self._my_details["full_name"])

        # RC Email
        layout.addWidget(self._styled_label("Email:"))
        self.rc_email = QLineEdit()
        self.rc_email.setPlaceholderText("Email address")
        self.rc_email.setStyleSheet(field_style)
        layout.addWidget(self.rc_email)

        if self._my_details.get("email"):
            self.rc_email.setText(self._my_details["email"])

        # RC Phone
        layout.addWidget(self._styled_label("Phone:"))
        self.rc_phone = QLineEdit()
        self.rc_phone.setPlaceholderText("Phone number")
        self.rc_phone.setStyleSheet(field_style)
        layout.addWidget(self.rc_phone)

        if self._my_details.get("phone"):
            self.rc_phone.setText(self._my_details["phone"])

        layout.addStretch()

        # Setup preview
        def generate_rc_details():
            parts = []
            name = self.rc_name.text().strip()
            email = self.rc_email.text().strip()
            phone = self.rc_phone.text().strip()
            if name:
                parts.append(f"RC: {name}")
            if email:
                parts.append(f"Email: {email}")
            if phone:
                parts.append(f"Phone: {phone}")
            return "\n".join(parts) if parts else ""

        self._setup_popup_preview(key, generate_rc_details)
        self._connect_preview_updates(key, [self.rc_name, self.rc_email, self.rc_phone])

        return popup

    def _create_leave_type_popup(self) -> QWidget:
        """Create leave type popup matching MOJ form structure exactly."""
        key = "leave_type"
        popup, layout = self._create_popup_container(key)

        layout.addWidget(self._styled_label("<b>Type of leave proposed:</b>"))
        layout.addSpacing(8)

        # Store all leave type checkboxes - matches MOJ form exactly
        self.leave_type_checkboxes = {}

        # Helper to create a row with day/overnight options
        def create_leave_row(label, key_prefix):
            row_frame = QFrame()
            row_frame.setStyleSheet("QFrame { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 6px; }")
            row_layout = QVBoxLayout(row_frame)
            row_layout.setContentsMargins(12, 10, 12, 10)
            row_layout.setSpacing(8)

            lbl = QLabel(f"<b>{label}</b>")
            lbl.setStyleSheet("font-size: 17px; font-weight: 600; color: #374151;")
            row_layout.addWidget(lbl)

            cb_row = QHBoxLayout()
            day_cb = QCheckBox("Day")
            overnight_cb = QCheckBox("Overnight")
            day_cb.setStyleSheet("font-size: 17px;")
            overnight_cb.setStyleSheet("font-size: 17px;")

            self.leave_type_checkboxes[f"{key_prefix}_day"] = day_cb
            self.leave_type_checkboxes[f"{key_prefix}_overnight"] = overnight_cb

            cb_row.addWidget(day_cb)
            cb_row.addWidget(overnight_cb)
            cb_row.addStretch()
            row_layout.addLayout(cb_row)

            day_cb.stateChanged.connect(lambda _, k=key: self._update_preview(k))
            overnight_cb.stateChanged.connect(lambda _, k=key: self._update_preview(k))

            # Also connect to update 3g leave report defaults when leave type changes
            day_cb.stateChanged.connect(lambda state, kp=key_prefix: self._on_3a_leave_type_changed(f"{kp}_day", state))
            overnight_cb.stateChanged.connect(lambda state, kp=key_prefix: self._on_3a_leave_type_changed(f"{kp}_overnight", state))

            return row_frame

        # Compassionate leave row
        layout.addWidget(create_leave_row("Compassionate", "compassionate"))
        layout.addSpacing(4)

        # Escorted community row
        layout.addWidget(create_leave_row("Escorted community", "escorted"))
        layout.addSpacing(4)

        # Unescorted community row
        layout.addWidget(create_leave_row("Unescorted community", "unescorted"))

        layout.addStretch()

        # Setup preview
        def generate_leave_type():
            parts = []
            labels = {
                "compassionate_day": "Compassionate (day)",
                "compassionate_overnight": "Compassionate (overnight)",
                "escorted_day": "Escorted community (day)",
                "escorted_overnight": "Escorted (overnight)",
                "unescorted_day": "Unescorted community (day)",
                "unescorted_overnight": "Unescorted community (overnight)",
            }
            for cb_key, label in labels.items():
                if self.leave_type_checkboxes.get(cb_key) and self.leave_type_checkboxes[cb_key].isChecked():
                    parts.append(f"☑ {label}")
            return "\n".join(parts) if parts else ""

        self._setup_popup_preview(key, generate_leave_type)
        self._connect_preview_updates(key, list(self.leave_type_checkboxes.values()))

        return popup

    def _create_documents_popup(self) -> QWidget:
        """Create documents reviewed popup with preview panel."""
        key = "documents"
        popup, layout = self._create_popup_container(key)

        layout.addWidget(self._styled_label("Documents reviewed in preparation for this application:"))

        self.documents_checkboxes = {}
        documents_list = [
            ("cpa_minutes", "CPA Minutes"),
            ("psychology_reports", "Psychology Reports"),
            ("hcr20", "HCR-20"),
            ("sara", "SARA"),
            ("other_risk_tools", "Other Risk Assessment Tools"),
            ("previous_reports", "Previous Reports"),
            ("current_reports", "Current Reports"),
            ("previous_notes", "Previous Notes"),
            ("current_notes", "Current Notes"),
        ]

        widgets_to_connect = []
        for doc_key, label in documents_list:
            cb = QCheckBox(label)
            cb.setStyleSheet("font-size: 17px;")
            self.documents_checkboxes[doc_key] = cb
            layout.addWidget(cb)
            widgets_to_connect.append(cb)

        # Select All / Deselect All buttons
        btn_row = QHBoxLayout()
        btn_row.setSpacing(8)

        select_all_btn = QPushButton("Select All")
        select_all_btn.setStyleSheet("""
            QPushButton { background: #3b82f6; color: white; border: none; border-radius: 4px; padding: 8px 16px; font-size: 13px; font-weight: 600; }
            QPushButton:hover { background: #2563eb; }
        """)
        select_all_btn.clicked.connect(lambda: [cb.setChecked(True) for cb in self.documents_checkboxes.values()])
        btn_row.addWidget(select_all_btn)

        deselect_all_btn = QPushButton("Deselect All")
        deselect_all_btn.setStyleSheet("""
            QPushButton { background: #6b7280; color: white; border: none; border-radius: 4px; padding: 8px 16px; font-size: 13px; font-weight: 600; }
            QPushButton:hover { background: #4b5563; }
        """)
        deselect_all_btn.clicked.connect(lambda: [cb.setChecked(False) for cb in self.documents_checkboxes.values()])
        btn_row.addWidget(deselect_all_btn)
        btn_row.addStretch()

        layout.addLayout(btn_row)

        # Other documents text field
        layout.addWidget(self._styled_label("Other documents (specify):"))
        self.other_documents = QLineEdit()
        self.other_documents.setPlaceholderText("Any other documents reviewed...")
        self.other_documents.setStyleSheet("background: white; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px;")
        layout.addWidget(self.other_documents)
        widgets_to_connect.append(self.other_documents)

        layout.addStretch()

        # Setup preview
        def generate_documents():
            parts = []
            for doc_key, label in documents_list:
                if self.documents_checkboxes[doc_key].isChecked():
                    parts.append(f"• {label}")
            other = self.other_documents.text().strip()
            if other:
                parts.append(f"• Other: {other}")
            return "\n".join(parts) if parts else ""

        self._setup_popup_preview(key, generate_documents)
        self._connect_preview_updates(key, widgets_to_connect)

        return popup

    def _create_purpose_popup(self) -> QWidget:
        """Create purpose of leave popup - auto-syncs to card."""
        popup = QScrollArea()
        popup.setWidgetResizable(True)
        popup.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        popup.setStyleSheet("QScrollArea { border: none; background: white; } QWidget { background: white; }")

        content = QWidget()
        layout = QVBoxLayout(content)
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(10)

        # Preview widget showing generated text (visible so user can verify card content)
        self.purpose_preview = QLabel("(No content yet...)")
        self.purpose_preview.setWordWrap(True)
        self.purpose_preview.setStyleSheet(
            "QLabel { background: #f0fdf4; border: 1px solid #86efac; border-radius: 8px; "
            "padding: 12px; font-size: 15px; color: #166534; line-height: 1.4; }"
        )
        self.purpose_preview.setMinimumHeight(40)
        layout.addWidget(self.purpose_preview)

        # === INPUT SECTION ===
        input_container = QFrame()
        input_container.setStyleSheet("QFrame { background: transparent; }")
        input_layout = QVBoxLayout(input_container)
        input_layout.setContentsMargins(8, 8, 8, 8)
        input_layout.setSpacing(10)

        # 1. PURPOSE OF LEAVE
        lbl1 = QLabel("<b>1. Purpose of Leave (therapeutic benefit):</b>")
        lbl1.setStyleSheet("font-size: 17px;")
        input_layout.addWidget(lbl1)

        self.purpose_group = QButtonGroup(self)
        self.purpose_radios = {}
        purpose_options = [
            ("starting", "Starting meaningful testing"),
            ("continuing", "Continuing previous leave"),
            ("unescorted", "Move to unescorted leave"),
            ("rehabilitation", "Rehabilitation process"),
        ]

        for key, label in purpose_options:
            radio = QRadioButton(label)
            radio.setStyleSheet("font-size: 20px;")
            radio.toggled.connect(self._update_purpose_preview)
            self.purpose_group.addButton(radio)
            self.purpose_radios[key] = radio
            input_layout.addWidget(radio)

        # 2. LOCATION OF LEAVE
        lbl2 = QLabel("<b>2. Location of Leave:</b>")
        lbl2.setStyleSheet("font-size: 17px;")
        input_layout.addWidget(lbl2)

        self.location_checkboxes = {}
        location_options = [
            ("ground", "Ground (hospital grounds)"),
            ("local", "Local (nearby area)"),
            ("community", "Community (wider area)"),
            ("family", "Family (visit family home)"),
        ]

        for key, label in location_options:
            cb = QCheckBox(label)
            cb.setStyleSheet("font-size: 20px;")
            cb.stateChanged.connect(self._update_purpose_preview)
            self.location_checkboxes[key] = cb
            input_layout.addWidget(cb)

        # Exclusion zone radios
        input_layout.addWidget(self._styled_label("Proximity to exclusion zone:"))
        self.exclusion_group = QButtonGroup(self)
        exclusion_row = QHBoxLayout()

        self.exclusion_yes = QRadioButton("Yes")
        self.exclusion_no = QRadioButton("No")
        self.exclusion_na = QRadioButton("N/A")
        self.exclusion_yes.setStyleSheet("font-size: 20px;")
        self.exclusion_no.setStyleSheet("font-size: 20px;")
        self.exclusion_na.setStyleSheet("font-size: 20px;")

        self.exclusion_group.addButton(self.exclusion_yes)
        self.exclusion_group.addButton(self.exclusion_no)
        self.exclusion_group.addButton(self.exclusion_na)

        self.exclusion_yes.toggled.connect(self._update_purpose_preview)
        self.exclusion_no.toggled.connect(self._update_purpose_preview)
        self.exclusion_na.toggled.connect(self._update_purpose_preview)

        exclusion_row.addWidget(self.exclusion_yes)
        exclusion_row.addWidget(self.exclusion_no)
        exclusion_row.addWidget(self.exclusion_na)
        exclusion_row.addStretch()
        input_layout.addLayout(exclusion_row)

        # 3. DISCHARGE PLAN
        input_layout.addWidget(self._styled_label("<b>3. Discharge Planning Status:</b>"))

        self.discharge_options = ["Not started", "Early stages", "In progress", "Almost completed", "Completed"]
        self.discharge_label = QLabel(self.discharge_options[0])
        self.discharge_label.setStyleSheet("color: #991b1b; font-weight: 600;")
        input_layout.addWidget(self.discharge_label)

        self.discharge_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.discharge_slider.setRange(0, len(self.discharge_options) - 1)
        self.discharge_slider.setValue(0)
        self.discharge_slider.setStyleSheet("""
            QSlider::groove:horizontal {
                border: 1px solid #d1d5db;
                height: 8px;
                background: #f3f4f6;
                border-radius: 4px;
            }
            QSlider::handle:horizontal {
                background: #991b1b;
                border: none;
                width: 18px;
                margin: -5px 0;
                border-radius: 9px;
            }
            QSlider::sub-page:horizontal {
                background: #fca5a5;
                border-radius: 4px;
            }
        """)
        self.discharge_slider.valueChanged.connect(
            lambda v: (self.discharge_label.setText(self.discharge_options[v]), self._update_purpose_preview())
        )
        input_layout.addWidget(self.discharge_slider)

        layout.addWidget(input_container)

        layout.addStretch()
        popup.setWidget(content)
        return popup

    def _get_patient_gender(self) -> str:
        """Get patient gender from the form, default to empty (they/them)."""
        if hasattr(self, 'gender_male') and self.gender_male.isChecked():
            return "male"
        elif hasattr(self, 'gender_female') and self.gender_female.isChecked():
            return "female"
        return ""  # Default to they/them

    def _update_purpose_preview(self):
        """Update the purpose preview with generated narrative."""
        if not hasattr(self, 'purpose_preview'):
            return

        # Get pronouns based on patient gender
        p = pronouns_from_gender(self._get_patient_gender())
        parts = []

        # 1. Purpose narrative
        if hasattr(self, 'purpose_radios'):
            if self.purpose_radios.get("starting") and self.purpose_radios["starting"].isChecked():
                parts.append("The purpose of leave is starting meaningful testing in the community looking toward progression to possible unescorted leave.")
            elif self.purpose_radios.get("continuing") and self.purpose_radios["continuing"].isChecked():
                parts.append(f"{p['subj']} {p['have']} already had some leave granted so the aim would be to continue to build on this.")
            elif self.purpose_radios.get("unescorted") and self.purpose_radios["unescorted"].isChecked():
                parts.append("The aim of leave is to move from escorted to unescorted to allow further independence and rehabilitation.")
            elif self.purpose_radios.get("rehabilitation") and self.purpose_radios["rehabilitation"].isChecked():
                parts.append(f"The leave is to build on {p['pos']} rehabilitation process.")

        # 2. Location narrative
        if hasattr(self, 'location_checkboxes'):
            locations = []
            if self.location_checkboxes.get("ground") and self.location_checkboxes["ground"].isChecked():
                locations.append("the hospital grounds")
            if self.location_checkboxes.get("local") and self.location_checkboxes["local"].isChecked():
                locations.append("the local area")
            if self.location_checkboxes.get("community") and self.location_checkboxes["community"].isChecked():
                locations.append("the wider community")
            if self.location_checkboxes.get("family") and self.location_checkboxes["family"].isChecked():
                locations.append("family residence")

            if locations:
                if len(locations) == 1:
                    parts.append(f"Leave would take place within {locations[0]}.")
                else:
                    loc_text = ", ".join(locations[:-1]) + " and " + locations[-1]
                    parts.append(f"Leave would take place within {loc_text}.")

        # Exclusion zone
        if hasattr(self, 'exclusion_yes') and self.exclusion_yes.isChecked():
            parts.append("The leave is close to/within the exclusion zone and this will be monitored closely by the team.")
        elif hasattr(self, 'exclusion_no') and self.exclusion_no.isChecked():
            parts.append("There are no concerns regarding the exclusion zone with this leave.")
        elif hasattr(self, 'exclusion_na') and self.exclusion_na.isChecked():
            parts.append("There is no exclusion zone with this patient.")

        # 3. Discharge planning narrative
        if hasattr(self, 'discharge_slider'):
            discharge_idx = self.discharge_slider.value()

            if discharge_idx == 0:  # Not started
                parts.append("Discharge planning has not yet commenced and leave would be an early step in this process.")
            elif discharge_idx == 1:  # Early stages
                parts.append("Discharge planning is in its early stages and leave would be an important step in building toward this.")
            elif discharge_idx == 2:  # In progress
                parts.append("Discharge planning is currently in progress and leave would be an important step in this.")
            elif discharge_idx == 3:  # Almost completed
                parts.append("Discharge planning is almost complete and leave would support the final stages of preparation.")
            elif discharge_idx == 4:  # Completed
                parts.append("Discharge planning is complete and leave forms part of the transition plan.")

        # Join with single space for flowing narrative
        text = " ".join(parts)
        self.purpose_preview.setText(text)
        # Auto-sync to card - preserve user additions
        if "purpose" in self.cards and text:
            self._update_text_preserving_additions(self.cards["purpose"].editor, text, "purpose")

    def _create_overnight_popup(self) -> QWidget:
        """Create unescorted overnight leave popup - auto-syncs to card."""
        popup = QScrollArea()
        popup.setWidgetResizable(True)
        popup.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        popup.setStyleSheet("QScrollArea { border: none; background: white; } QWidget { background: white; }")

        content = QWidget()
        layout = QVBoxLayout(content)
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(8)

        # Preview widget showing generated text (visible so user can verify card content)
        self.overnight_preview = QLabel("(No content yet...)")
        self.overnight_preview.setWordWrap(True)
        self.overnight_preview.setStyleSheet(
            "QLabel { background: #f0fdf4; border: 1px solid #86efac; border-radius: 8px; "
            "padding: 12px; font-size: 15px; color: #166534; line-height: 1.4; }"
        )
        self.overnight_preview.setMinimumHeight(40)
        layout.addWidget(self.overnight_preview)

        # === INPUT SECTION ===
        input_frame = QFrame()
        input_frame.setStyleSheet("QFrame { background: transparent; }")
        input_layout = QVBoxLayout(input_frame)
        input_layout.setContentsMargins(0, 0, 0, 0)
        input_layout.setSpacing(8)

        # === OVERNIGHT LEAVE - Yes/NA ===
        input_layout.addWidget(self._styled_label("<b>Unescorted overnight leave required:</b>"))
        self.overnight_main_group = QButtonGroup(self)
        overnight_main_row = QHBoxLayout()
        self.overnight_yes = QRadioButton("Yes")
        self.overnight_na = QRadioButton("N/A")
        self.overnight_yes.setStyleSheet("""
            QRadioButton {
                font-size: 17px;
                background: transparent;
            }
            QRadioButton::indicator {
                width: 18px;
                height: 18px;
            }
        """)
        self.overnight_na.setStyleSheet("""
            QRadioButton {
                font-size: 17px;
                background: transparent;
            }
            QRadioButton::indicator {
                width: 18px;
                height: 18px;
            }
        """)
        self.overnight_main_group.addButton(self.overnight_yes)
        self.overnight_main_group.addButton(self.overnight_na)
        overnight_main_row.addWidget(self.overnight_yes)
        overnight_main_row.addWidget(self.overnight_na)
        overnight_main_row.addStretch()
        input_layout.addLayout(overnight_main_row)

        # === DETAILS CONTAINER (shown when Yes) ===
        self.overnight_details_container = QFrame()
        self.overnight_details_container.setStyleSheet("""
            QFrame { background: #f3f4f6; border: none; border-radius: 8px; }
            QLabel { background: #f3f4f6; border: none; font-size: 16px; }
            QRadioButton, QCheckBox { background: #f3f4f6; border: none; font-size: 16px; }
            QLineEdit { font-size: 17px; }
        """)
        details_layout = QVBoxLayout(self.overnight_details_container)
        details_layout.setContentsMargins(8, 8, 8, 8)
        details_layout.setSpacing(6)

        # === COLLAPSE 1: Accommodation ===
        self.accom_section = CollapsibleSection("1. Accommodation", start_collapsed=True)
        self.accom_section.set_content_height(380)
        accom_content = QFrame()
        accom_content.setStyleSheet("QFrame { background: #f3f4f6; } QLabel { background: #f3f4f6; }")
        accom_layout = QVBoxLayout(accom_content)
        accom_layout.setContentsMargins(8, 8, 8, 8)
        accom_layout.setSpacing(6)

        # Accommodation Type
        accom_layout.addWidget(self._styled_label("Type:"))
        self.accom_group = QButtonGroup(self)
        self.accom_24hr = QRadioButton("24 hour supported")
        self.accom_9to5 = QRadioButton("9-5 supported")
        self.accom_independent = QRadioButton("Independent")
        self.accom_family = QRadioButton("Family")
        self.accom_group.addButton(self.accom_24hr)
        self.accom_group.addButton(self.accom_9to5)
        self.accom_group.addButton(self.accom_independent)
        self.accom_group.addButton(self.accom_family)
        for rb in [self.accom_24hr, self.accom_9to5, self.accom_independent, self.accom_family]:
            rb.setStyleSheet("""
                QRadioButton {
                    font-size: 17px;
                    background: transparent;
                }
                QRadioButton::indicator {
                    width: 18px;
                    height: 18px;
                }
            """)
            rb.toggled.connect(self._update_overnight_preview)
            accom_layout.addWidget(rb)

        # Address
        accom_layout.addWidget(self._styled_label("Address:"))
        self.overnight_address = QLineEdit()
        self.overnight_address.setPlaceholderText("Enter accommodation address...")
        self.overnight_address.setStyleSheet("background: white; color: #1f2937; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 17px;")
        self.overnight_address.textChanged.connect(self._update_overnight_preview)
        accom_layout.addWidget(self.overnight_address)

        # Prior to Recall
        accom_layout.addWidget(self._styled_label("Address prior to recall:"))
        self.prior_recall_group = QButtonGroup(self)
        prior_row = QHBoxLayout()
        self.prior_recall_yes = QRadioButton("Yes")
        self.prior_recall_no = QRadioButton("No")
        self.prior_recall_group.addButton(self.prior_recall_yes)
        self.prior_recall_group.addButton(self.prior_recall_no)
        self.prior_recall_yes.toggled.connect(self._update_overnight_preview)
        self.prior_recall_no.toggled.connect(self._update_overnight_preview)
        prior_row.addWidget(self.prior_recall_yes)
        prior_row.addWidget(self.prior_recall_no)
        prior_row.addStretch()
        accom_layout.addLayout(prior_row)

        # Linked to Index Offence
        accom_layout.addWidget(self._styled_label("Linked to index offence:"))
        self.index_link_group = QButtonGroup(self)
        index_row = QHBoxLayout()
        self.index_link_yes = QRadioButton("Yes")
        self.index_link_no = QRadioButton("No")
        self.index_link_group.addButton(self.index_link_yes)
        self.index_link_group.addButton(self.index_link_no)
        self.index_link_yes.toggled.connect(self._update_overnight_preview)
        self.index_link_no.toggled.connect(self._update_overnight_preview)
        index_row.addWidget(self.index_link_yes)
        index_row.addWidget(self.index_link_no)
        index_row.addStretch()
        accom_layout.addLayout(index_row)

        self.accom_section.set_content(accom_content)
        details_layout.addWidget(self.accom_section)

        # === COLLAPSE 2: Support ===
        self.support_section = CollapsibleSection("2. Support", start_collapsed=True)
        self.support_section.set_content_height(280)
        support_content = QFrame()
        support_content.setStyleSheet("QFrame { background: #f3f4f6; } QLabel { background: #f3f4f6; } QCheckBox { background: #f3f4f6; }")
        support_layout = QVBoxLayout(support_content)
        support_layout.setContentsMargins(8, 8, 8, 8)
        support_layout.setSpacing(6)

        self.support_staff_cb = QCheckBox("Staff at the accommodation")
        self.support_cmht_cb = QCheckBox("CMHT")
        self.support_inpatient_cb = QCheckBox("Inpatient Team")
        self.support_family_cb = QCheckBox("Family")

        for cb in [self.support_staff_cb, self.support_cmht_cb, self.support_inpatient_cb, self.support_family_cb]:
            cb.stateChanged.connect(self._update_overnight_preview)
            support_layout.addWidget(cb)

        self.support_section.set_content(support_content)
        details_layout.addWidget(self.support_section)

        # === COLLAPSE 3: Number of Nights ===
        self.nights_section = CollapsibleSection("3. Number of Nights", start_collapsed=True)
        self.nights_section.set_content_height(280)
        nights_content = QFrame()
        nights_content.setStyleSheet("QFrame { background: #f3f4f6; } QLabel { background: #f3f4f6; }")
        nights_layout = QVBoxLayout(nights_content)
        nights_layout.setContentsMargins(8, 8, 8, 8)
        nights_layout.setSpacing(6)

        self.overnight_weeks_data = {}
        nights_row = QHBoxLayout()
        nights_row.addWidget(QLabel("Week:"))
        self.week_dropdown = QComboBox()
        self.week_dropdown.addItems([str(i) for i in range(1, 11)])
        self.week_dropdown.setStyleSheet("""
            QComboBox { background-color: white; color: black; padding: 4px; border: 1px solid #d1d5db; border-radius: 4px; min-width: 70px; }
            QComboBox::drop-down { border: none; }
            QComboBox QAbstractItemView { background-color: white; color: black; selection-background-color: #e5e7eb; selection-color: black; }
        """)
        nights_row.addWidget(self.week_dropdown)
        nights_row.addWidget(QLabel("Nights:"))
        self.nights_dropdown = QComboBox()
        self.nights_dropdown.addItems([str(i) for i in range(1, 8)])
        self.nights_dropdown.setStyleSheet("""
            QComboBox { background-color: white; color: black; padding: 4px; border: 1px solid #d1d5db; border-radius: 4px; min-width: 70px; }
            QComboBox::drop-down { border: none; }
            QComboBox QAbstractItemView { background-color: white; color: black; selection-background-color: #e5e7eb; selection-color: black; }
        """)
        nights_row.addWidget(self.nights_dropdown)
        nights_row.addStretch()
        nights_layout.addLayout(nights_row)

        # Auto-update on dropdown change
        def on_nights_changed():
            week = int(self.week_dropdown.currentText())
            nights = int(self.nights_dropdown.currentText())
            self.overnight_weeks_data[week] = nights
            # Update summary label
            summary_parts = [f"Wk {w}: {n}n" for w, n in sorted(self.overnight_weeks_data.items())]
            self.nights_summary_label.setText(", ".join(summary_parts))
            self._update_overnight_preview()

        self.week_dropdown.currentIndexChanged.connect(on_nights_changed)
        self.nights_dropdown.currentIndexChanged.connect(on_nights_changed)

        self.nights_summary_label = QLabel("")
        self.nights_summary_label.setStyleSheet("font-size: 13px; color: #374151; font-style: italic; background: #f3f4f6;")
        nights_layout.addWidget(self.nights_summary_label)

        self.nights_section.set_content(nights_content)
        details_layout.addWidget(self.nights_section)

        # === Discharge Address (not collapsible, always visible) ===
        discharge_frame = QFrame()
        discharge_frame.setStyleSheet("QFrame { background: #f3f4f6; } QLabel { background: #f3f4f6; }")
        discharge_layout_inner = QVBoxLayout(discharge_frame)
        discharge_layout_inner.setContentsMargins(0, 8, 0, 0)
        discharge_layout_inner.setSpacing(4)

        discharge_layout_inner.addWidget(QLabel("Leave to proposed discharge address:"))
        self.discharge_addr_group = QButtonGroup(self)
        discharge_row = QHBoxLayout()
        self.discharge_addr_yes = QRadioButton("Yes")
        self.discharge_addr_no = QRadioButton("No")
        self.discharge_addr_group.addButton(self.discharge_addr_yes)
        self.discharge_addr_group.addButton(self.discharge_addr_no)
        self.discharge_addr_yes.toggled.connect(self._update_overnight_preview)
        self.discharge_addr_no.toggled.connect(self._update_overnight_preview)
        discharge_row.addWidget(self.discharge_addr_yes)
        discharge_row.addWidget(self.discharge_addr_no)
        discharge_row.addStretch()
        discharge_layout_inner.addLayout(discharge_row)

        details_layout.addWidget(discharge_frame)

        self.overnight_details_container.setVisible(False)
        input_layout.addWidget(self.overnight_details_container)

        # Add input frame to main layout
        layout.addWidget(input_frame)

        # Connect Yes/NA to show/hide details
        def on_overnight_main_changed():
            if self.overnight_yes.isChecked():
                self.overnight_details_container.setVisible(True)
            else:
                self.overnight_details_container.setVisible(False)
            self._update_overnight_preview()

        self.overnight_yes.toggled.connect(on_overnight_main_changed)
        self.overnight_na.toggled.connect(on_overnight_main_changed)

        layout.addStretch()
        popup.setWidget(content)
        return popup

    def _update_overnight_preview(self):
        """Update the overnight leave preview with generated narrative."""
        if not hasattr(self, 'overnight_preview'):
            return

        p = pronouns_from_gender(self._get_patient_gender())
        parts = []

        # Check if N/A selected
        if hasattr(self, 'overnight_na') and self.overnight_na.isChecked():
            self.overnight_preview.setText("N/A")
            # Auto-sync N/A to card - preserve user additions
            if "overnight" in self.cards:
                self._update_text_preserving_additions(self.cards["overnight"].editor, "N/A", "overnight")
            # Reset all related leave sections (3c, 3e, 3f, 3g, 3h) except this one
            self._reset_leave_sections(exclude='overnight')
            return

        if not (hasattr(self, 'overnight_yes') and self.overnight_yes.isChecked()):
            self.overnight_preview.setText("")
            return

        # Accommodation type
        if hasattr(self, 'accom_24hr') and self.accom_24hr.isChecked():
            parts.append(f"{p['subj']} will be staying at 24 hour supported accommodation.")
        elif hasattr(self, 'accom_9to5') and self.accom_9to5.isChecked():
            parts.append(f"{p['subj']} will be staying at 9-5 supported accommodation.")
        elif hasattr(self, 'accom_independent') and self.accom_independent.isChecked():
            parts.append(f"{p['subj']} will be staying at independent accommodation.")
        elif hasattr(self, 'accom_family') and self.accom_family.isChecked():
            parts.append(f"{p['subj']} will be staying with family.")

        # Address
        if hasattr(self, 'overnight_address') and self.overnight_address.text().strip():
            parts.append(f"The address is {self.overnight_address.text().strip()}.")

        # Prior to recall
        if hasattr(self, 'prior_recall_yes') and self.prior_recall_yes.isChecked():
            parts.append(f"This was the address prior to recall and we believe it is a suitable disposal currently.")
        elif hasattr(self, 'prior_recall_no') and self.prior_recall_no.isChecked():
            parts.append(f"Since recall {p['pos']} needs have changed and {p['subj_l']} will be moved to a new address.")

        # Linked to index offence
        if hasattr(self, 'index_link_yes') and self.index_link_yes.isChecked():
            parts.append("The address is linked to the index offence and appropriate measures have been put in place to manage any ongoing concerns. The team will monitor the risk closely.")
        elif hasattr(self, 'index_link_no') and self.index_link_no.isChecked():
            parts.append("The address has no link to the index offence.")

        # Support
        support_sources = []
        if hasattr(self, 'support_staff_cb') and self.support_staff_cb.isChecked():
            support_sources.append("staff at the accommodation")
        if hasattr(self, 'support_cmht_cb') and self.support_cmht_cb.isChecked():
            support_sources.append("the Community Mental Health Team")
        if hasattr(self, 'support_inpatient_cb') and self.support_inpatient_cb.isChecked():
            support_sources.append("the inpatient team")
        if hasattr(self, 'support_family_cb') and self.support_family_cb.isChecked():
            support_sources.append("family members")

        if support_sources:
            if len(support_sources) == 1:
                parts.append(f"{p['subj']} will be supported by {support_sources[0]}.")
            elif len(support_sources) == 2:
                parts.append(f"{p['subj']} will be supported by {support_sources[0]} and {support_sources[1]}.")
            else:
                parts.append(f"{p['subj']} will be supported by {', '.join(support_sources[:-1])}, and {support_sources[-1]}.")

        # Number of nights
        if hasattr(self, 'overnight_weeks_data') and self.overnight_weeks_data:
            nights_parts = [f"Week {w}: {n} night{'s' if n > 1 else ''}" for w, n in sorted(self.overnight_weeks_data.items())]
            parts.append("Leave schedule: " + ". ".join(nights_parts) + ".")

        # Discharge address
        if hasattr(self, 'discharge_addr_yes') and self.discharge_addr_yes.isChecked():
            parts.append("I can confirm this leave is to the proposed discharge address.")
        elif hasattr(self, 'discharge_addr_no') and self.discharge_addr_no.isChecked():
            parts.append(f"This leave is not to the proposed discharge address but such testing is a necessary part of {p['pos']} rehabilitation.")

        text = " ".join(parts)
        self.overnight_preview.setText(text)
        # Auto-sync to card - preserve user additions
        if "overnight" in self.cards and text:
            self._update_text_preserving_additions(self.cards["overnight"].editor, text, "overnight")

    def _create_escorted_overnight_popup(self) -> QWidget:
        """Create escorted overnight leave popup - auto-syncs to card."""
        popup = QScrollArea()
        popup.setWidgetResizable(True)
        popup.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        popup.setStyleSheet("QScrollArea { border: none; background: white; } QWidget { background: white; }")

        content = QWidget()
        layout = QVBoxLayout(content)
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(8)

        # Preview widget showing generated text (visible so user can verify card content)
        self.escorted_overnight_preview = QLabel("(No content yet...)")
        self.escorted_overnight_preview.setWordWrap(True)
        self.escorted_overnight_preview.setStyleSheet(
            "QLabel { background: #f0fdf4; border: 1px solid #86efac; border-radius: 8px; "
            "padding: 12px; font-size: 15px; color: #166534; line-height: 1.4; }"
        )
        self.escorted_overnight_preview.setMinimumHeight(40)
        layout.addWidget(self.escorted_overnight_preview)

        # === INPUT SECTION ===
        input_frame = QFrame()
        input_frame.setStyleSheet("QFrame { background: transparent; }")
        input_layout = QVBoxLayout(input_frame)
        input_layout.setContentsMargins(0, 0, 0, 0)
        input_layout.setSpacing(8)

        # === ESCORTED OVERNIGHT LEAVE - Yes/NA ===
        input_layout.addWidget(self._styled_label("<b>Escorted overnight leave required:</b>"))
        self.escorted_overnight_main_group = QButtonGroup(self)
        escorted_main_row = QHBoxLayout()
        self.escorted_overnight_yes = QRadioButton("Yes")
        self.escorted_overnight_na = QRadioButton("N/A")
        self.escorted_overnight_yes.setStyleSheet("""
            QRadioButton {
                font-size: 17px;
                background: transparent;
            }
            QRadioButton::indicator {
                width: 18px;
                height: 18px;
            }
        """)
        self.escorted_overnight_na.setStyleSheet("""
            QRadioButton {
                font-size: 17px;
                background: transparent;
            }
            QRadioButton::indicator {
                width: 18px;
                height: 18px;
            }
        """)
        self.escorted_overnight_main_group.addButton(self.escorted_overnight_yes)
        self.escorted_overnight_main_group.addButton(self.escorted_overnight_na)
        escorted_main_row.addWidget(self.escorted_overnight_yes)
        escorted_main_row.addWidget(self.escorted_overnight_na)
        escorted_main_row.addStretch()
        input_layout.addLayout(escorted_main_row)

        # === DETAILS CONTAINER (shown when Yes) ===
        self.escorted_overnight_details_container = QFrame()
        self.escorted_overnight_details_container.setStyleSheet("QFrame { background: #f3f4f6; border-radius: 8px; } QLabel { background: #f3f4f6; border: none; font-size: 16px; } QRadioButton, QCheckBox { background: #f3f4f6; border: none; font-size: 16px; } QLineEdit { font-size: 17px; }")
        details_outer_layout = QVBoxLayout(self.escorted_overnight_details_container)
        details_outer_layout.setContentsMargins(12, 12, 12, 12)
        details_outer_layout.setSpacing(12)

        # === 1. Capacity for residence/leave ===
        details_outer_layout.addWidget(self._styled_label("<b>Capacity for residence/leave:</b>"))
        self.capacity_group = QButtonGroup(self)
        capacity_row = QHBoxLayout()
        self.capacity_yes = QRadioButton("Yes")
        self.capacity_no = QRadioButton("No")
        self.capacity_group.addButton(self.capacity_yes)
        self.capacity_group.addButton(self.capacity_no)
        capacity_row.addWidget(self.capacity_yes)
        capacity_row.addWidget(self.capacity_no)
        capacity_row.addStretch()
        details_outer_layout.addLayout(capacity_row)

        # === Container for No path (DoLS) ===
        self.dols_container = QFrame()
        self.dols_container.setStyleSheet("QFrame { background: #fef3c7; border: 1px solid #f59e0b; border-radius: 6px; } QLabel { background: transparent; border: none; font-size: 16px; } QRadioButton { background: transparent; border: none; font-size: 16px; }")
        dols_layout = QVBoxLayout(self.dols_container)
        dols_layout.setContentsMargins(10, 8, 10, 8)
        dols_layout.setSpacing(6)

        dols_layout.addWidget(self._styled_label("<b>Plan for DoLS on discharge:</b>"))
        self.dols_group = QButtonGroup(self)
        dols_row = QHBoxLayout()
        self.dols_yes = QRadioButton("Yes")
        self.dols_no = QRadioButton("No")
        self.dols_group.addButton(self.dols_yes)
        self.dols_group.addButton(self.dols_no)
        self.dols_yes.toggled.connect(self._update_escorted_overnight_preview)
        self.dols_no.toggled.connect(self._update_escorted_overnight_preview)
        dols_row.addWidget(self.dols_yes)
        dols_row.addWidget(self.dols_no)
        dols_row.addStretch()
        dols_layout.addLayout(dols_row)

        self.dols_container.setVisible(False)
        details_outer_layout.addWidget(self.dols_container)

        # === Container for Yes path (Initial testing) ===
        self.initial_testing_container = QFrame()
        self.initial_testing_container.setStyleSheet("QFrame { background: #d1fae5; border: 1px solid #10b981; border-radius: 6px; } QLabel { background: transparent; border: none; font-size: 16px; } QRadioButton { background: transparent; border: none; font-size: 16px; }")
        testing_layout = QVBoxLayout(self.initial_testing_container)
        testing_layout.setContentsMargins(10, 8, 10, 8)
        testing_layout.setSpacing(6)

        testing_layout.addWidget(self._styled_label("<b>Is this initial testing before further extended leave?</b>"))
        self.initial_testing_group = QButtonGroup(self)
        testing_row = QHBoxLayout()
        self.initial_testing_yes = QRadioButton("Yes")
        self.initial_testing_no = QRadioButton("No")
        self.initial_testing_group.addButton(self.initial_testing_yes)
        self.initial_testing_group.addButton(self.initial_testing_no)
        self.initial_testing_yes.toggled.connect(self._update_escorted_overnight_preview)
        self.initial_testing_no.toggled.connect(self._update_escorted_overnight_preview)
        testing_row.addWidget(self.initial_testing_yes)
        testing_row.addWidget(self.initial_testing_no)
        testing_row.addStretch()
        testing_layout.addLayout(testing_row)

        self.initial_testing_container.setVisible(False)
        details_outer_layout.addWidget(self.initial_testing_container)

        # Connect capacity radios to show/hide containers
        def on_capacity_changed():
            if self.capacity_no.isChecked():
                self.dols_container.setVisible(True)
                self.initial_testing_container.setVisible(False)
            elif self.capacity_yes.isChecked():
                self.dols_container.setVisible(False)
                self.initial_testing_container.setVisible(True)
            else:
                self.dols_container.setVisible(False)
                self.initial_testing_container.setVisible(False)
            self._update_escorted_overnight_preview()

        self.capacity_yes.toggled.connect(on_capacity_changed)
        self.capacity_no.toggled.connect(on_capacity_changed)

        # === Discharge Plan Section (always visible within details) ===
        discharge_frame = QFrame()
        discharge_frame.setStyleSheet("QFrame { background: #e0e7ff; border: 1px solid #6366f1; border-radius: 6px; } QLabel { background: transparent; border: none; font-size: 16px; } QCheckBox { background: transparent; border: none; font-size: 16px; }")
        discharge_layout = QVBoxLayout(discharge_frame)
        discharge_layout.setContentsMargins(10, 8, 10, 8)
        discharge_layout.setSpacing(6)

        discharge_layout.addWidget(self._styled_label("<b>How does this fit into discharge plan?</b>"))
        self.discharge_dols_cb = QCheckBox("Discharge on DoLS")
        self.discharge_unescorted_cb = QCheckBox("Discharge after unescorted leave")
        self.discharge_initial_cb = QCheckBox("Initial testing for overnight leave")

        for cb in [self.discharge_dols_cb, self.discharge_unescorted_cb, self.discharge_initial_cb]:
            cb.stateChanged.connect(self._update_escorted_overnight_preview)
            discharge_layout.addWidget(cb)

        details_outer_layout.addWidget(discharge_frame)

        # Hide details container initially
        self.escorted_overnight_details_container.setVisible(False)
        input_layout.addWidget(self.escorted_overnight_details_container)

        # Connect Yes/NA to show/hide details
        def on_escorted_overnight_main_changed():
            if self.escorted_overnight_yes.isChecked():
                self.escorted_overnight_details_container.setVisible(True)
            else:
                self.escorted_overnight_details_container.setVisible(False)
            self._update_escorted_overnight_preview()

        self.escorted_overnight_yes.toggled.connect(on_escorted_overnight_main_changed)
        self.escorted_overnight_na.toggled.connect(on_escorted_overnight_main_changed)

        layout.addWidget(input_frame)

        layout.addStretch()
        popup.setWidget(content)
        return popup

    def _update_escorted_overnight_preview(self):
        """Update the escorted overnight preview with generated narrative."""
        if not hasattr(self, 'escorted_overnight_preview'):
            return

        # Check if N/A selected
        if hasattr(self, 'escorted_overnight_na') and self.escorted_overnight_na.isChecked():
            self.escorted_overnight_preview.setText("N/A")
            # Auto-sync N/A to card - preserve user additions
            if "escorted_overnight" in self.cards:
                self._update_text_preserving_additions(self.cards["escorted_overnight"].editor, "N/A", "escorted_overnight")
            # Reset all related leave sections (3c, 3d, 3f, 3g, 3h) except this one
            self._reset_leave_sections(exclude='escorted_overnight')
            return

        if not (hasattr(self, 'escorted_overnight_yes') and self.escorted_overnight_yes.isChecked()):
            self.escorted_overnight_preview.setText("")
            return

        p = self._get_pronouns()
        parts = []

        # Capacity section
        if hasattr(self, 'capacity_yes') and self.capacity_yes.isChecked():
            parts.append(f"{p['subj']} {p['have']} capacity to make decisions about {p['pos_l']} residence and leave.")
            # Initial testing follow-up
            if hasattr(self, 'initial_testing_yes') and self.initial_testing_yes.isChecked():
                parts.append(f"This escorted overnight leave represents initial testing before further extended leave is considered.")
            elif hasattr(self, 'initial_testing_no') and self.initial_testing_no.isChecked():
                parts.append(f"{p['subj']} {p['have']} already completed initial testing and this leave continues {p['pos_l']} rehabilitation pathway.")
        elif hasattr(self, 'capacity_no') and self.capacity_no.isChecked():
            parts.append(f"{p['subj']} {p['do']} not have capacity to make decisions about {p['pos_l']} residence and leave.")
            # DoLS follow-up
            if hasattr(self, 'dols_yes') and self.dols_yes.isChecked():
                parts.append(f"There is a plan for Deprivation of Liberty Safeguards (DoLS) to be in place on discharge.")
            elif hasattr(self, 'dols_no') and self.dols_no.isChecked():
                parts.append(f"DoLS will not be required on discharge as alternative arrangements are in place.")

        # Discharge plan section
        discharge_parts = []
        if hasattr(self, 'discharge_dols_cb') and self.discharge_dols_cb.isChecked():
            discharge_parts.append("discharge under DoLS")
        if hasattr(self, 'discharge_unescorted_cb') and self.discharge_unescorted_cb.isChecked():
            discharge_parts.append("discharge following a period of unescorted leave")
        if hasattr(self, 'discharge_initial_cb') and self.discharge_initial_cb.isChecked():
            discharge_parts.append("initial testing for overnight leave arrangements")

        if discharge_parts:
            if len(discharge_parts) == 1:
                parts.append(f"This leave fits into {p['pos']} discharge plan as part of {discharge_parts[0]}.")
            elif len(discharge_parts) == 2:
                parts.append(f"This leave fits into {p['pos']} discharge plan as part of {discharge_parts[0]} and {discharge_parts[1]}.")
            else:
                parts.append(f"This leave fits into {p['pos']} discharge plan as part of {', '.join(discharge_parts[:-1])}, and {discharge_parts[-1]}.")

        text = " ".join(parts)
        self.escorted_overnight_preview.setText(text)
        # Auto-sync to card - preserve user additions
        if "escorted_overnight" in self.cards and text:
            self._update_text_preserving_additions(self.cards["escorted_overnight"].editor, text, "escorted_overnight")

    def _create_compassionate_popup(self) -> QWidget:
        """Create compassionate leave popup - auto-syncs to card."""
        popup = QScrollArea()
        popup.setWidgetResizable(True)
        popup.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        popup.setStyleSheet("QScrollArea { border: none; background: white; } QWidget { background: white; }")

        content = QWidget()
        layout = QVBoxLayout(content)
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(8)

        # Preview widget showing generated text (visible so user can verify card content)
        self.compassionate_preview = QLabel("(No content yet...)")
        self.compassionate_preview.setWordWrap(True)
        self.compassionate_preview.setStyleSheet(
            "QLabel { background: #f0fdf4; border: 1px solid #86efac; border-radius: 8px; "
            "padding: 12px; font-size: 15px; color: #166534; line-height: 1.4; }"
        )
        self.compassionate_preview.setMinimumHeight(40)
        layout.addWidget(self.compassionate_preview)

        # === INPUT SECTION ===
        input_frame = QFrame()
        input_frame.setStyleSheet("QFrame { background: #f3f4f6; border-radius: 8px; } QLabel { background: #f3f4f6; border: none; font-size: 16px; } QRadioButton, QCheckBox { background: #f3f4f6; border: none; font-size: 16px; } QTextEdit { font-size: 17px; }")
        input_layout = QVBoxLayout(input_frame)
        input_layout.setContentsMargins(12, 12, 12, 12)
        input_layout.setSpacing(12)

        # === Compassionate Leave Required: Yes/NA ===
        input_layout.addWidget(self._styled_label("<b>Compassionate Leave Required:</b>"))
        self.compassionate_main_group = QButtonGroup(self)
        main_row = QHBoxLayout()
        self.compassionate_yes = QRadioButton("Yes")
        self.compassionate_na = QRadioButton("N/A")
        self.compassionate_yes.setStyleSheet("""
            QRadioButton {
                font-size: 17px;
                background: transparent;
            }
            QRadioButton::indicator {
                width: 18px;
                height: 18px;
            }
        """)
        self.compassionate_na.setStyleSheet("""
            QRadioButton {
                font-size: 17px;
                background: transparent;
            }
            QRadioButton::indicator {
                width: 18px;
                height: 18px;
            }
        """)
        self.compassionate_main_group.addButton(self.compassionate_yes)
        self.compassionate_main_group.addButton(self.compassionate_na)
        main_row.addWidget(self.compassionate_yes)
        main_row.addWidget(self.compassionate_na)
        main_row.addStretch()
        input_layout.addLayout(main_row)

        # === Details container (shown when Yes) ===
        self.compassionate_details_container = QFrame()
        self.compassionate_details_container.setStyleSheet("QFrame { background: transparent; } QLabel { background: transparent; border: none; font-size: 16px; } QRadioButton { background: transparent; border: none; font-size: 16px; }")
        details_layout = QVBoxLayout(self.compassionate_details_container)
        details_layout.setContentsMargins(0, 0, 0, 0)
        details_layout.setSpacing(10)

        # Can this be virtual?
        virtual_frame = QFrame()
        virtual_frame.setStyleSheet("QFrame { background: #e0e7ff; border: 1px solid #6366f1; border-radius: 6px; } QLabel { background: transparent; border: none; font-size: 16px; } QRadioButton { background: transparent; border: none; font-size: 16px; }")
        virtual_layout = QVBoxLayout(virtual_frame)
        virtual_layout.setContentsMargins(10, 8, 10, 8)
        virtual_layout.setSpacing(6)

        virtual_layout.addWidget(self._styled_label("<b>Can this be virtual?</b>"))
        self.virtual_group = QButtonGroup(self)
        virtual_row = QHBoxLayout()
        self.virtual_yes = QRadioButton("Yes")
        self.virtual_no = QRadioButton("No")
        self.virtual_group.addButton(self.virtual_yes)
        self.virtual_group.addButton(self.virtual_no)
        self.virtual_yes.toggled.connect(self._update_compassionate_preview)
        self.virtual_no.toggled.connect(self._update_compassionate_preview)
        virtual_row.addWidget(self.virtual_yes)
        virtual_row.addWidget(self.virtual_no)
        virtual_row.addStretch()
        virtual_layout.addLayout(virtual_row)

        # Reasons (shown when virtual=No)
        self.virtual_reasons_container = QFrame()
        self.virtual_reasons_container.setStyleSheet("QFrame { background: transparent; }")
        reasons_layout = QVBoxLayout(self.virtual_reasons_container)
        reasons_layout.setContentsMargins(0, 4, 0, 0)
        reasons_layout.setSpacing(4)
        reasons_layout.addWidget(self._styled_label("Reasons why virtual is not possible:"))
        self.virtual_reasons = QTextEdit()
        self.virtual_reasons.setPlaceholderText("Explain why virtual attendance is not possible...")
        self.virtual_reasons.setMaximumHeight(80)
        self.virtual_reasons.setStyleSheet("QTextEdit { background: white; border: 1px solid #d1d5db; border-radius: 4px; padding: 8px; font-size: 17px; }")
        self.virtual_reasons.textChanged.connect(self._update_compassionate_preview)
        reasons_layout.addWidget(self.virtual_reasons)
        self.virtual_reasons_container.setVisible(False)
        virtual_layout.addWidget(self.virtual_reasons_container)

        # Connect virtual radios
        def on_virtual_changed():
            self.virtual_reasons_container.setVisible(self.virtual_no.isChecked())
            self._update_compassionate_preview()

        self.virtual_yes.toggled.connect(on_virtual_changed)
        self.virtual_no.toggled.connect(on_virtual_changed)

        details_layout.addWidget(virtual_frame)

        # Details of people affected
        people_frame = QFrame()
        people_frame.setStyleSheet("QFrame { background: #fef3c7; border: 1px solid #f59e0b; border-radius: 6px; } QLabel { background: transparent; border: none; font-size: 16px; }")
        people_layout = QVBoxLayout(people_frame)
        people_layout.setContentsMargins(10, 8, 10, 8)
        people_layout.setSpacing(6)

        people_layout.addWidget(self._styled_label("<b>Details of people affected:</b>"))
        self.people_affected = QTextEdit()
        self.people_affected.setPlaceholderText("Enter details of family members or others affected...")
        self.people_affected.setMaximumHeight(80)
        self.people_affected.setStyleSheet("QTextEdit { background: white; border: 1px solid #d1d5db; border-radius: 4px; padding: 8px; font-size: 17px; }")
        self.people_affected.textChanged.connect(self._update_compassionate_preview)
        people_layout.addWidget(self.people_affected)

        details_layout.addWidget(people_frame)

        # Urgent?
        urgent_frame = QFrame()
        urgent_frame.setStyleSheet("QFrame { background: #fee2e2; border: 1px solid #ef4444; border-radius: 6px; } QLabel { background: transparent; border: none; font-size: 16px; } QRadioButton { background: transparent; border: none; font-size: 16px; }")
        urgent_layout = QVBoxLayout(urgent_frame)
        urgent_layout.setContentsMargins(10, 8, 10, 8)
        urgent_layout.setSpacing(6)

        urgent_layout.addWidget(self._styled_label("<b>Urgent:</b>"))
        self.urgent_group = QButtonGroup(self)
        urgent_row = QHBoxLayout()
        self.urgent_yes = QRadioButton("Yes")
        self.urgent_no = QRadioButton("No")
        self.urgent_group.addButton(self.urgent_yes)
        self.urgent_group.addButton(self.urgent_no)
        self.urgent_yes.toggled.connect(self._update_compassionate_preview)
        self.urgent_no.toggled.connect(self._update_compassionate_preview)
        urgent_row.addWidget(self.urgent_yes)
        urgent_row.addWidget(self.urgent_no)
        urgent_row.addStretch()
        urgent_layout.addLayout(urgent_row)

        details_layout.addWidget(urgent_frame)

        self.compassionate_details_container.setVisible(False)
        input_layout.addWidget(self.compassionate_details_container)

        # Connect main Yes/NA
        def on_compassionate_main_changed():
            self.compassionate_details_container.setVisible(self.compassionate_yes.isChecked())
            self._update_compassionate_preview()

        self.compassionate_yes.toggled.connect(on_compassionate_main_changed)
        self.compassionate_na.toggled.connect(on_compassionate_main_changed)

        layout.addWidget(input_frame)

        layout.addStretch()
        popup.setWidget(content)
        return popup

    def _update_compassionate_preview(self):
        """Update the compassionate leave preview with generated narrative."""
        if not hasattr(self, 'compassionate_preview'):
            return

        p = self._get_pronouns()
        parts = []

        if hasattr(self, 'compassionate_na') and self.compassionate_na.isChecked():
            parts.append("Compassionate leave is not applicable at this time.")
        elif hasattr(self, 'compassionate_yes') and self.compassionate_yes.isChecked():
            parts.append("Compassionate leave is being requested.")

            # Virtual
            if hasattr(self, 'virtual_yes') and self.virtual_yes.isChecked():
                parts.append("This visit can be conducted virtually.")
            elif hasattr(self, 'virtual_no') and self.virtual_no.isChecked():
                reasons = self.virtual_reasons.toPlainText().strip() if hasattr(self, 'virtual_reasons') else ""
                if reasons:
                    parts.append(f"A virtual visit is not possible because {reasons.lower() if not reasons[0].isupper() else reasons}")
                else:
                    parts.append("A virtual visit is not possible in this case.")

            # People affected
            if hasattr(self, 'people_affected'):
                people = self.people_affected.toPlainText().strip()
                if people:
                    parts.append(f"The people affected are: {people}")

            # Urgent
            if hasattr(self, 'urgent_yes') and self.urgent_yes.isChecked():
                parts.append("This request is urgent and requires expedited consideration.")
            elif hasattr(self, 'urgent_no') and self.urgent_no.isChecked():
                parts.append("This request is not urgent.")

        text = " ".join(parts)
        self.compassionate_preview.setText(text)
        # Auto-sync to card - preserve user additions
        if "compassionate" in self.cards and text:
            self._update_text_preserving_additions(self.cards["compassionate"].editor, text, "compassionate")

    def _reset_leave_sections(self, exclude=None):
        """Reset all leave-related sections (3c, 3d, 3e, 3f, 3g, 3h) to initial empty state."""
        print(f"[MOJ-LEAVE] RESET: Starting reset of leave sections (exclude={exclude})")

        # Block signals to prevent cascading updates during reset
        widgets_to_block = []
        for attr in ['purpose_text', 'overnight_yes', 'overnight_na', 'escorted_overnight_yes',
                     'escorted_overnight_na', 'compassionate_yes', 'compassionate_na',
                     'accom_24hr', 'accom_9to5', 'accom_independent', 'accom_family',
                     'capacity_yes', 'capacity_no', 'dols_yes', 'dols_no',
                     'initial_testing_yes', 'initial_testing_no',
                     'discharge_dols_cb', 'discharge_unescorted_cb', 'discharge_initial_cb',
                     'comp_funeral_cb', 'comp_hospital_cb', 'comp_family_cb', 'comp_other_cb',
                     'urgent_yes', 'urgent_no', 'leaves_dropdown', 'frequency_dropdown', 'duration_dropdown',
                     'ground_cb', 'local_cb', 'community_cb', 'extended_cb', 'overnight_cb',
                     'medical_cb', 'court_cb', 'compassionate_cb',
                     'ground_slider', 'local_slider', 'community_slider', 'extended_slider', 'overnight_slider',
                     'suspended_yes', 'suspended_no', 'suspension_details', 'procedures_text',
                     # 3c widgets
                     'exclusion_yes', 'exclusion_no', 'exclusion_na', 'discharge_slider',
                     # 3g other leave widgets
                     'leave_medical_cb', 'leave_court_cb', 'leave_compassionate_cb',
                     # 3h widgets
                     'escorts_dropdown']:
            if hasattr(self, attr):
                widget = getattr(self, attr)
                widget.blockSignals(True)
                widgets_to_block.append(widget)

        # Also block signals for dictionary-based checkboxes
        for dict_attr in ['transport_checkboxes', 'pre_leave_checkboxes', 'on_return_checkboxes', 'breach_checkboxes',
                          'purpose_radios', 'location_checkboxes']:
            if hasattr(self, dict_attr):
                for cb in getattr(self, dict_attr).values():
                    cb.blockSignals(True)
                    widgets_to_block.append(cb)

        # Block signals for leave_type_widgets (3g)
        if hasattr(self, 'leave_type_widgets'):
            for widgets in self.leave_type_widgets.values():
                widgets["cb"].blockSignals(True)
                widgets["slider"].blockSignals(True)
                widgets_to_block.append(widgets["cb"])
                widgets_to_block.append(widgets["slider"])

        try:
            # Reset 3c - Purpose of Leave
            if exclude != 'purpose':
                print(f"[MOJ-LEAVE] RESET 3c: purpose_radios exists={hasattr(self, 'purpose_radios')}, location_checkboxes exists={hasattr(self, 'location_checkboxes')}")
                if hasattr(self, 'purpose_text'):
                    self.purpose_text.clear()
                if hasattr(self, 'purpose_preview'):
                    self.purpose_preview.setText("")
                if "purpose" in self.cards and (self._auto_fill_phase or self._selected_card_key == "purpose"):
                    self.cards["purpose"].editor.setPlainText("")
                # Reset purpose radio buttons (stored in purpose_radios dict)
                if hasattr(self, 'purpose_radios'):
                    for radio in self.purpose_radios.values():
                        radio.setAutoExclusive(False)
                        radio.setChecked(False)
                        radio.setAutoExclusive(True)
                # Reset location checkboxes (stored in location_checkboxes dict)
                if hasattr(self, 'location_checkboxes'):
                    for cb in self.location_checkboxes.values():
                        cb.setChecked(False)
                # Reset exclusion zone radios
                for attr in ['exclusion_yes', 'exclusion_no', 'exclusion_na']:
                    if hasattr(self, attr):
                        btn = getattr(self, attr)
                        btn.setAutoExclusive(False)
                        btn.setChecked(False)
                        btn.setAutoExclusive(True)
                # Reset discharge slider and label
                if hasattr(self, 'discharge_slider'):
                    self.discharge_slider.setValue(0)
                if hasattr(self, 'discharge_label') and hasattr(self, 'discharge_options'):
                    self.discharge_label.setText(self.discharge_options[0])
                print(f"[MOJ-LEAVE] RESET 3c: Done")

            # Reset 3d - Overnight
            if exclude != 'overnight':
                print(f"[MOJ-LEAVE] RESET 3d: overnight_yes exists={hasattr(self, 'overnight_yes')}")
                if hasattr(self, 'overnight_yes'):
                    self.overnight_yes.setAutoExclusive(False)
                    self.overnight_yes.setChecked(False)
                    self.overnight_yes.setAutoExclusive(True)
                if hasattr(self, 'overnight_na'):
                    self.overnight_na.setAutoExclusive(False)
                    self.overnight_na.setChecked(False)
                    self.overnight_na.setAutoExclusive(True)
                print(f"[MOJ-LEAVE] RESET 3d: Done")
                if hasattr(self, 'overnight_details_container'):
                    self.overnight_details_container.setVisible(False)
                for attr in ['accom_24hr', 'accom_9to5', 'accom_independent', 'accom_family']:
                    if hasattr(self, attr):
                        btn = getattr(self, attr)
                        btn.setAutoExclusive(False)
                        btn.setChecked(False)
                        btn.setAutoExclusive(True)
                if hasattr(self, 'overnight_address'):
                    self.overnight_address.clear()
                if hasattr(self, 'overnight_preview'):
                    self.overnight_preview.setText("")
                if "overnight" in self.cards and (self._auto_fill_phase or self._selected_card_key == "overnight"):
                    self.cards["overnight"].editor.setPlainText("")

            # Reset 3e - Escorted Overnight
            if exclude != 'escorted_overnight':
                print(f"[MOJ-LEAVE] RESET 3e: escorted_overnight_yes exists={hasattr(self, 'escorted_overnight_yes')}")
                if hasattr(self, 'escorted_overnight_yes'):
                    self.escorted_overnight_yes.setAutoExclusive(False)
                    self.escorted_overnight_yes.setChecked(False)
                    self.escorted_overnight_yes.setAutoExclusive(True)
                if hasattr(self, 'escorted_overnight_na'):
                    self.escorted_overnight_na.setAutoExclusive(False)
                    self.escorted_overnight_na.setChecked(False)
                    self.escorted_overnight_na.setAutoExclusive(True)
                print(f"[MOJ-LEAVE] RESET 3e: Done")
                if hasattr(self, 'escorted_overnight_details_container'):
                    self.escorted_overnight_details_container.setVisible(False)
                for attr in ['capacity_yes', 'capacity_no', 'dols_yes', 'dols_no', 'initial_testing_yes', 'initial_testing_no']:
                    if hasattr(self, attr):
                        btn = getattr(self, attr)
                        btn.setAutoExclusive(False)
                        btn.setChecked(False)
                        btn.setAutoExclusive(True)
                for attr in ['discharge_dols_cb', 'discharge_unescorted_cb', 'discharge_initial_cb']:
                    if hasattr(self, attr):
                        getattr(self, attr).setChecked(False)
                if hasattr(self, 'escorted_overnight_preview'):
                    self.escorted_overnight_preview.setText("")
                if "escorted_overnight" in self.cards and (self._auto_fill_phase or self._selected_card_key == "escorted_overnight"):
                    self.cards["escorted_overnight"].editor.setPlainText("")

            # Reset 3f - Compassionate Leave
            if exclude != 'compassionate':
                if hasattr(self, 'compassionate_yes'):
                    self.compassionate_yes.setAutoExclusive(False)
                    self.compassionate_yes.setChecked(False)
                    self.compassionate_yes.setAutoExclusive(True)
                if hasattr(self, 'compassionate_na'):
                    self.compassionate_na.setAutoExclusive(False)
                    self.compassionate_na.setChecked(False)
                    self.compassionate_na.setAutoExclusive(True)
                if hasattr(self, 'compassionate_details_container'):
                    self.compassionate_details_container.setVisible(False)
                for attr in ['comp_funeral_cb', 'comp_hospital_cb', 'comp_family_cb', 'comp_other_cb']:
                    if hasattr(self, attr):
                        getattr(self, attr).setChecked(False)
                for attr in ['urgent_yes', 'urgent_no']:
                    if hasattr(self, attr):
                        btn = getattr(self, attr)
                        btn.setAutoExclusive(False)
                        btn.setChecked(False)
                        btn.setAutoExclusive(True)
                if hasattr(self, 'comp_details'):
                    self.comp_details.clear()
                if hasattr(self, 'compassionate_preview'):
                    self.compassionate_preview.setText("")
                if "compassionate" in self.cards and (self._auto_fill_phase or self._selected_card_key == "compassionate"):
                    self.cards["compassionate"].editor.setPlainText("")

            # Reset 3g - Leave Report
            if exclude != 'leave_report':
                print(f"[MOJ-LEAVE] RESET 3g: leaves_dropdown exists={hasattr(self, 'leaves_dropdown')}, leave_type_widgets exists={hasattr(self, 'leave_type_widgets')}")
                # Clear the state dictionaries that store the leave report data
                if hasattr(self, '_leave_escorted_state'):
                    self._leave_escorted_state = {}
                if hasattr(self, '_leave_unescorted_state'):
                    self._leave_unescorted_state = {}
                if hasattr(self, 'leave_escorted_radio'):
                    self.leave_escorted_radio.setChecked(True)
                if hasattr(self, 'leaves_dropdown'):
                    self.leaves_dropdown.setCurrentIndex(0)
                if hasattr(self, 'frequency_dropdown'):
                    self.frequency_dropdown.setCurrentIndex(0)
                if hasattr(self, 'duration_dropdown'):
                    self.duration_dropdown.setCurrentIndex(0)
                # Reset leave type widgets (checkboxes and sliders)
                if hasattr(self, 'leave_type_widgets'):
                    for key, widgets in self.leave_type_widgets.items():
                        widgets["cb"].setChecked(False)
                        widgets["slider"].setValue(0)
                        widgets["slider"].setEnabled(False)
                        widgets["label"].setText("0%")
                        print(f"[MOJ-LEAVE] RESET 3g: Reset leave_type_widgets[{key}]")
                # Reset other leave checkboxes
                for attr in ['leave_medical_cb', 'leave_court_cb', 'leave_compassionate_cb']:
                    if hasattr(self, attr):
                        getattr(self, attr).setChecked(False)
                # Reset suspension radio buttons
                for attr in ['suspended_yes', 'suspended_no']:
                    if hasattr(self, attr):
                        btn = getattr(self, attr)
                        btn.setAutoExclusive(False)
                        btn.setChecked(False)
                        btn.setAutoExclusive(True)
                if hasattr(self, 'suspension_details'):
                    self.suspension_details.clear()
                if hasattr(self, 'leave_report_preview'):
                    self.leave_report_preview.setText("")
                if "leave_report" in self.cards and (self._auto_fill_phase or self._selected_card_key == "leave_report"):
                    self.cards["leave_report"].editor.setPlainText("")
                print(f"[MOJ-LEAVE] RESET 3g: Done")

            # Reset 3h - Procedures
            if exclude != 'procedures':
                print(f"[MOJ-LEAVE] RESET 3h: escorts_dropdown exists={hasattr(self, 'escorts_dropdown')}")
                if hasattr(self, 'procedures_text'):
                    self.procedures_text.clear()
                if hasattr(self, 'escorts_dropdown'):
                    self.escorts_dropdown.setCurrentIndex(0)
                if hasattr(self, 'transport_checkboxes'):
                    for cb in self.transport_checkboxes.values():
                        cb.setChecked(False)
                if hasattr(self, 'pre_leave_checkboxes'):
                    for cb in self.pre_leave_checkboxes.values():
                        cb.setChecked(False)
                if hasattr(self, 'on_return_checkboxes'):
                    for cb in self.on_return_checkboxes.values():
                        cb.setChecked(False)
                if hasattr(self, 'breach_checkboxes'):
                    for cb in self.breach_checkboxes.values():
                        cb.setChecked(False)
                if hasattr(self, 'procedures_preview'):
                    self.procedures_preview.setText("")
                if "procedures" in self.cards and (self._auto_fill_phase or self._selected_card_key == "procedures"):
                    self.cards["procedures"].editor.setPlainText("")
                print(f"[MOJ-LEAVE] RESET 3h: Done")
        finally:
            # Unblock signals
            for widget in widgets_to_block:
                widget.blockSignals(False)
            print(f"[MOJ-LEAVE] RESET: Complete - unblocked {len(widgets_to_block)} widgets")

            # Re-enable all 3a checkboxes since nothing is selected now
            if hasattr(self, '_update_3a_section_enabled_state'):
                self._update_3a_section_enabled_state()

    def _create_leave_report_popup(self) -> QWidget:
        """Create leave report popup - 3g. Leave report last 2 years."""
        # Initialize state storage for escorted/unescorted entries
        self._leave_escorted_state = {}
        self._leave_unescorted_state = {}
        self._leave_switching = False  # Flag to prevent recursive updates

        popup = QWidget()
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)

        # === HEADER ===
        header_label = QLabel("<b>3g. Leave report last 2 years</b>")
        header_label.setStyleSheet("font-size: 21px; color: #1f2937; padding: 8px; border: none;")
        main_layout.addWidget(header_label)

        # Preview widget showing generated text (visible so user can verify card content)
        self.leave_report_preview = QLabel("(No content yet...)")
        self.leave_report_preview.setWordWrap(True)
        self.leave_report_preview.setStyleSheet(
            "QLabel { background: #f0fdf4; border: 1px solid #86efac; border-radius: 8px; "
            "padding: 12px; font-size: 15px; color: #166534; line-height: 1.4; }"
        )
        self.leave_report_preview.setMinimumHeight(60)
        main_layout.addWidget(self.leave_report_preview)

        # === SCROLLABLE CONTENT ===
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        scroll_area.setStyleSheet("QScrollArea { border: none; background: white; }")

        scroll_content = QWidget()
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setContentsMargins(0, 0, 0, 0)
        scroll_layout.setSpacing(8)

        # === INPUT FIELDS SECTION ===
        self.leave_input_section = CollapsibleSection("Input Fields", start_collapsed=True)
        self.leave_input_section.set_content_height(608)

        input_content = QFrame()
        input_content.setStyleSheet("QFrame { background: #f3f4f6; } QLabel { background: transparent; border: none; font-size: 16px; } QRadioButton, QCheckBox { background: transparent; border: none; font-size: 16px; }")
        input_layout = QVBoxLayout(input_content)
        input_layout.setContentsMargins(10, 10, 10, 10)
        input_layout.setSpacing(8)

        # === ESCORTED/UNESCORTED TOGGLE ===
        escort_frame = QFrame()
        escort_frame.setStyleSheet("QFrame { background: #dbeafe; border: 2px solid #3b82f6; border-radius: 8px; } QLabel { background: transparent; border: none; font-size: 16px; } QRadioButton { background: transparent; border: none; font-size: 16px; }")
        escort_layout = QHBoxLayout(escort_frame)
        escort_layout.setContentsMargins(12, 8, 12, 8)
        escort_layout.setSpacing(16)

        escort_label = QLabel("<b>Leave Type:</b>")
        escort_label.setStyleSheet("font-size: 17px; color: #1e40af;")
        escort_layout.addWidget(escort_label)

        self.leave_escort_group = QButtonGroup(self)
        self.leave_escorted_radio = QRadioButton("Escorted")
        self.leave_unescorted_radio = QRadioButton("Unescorted")
        self.leave_escorted_radio.setStyleSheet("font-weight: 600; font-size: 17px; color: #1e40af;")
        self.leave_unescorted_radio.setStyleSheet("font-weight: 600; font-size: 17px; color: #1e40af;")
        self.leave_escort_group.addButton(self.leave_escorted_radio)
        self.leave_escort_group.addButton(self.leave_unescorted_radio)
        self.leave_escorted_radio.setChecked(True)  # Default to escorted
        escort_layout.addWidget(self.leave_escorted_radio)
        escort_layout.addWidget(self.leave_unescorted_radio)
        escort_layout.addStretch()

        input_layout.addWidget(escort_frame)

        # Row 1: Leaves, Frequency, Duration
        dropdown_style = """
            QComboBox {
                background: white;
                color: black;
                padding: 8px 14px;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                font-size: 13px;
            }
            QComboBox::drop-down { width: 20px; }
            QComboBox QAbstractItemView { background: white; color: black; selection-background-color: #dbeafe; font-size: 13px; }
        """

        row1 = QHBoxLayout()
        leaves_lbl = QLabel("Leaves:")
        leaves_lbl.setStyleSheet("font-size: 16px;")
        row1.addWidget(leaves_lbl)
        self.leaves_dropdown = QComboBox()
        self.leaves_dropdown.addItems([str(i) for i in range(1, 8)])
        self.leaves_dropdown.setMinimumWidth(90)
        self.leaves_dropdown.setStyleSheet(dropdown_style)
        self.leaves_dropdown.currentIndexChanged.connect(self._update_leave_report_preview)
        row1.addWidget(self.leaves_dropdown)
        freq_lbl = QLabel("Freq:")
        freq_lbl.setStyleSheet("font-size: 16px;")
        row1.addWidget(freq_lbl)
        self.frequency_dropdown = QComboBox()
        self.frequency_dropdown.addItems(["Weekly", "2 weekly", "3 weekly", "Monthly", "2 monthly"])
        self.frequency_dropdown.setMinimumWidth(130)
        self.frequency_dropdown.setStyleSheet(dropdown_style)
        self.frequency_dropdown.currentIndexChanged.connect(self._update_leave_report_preview)
        row1.addWidget(self.frequency_dropdown)
        dur_lbl = QLabel("Dur:")
        dur_lbl.setStyleSheet("font-size: 16px;")
        row1.addWidget(dur_lbl)
        self.duration_dropdown = QComboBox()
        self.duration_dropdown.addItems(["30 mins", "1 hour", "2 hours", "3 hours", "4 hours", "5 hours", "6 hours", "7 hours", "8 hours"])
        self.duration_dropdown.setMinimumWidth(120)
        self.duration_dropdown.setStyleSheet(dropdown_style)
        self.duration_dropdown.currentIndexChanged.connect(self._update_leave_report_preview)
        row1.addWidget(self.duration_dropdown)
        row1.addStretch()
        input_layout.addLayout(row1)

        # Leave types with individual linked sliders
        weight_frame = QFrame()
        weight_frame.setStyleSheet("QFrame { background: #e0e7ff; border: 1px solid #6366f1; border-radius: 6px; } QLabel { background: transparent; border: none; font-size: 16px; } QCheckBox { background: transparent; border: none; font-size: 16px; }")
        weight_layout = QVBoxLayout(weight_frame)
        weight_layout.setContentsMargins(10, 8, 10, 8)
        weight_layout.setSpacing(6)

        weight_layout.addWidget(self._styled_label("<b>Leave types & weighting:</b>"))

        # Store leave type data: checkbox, slider, label
        self.leave_type_widgets = {}
        self._updating_sliders = False

        leave_types = [
            ("ground", "Ground"),
            ("local", "Local community"),
            ("community", "Community"),
            ("extended", "Extended community"),
            ("overnight", "Overnight")
        ]

        for key, label in leave_types:
            row = QHBoxLayout()
            row.setSpacing(8)

            cb = QCheckBox(label)
            cb.setFixedWidth(160)
            row.addWidget(cb)

            slider = NoWheelSlider(Qt.Horizontal)
            slider.setMinimum(0)
            slider.setMaximum(100)
            slider.setValue(0)
            slider.setEnabled(False)
            slider.setStyleSheet("QSlider::groove:horizontal { background: #c7d2fe; height: 6px; border-radius: 3px; } QSlider::handle:horizontal { background: #4f46e5; width: 14px; margin: -4px 0; border-radius: 7px; } QSlider:disabled::groove:horizontal { background: #e5e7eb; } QSlider:disabled::handle:horizontal { background: #9ca3af; }")
            row.addWidget(slider, 1)

            pct_label = QLabel("0%")
            pct_label.setFixedWidth(65)
            pct_label.setStyleSheet("font-weight: 600; color: #4f46e5;")
            row.addWidget(pct_label)

            self.leave_type_widgets[key] = {"cb": cb, "slider": slider, "label": pct_label}

            cb.stateChanged.connect(lambda state, k=key: self._on_leave_type_toggled(k, state))
            slider.valueChanged.connect(lambda val, k=key: self._on_leave_slider_changed(k, val))

            weight_layout.addLayout(row)

        input_layout.addWidget(weight_frame)

        # Other leave types
        other_frame = QFrame()
        other_frame.setStyleSheet("QFrame { background: #fef3c7; border: 1px solid #f59e0b; border-radius: 6px; } QLabel { background: transparent; border: none; font-size: 16px; } QCheckBox { background: transparent; border: none; font-size: 16px; }")
        other_layout = QVBoxLayout(other_frame)
        other_layout.setContentsMargins(10, 8, 10, 8)
        other_layout.setSpacing(6)

        other_layout.addWidget(self._styled_label("<b>Other leave:</b>"))
        other_row = QHBoxLayout()
        self.leave_medical_cb = QCheckBox("Medical")
        self.leave_court_cb = QCheckBox("Court")
        self.leave_compassionate_cb = QCheckBox("Compassionate")
        for cb in [self.leave_medical_cb, self.leave_court_cb, self.leave_compassionate_cb]:
            cb.stateChanged.connect(self._update_leave_report_preview)
            other_row.addWidget(cb)
        other_row.addStretch()
        other_layout.addLayout(other_row)

        input_layout.addWidget(other_frame)

        # Leave suspended
        suspended_frame = QFrame()
        suspended_frame.setStyleSheet("QFrame { background: #fee2e2; border: 1px solid #ef4444; border-radius: 6px; } QLabel { background: transparent; border: none; font-size: 16px; } QRadioButton { background: transparent; border: none; font-size: 16px; }")
        suspended_layout = QVBoxLayout(suspended_frame)
        suspended_layout.setContentsMargins(10, 8, 10, 8)
        suspended_layout.setSpacing(6)

        suspended_layout.addWidget(self._styled_label("<b>Leave ever suspended:</b>"))
        self.suspended_group = QButtonGroup(self)
        suspended_row = QHBoxLayout()
        self.suspended_yes = QRadioButton("Yes")
        self.suspended_no = QRadioButton("No")
        self.suspended_group.addButton(self.suspended_yes)
        self.suspended_group.addButton(self.suspended_no)
        suspended_row.addWidget(self.suspended_yes)
        suspended_row.addWidget(self.suspended_no)
        suspended_row.addStretch()
        suspended_layout.addLayout(suspended_row)

        # Suspension details (shown when Yes) - taller
        self.suspension_details_container = QFrame()
        self.suspension_details_container.setStyleSheet("QFrame { background: transparent; } QLabel { background: transparent; border: none; font-size: 16px; }")
        susp_details_layout = QVBoxLayout(self.suspension_details_container)
        susp_details_layout.setContentsMargins(0, 4, 0, 0)
        susp_details_layout.setSpacing(4)
        susp_details_layout.addWidget(self._styled_label("Details:"))
        self.suspension_details = QTextEdit()
        self.suspension_details.setPlaceholderText("Describe the circumstances of leave suspension...")
        self.suspension_details.setMinimumHeight(80)
        self.suspension_details.setStyleSheet("QTextEdit { background: white; border: 1px solid #d1d5db; border-radius: 4px; padding: 8px; font-size: 16px; }")
        self.suspension_details.textChanged.connect(self._update_leave_report_preview)
        susp_details_layout.addWidget(self.suspension_details)
        self.suspension_details_container.setVisible(False)
        suspended_layout.addWidget(self.suspension_details_container)

        def on_suspended_changed():
            self.suspension_details_container.setVisible(self.suspended_yes.isChecked())
            self._update_leave_report_preview()

        self.suspended_yes.toggled.connect(on_suspended_changed)
        self.suspended_no.toggled.connect(on_suspended_changed)

        input_layout.addWidget(suspended_frame)

        # Connect escorted/unescorted toggle to save/restore state
        def on_escort_type_changed():
            if self._leave_switching:
                return
            self._leave_switching = True
            try:
                if self.leave_escorted_radio.isChecked():
                    # Save unescorted state, restore escorted state
                    self._save_leave_state(self._leave_unescorted_state)
                    self._restore_leave_state(self._leave_escorted_state)
                else:
                    # Save escorted state, restore unescorted state
                    self._save_leave_state(self._leave_escorted_state)
                    self._restore_leave_state(self._leave_unescorted_state)
                self._update_leave_report_preview()
            finally:
                self._leave_switching = False

        self.leave_escorted_radio.toggled.connect(on_escort_type_changed)

        self.leave_input_section.set_content(input_content)
        scroll_layout.addWidget(self.leave_input_section)

        # === IMPORTED NOTES SECTION (matching 4a style) ===
        self.leave_import_section = CollapsibleSection("Imported Data", start_collapsed=True)
        self.leave_import_section.set_content_height(525)
        self.leave_import_section._min_height = 60
        self.leave_import_section._max_height = 600
        self.leave_import_section.set_header_style("""
            QFrame {
                background: rgba(255, 248, 220, 0.95);
                border: 1px solid rgba(180, 150, 50, 0.4);
                border-radius: 6px 6px 0 0;
            }
        """)
        self.leave_import_section.set_title_style("""
            QLabel {
                font-size: 14px;
                font-weight: 600;
                color: #806000;
                background: transparent;
                border: none;
            }
        """)

        import_panel = QFrame()
        import_panel.setStyleSheet("""
            QFrame {
                background: rgba(255, 248, 220, 0.95);
                border: 1px solid rgba(180, 150, 50, 0.4);
                border-top: none;
                border-radius: 0 0 12px 12px;
            }
            QCheckBox {
                background: transparent;
                border: none;
                padding: 4px;
                font-size: 14px;
                color: #4a4a4a;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
        """)
        import_panel_layout = QVBoxLayout(import_panel)
        import_panel_layout.setContentsMargins(12, 10, 12, 10)
        import_panel_layout.setSpacing(6)

        # Subtitle with count
        self.leave_import_subtitle = QLabel("Leave evidence from notes (last 2 years)")
        self.leave_import_subtitle.setStyleSheet("font-size: 13px; font-weight: 600; color: #806000; background: transparent; border: none;")
        import_panel_layout.addWidget(self.leave_import_subtitle)

        # Filter tags row (populated dynamically)
        self.leave_filter_row = QHBoxLayout()
        self.leave_filter_row.setSpacing(6)
        self.leave_filter_row.addStretch()
        import_panel_layout.addLayout(self.leave_filter_row)

        # Scrollable content area
        leave_import_scroll = QScrollArea()
        leave_import_scroll.setWidgetResizable(True)
        leave_import_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        leave_import_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        leave_import_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        leave_import_scroll.setStyleSheet("""
            QScrollArea { background: transparent; border: none; }
            QScrollArea > QWidget > QWidget { background: transparent; }
        """)
        leave_import_scroll.setMinimumHeight(180)

        # Content widget for entries
        self.leave_import_content = QWidget()
        self.leave_import_content.setStyleSheet("background: transparent;")
        self.leave_import_layout = QVBoxLayout(self.leave_import_content)
        self.leave_import_layout.setContentsMargins(2, 2, 2, 2)
        self.leave_import_layout.setSpacing(6)
        self.leave_import_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        leave_import_scroll.setWidget(self.leave_import_content)

        # Placeholder
        self.leave_import_placeholder = QLabel("No entries found. Use Import Data to load clinical notes.")
        self.leave_import_placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 13px; background: transparent; border: none;")
        self.leave_import_layout.addWidget(self.leave_import_placeholder)

        import_panel_layout.addWidget(leave_import_scroll, 1)

        # Button row
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(8)

        clear_btn = QPushButton("Clear")
        clear_btn.setStyleSheet("""
            QPushButton { background: rgba(255, 248, 220, 0.95); color: #806000; border: 1px solid rgba(180, 150, 50, 0.4); padding: 8px 16px; border-radius: 6px; font-weight: 500; font-size: 13px; }
            QPushButton:hover { background: #fef3c7; }
        """)
        clear_btn.clicked.connect(self._clear_leave_imports)
        btn_layout.addWidget(clear_btn)

        btn_layout.addStretch()
        import_panel_layout.addLayout(btn_layout)

        # Storage for imported entries and checkboxes
        self.leave_imported_entries = []
        self.leave_import_checkboxes = []
        self._leave_current_filter = None
        self._leave_all_categorized = []

        self.leave_import_section.set_content(import_panel)
        scroll_layout.addWidget(self.leave_import_section)

        scroll_layout.addStretch()
        scroll_area.setWidget(scroll_content)
        main_layout.addWidget(scroll_area, 1)

        return popup

    def _on_leave_type_toggled(self, key, state):
        """Handle leave type checkbox toggle - enable/disable slider and redistribute weights."""
        if not hasattr(self, 'leave_type_widgets'):
            return

        widgets = self.leave_type_widgets[key]
        is_checked = state == Qt.CheckState.Checked.value

        widgets["slider"].setEnabled(is_checked)

        if is_checked:
            self._add_leave_type_weight(key)
        else:
            self._remove_leave_type_weight(key)

        self._update_leave_report_preview()

    def _add_leave_type_weight(self, new_key):
        """Add a new leave type, taking weight proportionally from existing checked items."""
        self._updating_sliders = True

        other_checked = [(k, w["slider"].value()) for k, w in self.leave_type_widgets.items()
                         if w["cb"].isChecked() and k != new_key]

        if not other_checked:
            slider = self.leave_type_widgets[new_key]["slider"]
            slider.blockSignals(True)
            slider.setValue(100)
            slider.blockSignals(False)
            self.leave_type_widgets[new_key]["label"].setText("100%")
        else:
            new_item_share = 1
            remaining = 100 - new_item_share

            total_existing = sum(v for _, v in other_checked)
            if total_existing == 0:
                total_existing = 100

            for k, old_val in other_checked:
                if total_existing > 0:
                    new_val = int((old_val / total_existing) * remaining)
                else:
                    new_val = remaining // len(other_checked)
                slider = self.leave_type_widgets[k]["slider"]
                slider.blockSignals(True)
                slider.setValue(new_val)
                slider.blockSignals(False)
                self.leave_type_widgets[k]["label"].setText(f"{new_val}%")

            slider = self.leave_type_widgets[new_key]["slider"]
            slider.blockSignals(True)
            slider.setValue(new_item_share)
            slider.blockSignals(False)
            self.leave_type_widgets[new_key]["label"].setText(f"{new_item_share}%")

        self._updating_sliders = False

    def _remove_leave_type_weight(self, removed_key):
        """Remove a leave type, distributing its weight to remaining checked items."""
        self._updating_sliders = True

        removed_weight = self.leave_type_widgets[removed_key]["slider"].value()

        slider = self.leave_type_widgets[removed_key]["slider"]
        slider.blockSignals(True)
        slider.setValue(0)
        slider.blockSignals(False)
        self.leave_type_widgets[removed_key]["label"].setText("0%")

        remaining_checked = [(k, w["slider"].value()) for k, w in self.leave_type_widgets.items()
                            if w["cb"].isChecked() and k != removed_key]

        if remaining_checked:
            total_remaining = sum(v for _, v in remaining_checked)
            if total_remaining == 0:
                per_item = removed_weight // len(remaining_checked)
                extra = removed_weight % len(remaining_checked)
                for i, (k, _) in enumerate(remaining_checked):
                    new_val = per_item + (1 if i < extra else 0)
                    slider = self.leave_type_widgets[k]["slider"]
                    slider.blockSignals(True)
                    slider.setValue(new_val)
                    slider.blockSignals(False)
                    self.leave_type_widgets[k]["label"].setText(f"{new_val}%")
            else:
                for k, old_val in remaining_checked:
                    proportion = old_val / total_remaining
                    new_val = old_val + int(removed_weight * proportion)
                    slider = self.leave_type_widgets[k]["slider"]
                    slider.blockSignals(True)
                    slider.setValue(min(100, new_val))
                    slider.blockSignals(False)
                    self.leave_type_widgets[k]["label"].setText(f"{min(100, new_val)}%")

        self._updating_sliders = False

    def _on_leave_slider_changed(self, key, value):
        """Handle slider change - redistribute remaining weight proportionally among other checked items."""
        if self._updating_sliders or not hasattr(self, 'leave_type_widgets'):
            return

        self._updating_sliders = True

        self.leave_type_widgets[key]["label"].setText(f"{value}%")

        others = [(k, w["slider"].value()) for k, w in self.leave_type_widgets.items()
                  if w["cb"].isChecked() and k != key]

        if others:
            remaining = 100 - value
            total_others = sum(v for _, v in others)

            if total_others > 0:
                for k, old_val in others:
                    proportion = old_val / total_others
                    new_val = int(remaining * proportion)
                    slider = self.leave_type_widgets[k]["slider"]
                    slider.blockSignals(True)
                    slider.setValue(new_val)
                    slider.blockSignals(False)
                    self.leave_type_widgets[k]["label"].setText(f"{new_val}%")
            else:
                per_item = remaining // len(others)
                extra = remaining % len(others)
                for i, (k, _) in enumerate(others):
                    new_val = per_item + (1 if i < extra else 0)
                    slider = self.leave_type_widgets[k]["slider"]
                    slider.blockSignals(True)
                    slider.setValue(new_val)
                    slider.blockSignals(False)
                    self.leave_type_widgets[k]["label"].setText(f"{new_val}%")

        self._updating_sliders = False
        self._update_leave_report_preview()

    def _save_leave_state(self, state_dict):
        """Save current leave report form state to a dictionary."""
        state_dict['leaves'] = self.leaves_dropdown.currentIndex() if hasattr(self, 'leaves_dropdown') else 0
        state_dict['frequency'] = self.frequency_dropdown.currentIndex() if hasattr(self, 'frequency_dropdown') else 0
        state_dict['duration'] = self.duration_dropdown.currentIndex() if hasattr(self, 'duration_dropdown') else 0
        state_dict['leave_types'] = {}
        if hasattr(self, 'leave_type_widgets'):
            for key, widgets in self.leave_type_widgets.items():
                state_dict['leave_types'][key] = {
                    'checked': widgets['cb'].isChecked(),
                    'value': widgets['slider'].value()
                }
        state_dict['medical'] = self.leave_medical_cb.isChecked() if hasattr(self, 'leave_medical_cb') else False
        state_dict['court'] = self.leave_court_cb.isChecked() if hasattr(self, 'leave_court_cb') else False
        state_dict['compassionate'] = self.leave_compassionate_cb.isChecked() if hasattr(self, 'leave_compassionate_cb') else False
        state_dict['suspended_yes'] = self.suspended_yes.isChecked() if hasattr(self, 'suspended_yes') else False
        state_dict['suspended_no'] = self.suspended_no.isChecked() if hasattr(self, 'suspended_no') else False
        state_dict['suspension_details'] = self.suspension_details.toPlainText() if hasattr(self, 'suspension_details') else ""

    def _restore_leave_state(self, state_dict):
        """Restore leave report form state from a dictionary."""
        if not state_dict:
            # Reset to defaults
            if hasattr(self, 'leaves_dropdown'):
                self.leaves_dropdown.setCurrentIndex(0)
            if hasattr(self, 'frequency_dropdown'):
                self.frequency_dropdown.setCurrentIndex(0)
            if hasattr(self, 'duration_dropdown'):
                self.duration_dropdown.setCurrentIndex(0)
            if hasattr(self, 'leave_type_widgets'):
                for widgets in self.leave_type_widgets.values():
                    widgets['cb'].setChecked(False)
                    widgets['slider'].setValue(0)
            if hasattr(self, 'leave_medical_cb'):
                self.leave_medical_cb.setChecked(False)
            if hasattr(self, 'leave_court_cb'):
                self.leave_court_cb.setChecked(False)
            if hasattr(self, 'leave_compassionate_cb'):
                self.leave_compassionate_cb.setChecked(False)
            if hasattr(self, 'suspended_yes'):
                self.suspended_yes.setChecked(False)
            if hasattr(self, 'suspended_no'):
                self.suspended_no.setChecked(False)
            if hasattr(self, 'suspension_details'):
                self.suspension_details.clear()
            return

        if hasattr(self, 'leaves_dropdown'):
            self.leaves_dropdown.setCurrentIndex(state_dict.get('leaves', 0))
        if hasattr(self, 'frequency_dropdown'):
            self.frequency_dropdown.setCurrentIndex(state_dict.get('frequency', 0))
        if hasattr(self, 'duration_dropdown'):
            self.duration_dropdown.setCurrentIndex(state_dict.get('duration', 0))
        if hasattr(self, 'leave_type_widgets'):
            leave_types = state_dict.get('leave_types', {})
            for key, widgets in self.leave_type_widgets.items():
                lt = leave_types.get(key, {})
                widgets['cb'].setChecked(lt.get('checked', False))
                widgets['slider'].setValue(lt.get('value', 0))
        if hasattr(self, 'leave_medical_cb'):
            self.leave_medical_cb.setChecked(state_dict.get('medical', False))
        if hasattr(self, 'leave_court_cb'):
            self.leave_court_cb.setChecked(state_dict.get('court', False))
        if hasattr(self, 'leave_compassionate_cb'):
            self.leave_compassionate_cb.setChecked(state_dict.get('compassionate', False))
        if state_dict.get('suspended_yes') and hasattr(self, 'suspended_yes'):
            self.suspended_yes.setChecked(True)
        elif state_dict.get('suspended_no') and hasattr(self, 'suspended_no'):
            self.suspended_no.setChecked(True)
        else:
            if hasattr(self, 'suspended_yes'):
                self.suspended_yes.setChecked(False)
            if hasattr(self, 'suspended_no'):
                self.suspended_no.setChecked(False)
        if hasattr(self, 'suspension_details'):
            self.suspension_details.setPlainText(state_dict.get('suspension_details', ''))

    def _generate_leave_report_from_state(self, state_dict, leave_type_label):
        """Generate leave report text from a state dictionary."""
        if not state_dict:
            return ""

        p = self._get_pronouns()
        parts = []

        # Get values from state
        leaves_idx = state_dict.get('leaves', 0)
        leaves = str(leaves_idx + 1)  # Index 0 = "1", etc.
        freq_options = ["weekly", "2 weekly", "3 weekly", "monthly", "2 monthly"]
        frequency = freq_options[state_dict.get('frequency', 0)]
        dur_options = ["30 mins", "1 hour", "2 hours", "3 hours", "4 hours", "5 hours", "6 hours", "7 hours", "8 hours"]
        duration = dur_options[state_dict.get('duration', 0)]

        leave_type_labels = {
            "ground": "ground leave",
            "local": "local community leave",
            "community": "community leave",
            "extended": "extended community leave",
            "overnight": "overnight leave"
        }

        # Get checked leave types with their weights
        leave_types = state_dict.get('leave_types', {})
        checked_types = []
        for key, lt in leave_types.items():
            if lt.get('checked', False):
                weight = lt.get('value', 0)
                checked_types.append((key, weight, leave_type_labels.get(key, key)))

        checked_types.sort(key=lambda x: x[1], reverse=True)

        if checked_types:
            type_phrases = []
            for i, (key, weight, label) in enumerate(checked_types):
                if i == 0:
                    type_phrases.append(f"mainly {label}")
                elif i == 1:
                    type_phrases.append(f"but also some {label}")
                elif i == 2:
                    type_phrases.append(f"and to a lesser extent {label}")
                else:
                    type_phrases.append(f"and occasionally {label}")

            if len(type_phrases) == 1:
                type_str = type_phrases[0]
            else:
                type_str = ", ".join(type_phrases)

            parts.append(f"Over the past two years, {p['subj_l']} {p['have']} taken approximately {leaves} {leave_type_label} leave{'s' if leaves != '1' else ''} {frequency}, averaging {duration} per leave, engaging in {type_str}.")

        # Other leave types
        other_types = []
        if state_dict.get('medical', False):
            other_types.append("medical appointments")
        if state_dict.get('court', False):
            other_types.append("court appearances")
        if state_dict.get('compassionate', False):
            other_types.append("compassionate visits")

        if other_types:
            # Only use "also" if there are other leave types (ground, local, etc.) mentioned above
            also_word = "also " if checked_types else ""
            if len(other_types) == 1:
                parts.append(f"{p['subj']} {p['have']} {also_word}taken leave for {other_types[0]}.")
            else:
                parts.append(f"{p['subj']} {p['have']} {also_word}taken leave for {', '.join(other_types[:-1])} and {other_types[-1]}.")

        # Note: Leave suspension is now handled separately in _update_leave_report_preview
        # to keep it independent from escorted/unescorted sections

        return " ".join(parts)

    def _generate_suspension_text(self):
        """Generate leave suspension text independently from escorted/unescorted sections."""
        p = self._get_pronouns()

        # Read directly from the suspension radio buttons and details
        suspended_yes = hasattr(self, 'suspended_yes') and self.suspended_yes.isChecked()
        suspended_no = hasattr(self, 'suspended_no') and self.suspended_no.isChecked()
        details = self.suspension_details.toPlainText().strip() if hasattr(self, 'suspension_details') else ""

        if suspended_yes:
            if details:
                return f"{p['pos'].capitalize()} leave has been suspended in the past. {details}"
            else:
                return f"{p['pos'].capitalize()} leave has been suspended in the past."
        elif suspended_no:
            return f"{p['pos'].capitalize()} leave has never been suspended."

        return ""

    def _update_leave_report_preview(self):
        """Update the leave report preview with generated narrative."""
        if not hasattr(self, 'leave_report_preview'):
            return

        # Initialize state dicts if they don't exist
        if not hasattr(self, '_leave_escorted_state'):
            self._leave_escorted_state = {}
        if not hasattr(self, '_leave_unescorted_state'):
            self._leave_unescorted_state = {}

        # Save current state to appropriate dict
        is_escorted = hasattr(self, 'leave_escorted_radio') and self.leave_escorted_radio.isChecked()
        if hasattr(self, 'leaves_dropdown'):  # Only save if popup has been built
            if is_escorted:
                self._save_leave_state(self._leave_escorted_state)
            else:
                self._save_leave_state(self._leave_unescorted_state)

        # Generate both outputs
        escorted_text = self._generate_leave_report_from_state(self._leave_escorted_state, "escorted")
        unescorted_text = self._generate_leave_report_from_state(self._leave_unescorted_state, "unescorted")

        result_parts = []
        if escorted_text:
            result_parts.append(f"ESCORTED LEAVE:\n{escorted_text}")
        if unescorted_text:
            result_parts.append(f"UNESCORTED LEAVE:\n{unescorted_text}")

        # Generate suspension section independently (not tied to escorted/unescorted)
        suspension_text = self._generate_suspension_text()
        if suspension_text:
            result_parts.append(f"LEAVE SUSPENSION STATUS:\n{suspension_text}")

        result = "\n\n".join(result_parts) if result_parts else "(No content yet...)"
        self.leave_report_preview.setText(result)
        # Auto-sync to card - preserve user additions
        if "leave_report" in self.cards and result and result != "(No content yet...)":
            self._update_text_preserving_additions(self.cards["leave_report"].editor, result, "leave_report")

    def _search_leave_evidence(self):
        """Search uploaded notes for evidence of leave taken and suspensions."""
        # Leave search terms
        leave_terms = [
            "took leave", "community leave", "went on leave", "returned from leave",
            "S17 leave", "engaged in S17", "ground leave", "escorted leave",
            "unescorted leave", "overnight leave", "local leave", "extended leave",
            "leave to", "leave was", "leave today", "on leave", "from leave"
        ]

        # Suspension search terms
        suspension_terms = [
            "leave suspended", "suspension of leave", "leave was suspended",
            "suspended leave", "leave revoked", "leave cancelled", "leave stopped",
            "leave withdrawn", "no leave", "leave not permitted"
        ]

        # Check if we have uploaded notes (from main app)
        main_window = self.window()
        notes_text = ""

        # Try to get notes from various sources
        if hasattr(main_window, 'uploaded_notes'):
            notes_text = main_window.uploaded_notes
        elif hasattr(self, 'leave_taken_text'):
            # Allow manual paste for now
            pass

        if not notes_text:
            self.leave_taken_text.setPlainText("No notes available. Please upload clinical notes via Data Extractor first.")
            self.leave_suspension_text.setPlainText("No notes available.")
            return

        # Parse notes and search (simplified - would need proper date parsing in production)
        leave_findings = []
        suspension_findings = []

        lines = notes_text.split('\n')
        for i, line in enumerate(lines):
            line_lower = line.lower()

            # Check for leave evidence
            for term in leave_terms:
                if term.lower() in line_lower:
                    # Get context (2 lines before/after)
                    start = max(0, i - 1)
                    end = min(len(lines), i + 2)
                    context = '\n'.join(lines[start:end])
                    leave_findings.append(f"[{term}]: {context[:200]}...")
                    break

            # Check for suspension evidence
            for term in suspension_terms:
                if term.lower() in line_lower:
                    start = max(0, i - 1)
                    end = min(len(lines), i + 2)
                    context = '\n'.join(lines[start:end])
                    suspension_findings.append(f"[{term}]: {context[:200]}...")
                    break

        # Display findings
        if leave_findings:
            self.leave_taken_text.setPlainText('\n\n'.join(leave_findings[:10]))  # Limit to 10
        else:
            self.leave_taken_text.setPlainText("No evidence of leave found in notes.")

        if suspension_findings:
            self.leave_suspension_text.setPlainText('\n\n'.join(suspension_findings[:5]))
        else:
            self.leave_suspension_text.setPlainText("No evidence of leave suspension found in notes.")

    def _upload_leave_file(self, file_path=None):
        """Process uploaded file for leave report data extraction."""
        from data_extractor_popup import DataExtractorPopup

        if not file_path:
            return

        # Create or get data extractor
        if not hasattr(self, '_leave_data_extractor') or self._leave_data_extractor is None:
            self._leave_data_extractor = DataExtractorPopup(parent=self)
            self._leave_data_extractor.hide()
            self._leave_data_extractor.data_extracted.connect(self._on_leave_data_extracted)

        # Import the file
        self._leave_data_extractor.load_file(file_path)

    def _view_leave_data(self):
        """View the data extractor with previously loaded leave data."""
        pass

    def _on_leave_data_extracted(self, panel_data: dict):
        """Handle extracted data specifically for leave report section."""
        # Search for leave-related entries in the extracted data
        leave_text_parts = []
        suspension_text_parts = []

        # Get raw notes if available
        raw_notes = []
        if hasattr(self, '_leave_data_extractor') and self._leave_data_extractor:
            raw_notes = getattr(self._leave_data_extractor, 'notes', [])
            if raw_notes:
                notes_text = "\n".join([str(n.get('body', '')) for n in raw_notes if isinstance(n, dict)])
                self._search_leave_in_text(notes_text, leave_text_parts, suspension_text_parts)

        # Also check LEAVE category from extracted data
        if "LEAVE" in panel_data:
            notes = panel_data["LEAVE"]
            if notes:
                text = "\n\n".join(notes) if isinstance(notes, list) else str(notes)
                leave_text_parts.append(text)

        # Update the display
        if leave_text_parts:
            self.leave_taken_text.setPlainText('\n\n'.join(leave_text_parts))
        if suspension_text_parts:
            self.leave_suspension_text.setPlainText('\n\n'.join(suspension_text_parts))

        # Populate the Imported Notes section with filtered raw notes
        if raw_notes:
            self._populate_leave_imports(raw_notes)
            if hasattr(self, 'leave_import_section'):
                self.leave_import_section.setVisible(True)

    def _search_leave_in_text(self, text: str, leave_parts: list, suspension_parts: list):
        """Search for leave and suspension evidence in text."""
        leave_terms = ["took leave", "community leave", "went on leave", "returned from leave",
                      "S17 leave", "engaged in S17", "ground leave", "escorted leave",
                      "unescorted leave", "overnight leave", "local leave", "extended leave"]
        suspension_terms = ["leave suspended", "suspension of leave", "leave was suspended",
                           "suspended leave", "leave revoked", "leave cancelled"]

        lines = text.split('\n')
        for i, line in enumerate(lines):
            line_lower = line.lower()
            for term in leave_terms:
                if term.lower() in line_lower:
                    start = max(0, i - 1)
                    end = min(len(lines), i + 2)
                    context = '\n'.join(lines[start:end])
                    leave_parts.append(f"[{term}]: {context[:200]}...")
                    break
            for term in suspension_terms:
                if term.lower() in line_lower:
                    start = max(0, i - 1)
                    end = min(len(lines), i + 2)
                    context = '\n'.join(lines[start:end])
                    suspension_parts.append(f"[{term}]: {context[:200]}...")
                    break

    def _populate_leave_imports(self, raw_notes: list):
        """
        Populate the Imported Notes section with filtered notes from last 2 years.
        Filters for leave-related categories and shows relevant entries with checkboxes.

        IMPORTANT: Detects if input is a REPORT (long single document) vs NOTES (multiple entries).
        For reports, splits into separate leave-related paragraphs/sentences.
        """
        import re
        from datetime import datetime, timedelta

        if not raw_notes:
            print("[MOJ-LEAVE] 3g: No raw notes available for leave imports")
            self._clear_leave_imports()
            return

        # =================================================================
        # LEAVE CATEGORIES - SPECIFIC TERMS ONLY (no broad terms)
        # =================================================================
        # These must be leave-specific, not general terms that could match other contexts
        LEAVE_CATEGORIES = {
            "Ground Leave": [
                "ground leave", "grounds leave", "leave to grounds",
                "leave on the grounds", "leave within grounds"
            ],
            "Local Leave": [
                "local community leave", "local leave", "leave to local",
                "local community"
            ],
            "Community Leave": [
                "community leave", "s17 leave", "section 17 leave",
                "s.17 leave", "section17", "s17", "took leave",
                "went on leave", "returned from leave", "engaged in leave",
                "leave taken", "leave to", "leave was"
            ],
            "Extended Leave": [
                "extended leave", "extended community leave"
            ],
            "Overnight Leave": [
                "overnight leave", "overnight stay", "stayed overnight",
                "leave overnight"
            ],
            "Escorted Leave": [
                "escorted leave", "escorted community", "with escort",
                "staff escort", "nurse escort", "1:1 escort", "2:1 escort",
                "escorted by staff", "escorted by nurse"
            ],
            "Unescorted Leave": [
                "unescorted leave", "unescorted community", "without escort",
                "independent leave"
            ],
            "Leave Progress": [
                "leave progressing", "leave progression", "leave has progressed",
                "progressed to unescorted", "progressed to community",
                "leave successful", "successful leave", "uneventful leave",
                "leave went well", "positive leave experience"
            ],
            "Leave Suspension": [
                "leave suspended", "leave was suspended", "suspension of leave",
                "leave has been suspended", "leave cancelled", "leave was cancelled",
                "leave revoked", "leave was revoked", "leave stopped",
                "leave was stopped", "leave withdrawn", "leave was withdrawn",
                "breach of leave", "failed to return from leave", "leave incident"
            ]
        }

        CATEGORY_COLORS = {
            "Ground Leave": "#059669",       # Green
            "Local Leave": "#0891b2",        # Cyan
            "Community Leave": "#3b82f6",    # Blue
            "Extended Leave": "#7c3aed",     # Purple
            "Overnight Leave": "#6366f1",    # Indigo
            "Escorted Leave": "#d97706",     # Amber
            "Unescorted Leave": "#dc2626",   # Red
            "Leave Progress": "#0d9488",     # Teal
            "Leave Suspension": "#be185d"    # Pink
        }

        # Store for filtering
        self._leave_categories = LEAVE_CATEGORIES
        self._leave_category_colors = CATEGORY_COLORS

        # =================================================================
        # HELPER FUNCTIONS
        # =================================================================
        def parse_note_date(date_val):
            if isinstance(date_val, datetime):
                return date_val
            if not date_val:
                return None
            date_str = str(date_val).strip()
            for fmt in ["%d/%m/%Y", "%Y-%m-%d", "%d-%m-%Y", "%Y/%m/%d", "%d/%m/%Y %H:%M", "%Y-%m-%d %H:%M:%S"]:
                try:
                    return datetime.strptime(date_str.split()[0] if ' ' in date_str else date_str, fmt.split()[0])
                except:
                    pass
            return None

        def format_date_nice(date_obj):
            if not date_obj:
                return ""
            if isinstance(date_obj, str):
                return date_obj
            day = date_obj.day
            if 11 <= day <= 13:
                suffix = "th"
            else:
                suffix = {1: "st", 2: "nd", 3: "rd"}.get(day % 10, "th")
            return date_obj.strftime(f"{day}{suffix} %b %Y")

        def _leave_kw_matches(kw, text_lower):
            """Check if keyword matches in text, using word boundaries for short keywords (<=5 chars)."""
            if len(kw) <= 5:
                return bool(re.search(r'(?<!\w)' + re.escape(kw) + r'(?!\w)', text_lower, re.IGNORECASE))
            return kw in text_lower

        def get_matching_categories(text: str) -> list:
            """Return list of categories that match the text."""
            if not text:
                return []
            text_lower = text.lower()
            matched = []
            for cat, keywords in LEAVE_CATEGORIES.items():
                if any(_leave_kw_matches(kw, text_lower) for kw in keywords):
                    matched.append(cat)
            return matched

        def is_report(notes: list) -> bool:
            """Detect if this is a report (single long document) vs notes (multiple entries)."""
            if len(notes) == 1:
                text = notes[0].get("body", "") or notes[0].get("text", "") or notes[0].get("content", "")
                # If single entry > 2000 chars, it's likely a report
                if len(text) > 2000:
                    return True
                # Check for report indicators
                report_indicators = ["=== page", "report", "tribunal", "ministry of justice",
                                   "responsible clinician", "rc report", "nursing report"]
                text_lower = text.lower()
                if any(ind in text_lower for ind in report_indicators):
                    return True
            # Check source format
            for n in notes:
                source = n.get("source", {})
                if isinstance(source, dict):
                    fmt = source.get("format", "").lower()
                    if fmt in ["pdf", "docx", "doc"]:
                        return True
            return False

        def extract_leave_sections_from_report(text: str, doc_date) -> list:
            """
            Extract individual leave-related sections from a report.
            Returns list of entries, each with text and matched categories.
            """
            entries = []

            # Split by paragraphs (double newline) or sentences containing leave keywords
            # First, find all sentences/paragraphs that mention leave
            paragraphs = re.split(r'\n\s*\n|\n(?=[A-Z])', text)

            # Also split long paragraphs by sentences
            all_segments = []
            for para in paragraphs:
                para = para.strip()
                if not para:
                    continue
                # If paragraph is long, split into sentences
                if len(para) > 500:
                    sentences = re.split(r'(?<=[.!?])\s+(?=[A-Z])', para)
                    all_segments.extend(sentences)
                else:
                    all_segments.append(para)

            # Now find segments that contain leave keywords
            for segment in all_segments:
                segment = segment.strip()
                if len(segment) < 20:  # Skip very short segments
                    continue

                categories = get_matching_categories(segment)
                if categories:
                    # Get some context (surrounding text)
                    # Find where this segment appears in original text
                    seg_start = text.find(segment)
                    if seg_start >= 0:
                        # Get 100 chars before and after for context
                        context_start = max(0, seg_start - 100)
                        context_end = min(len(text), seg_start + len(segment) + 100)
                        context = text[context_start:context_end].strip()

                        # Clean up context
                        if context_start > 0:
                            context = "..." + context
                        if context_end < len(text):
                            context = context + "..."
                    else:
                        context = segment

                    entries.append({
                        "text": context,
                        "snippet": segment[:200] + "..." if len(segment) > 200 else segment,
                        "date": doc_date,
                        "date_obj": parse_note_date(doc_date),
                        "categories": categories
                    })

            return entries

        # =================================================================
        # DETECT REPORT VS NOTES
        # =================================================================
        is_report_mode = is_report(raw_notes)
        print(f"[MOJ-LEAVE] 3g: Detected {'REPORT' if is_report_mode else 'NOTES'} mode")

        # =================================================================
        # FIND DATE RANGE
        # =================================================================
        all_dates = []
        for n in raw_notes:
            dt = parse_note_date(n.get("date") or n.get("datetime"))
            if dt:
                all_dates.append(dt)

        if not all_dates:
            # Use today if no dates found
            most_recent = datetime.now()
            print("[MOJ-LEAVE] 3g: No dates found, using today as reference")
        else:
            most_recent = max(all_dates)

        two_years_cutoff = most_recent - timedelta(days=730)
        print(f"[MOJ-LEAVE] 3g: Date range: {two_years_cutoff.strftime('%d/%m/%Y')} to {most_recent.strftime('%d/%m/%Y')}")

        # =================================================================
        # PROCESS ENTRIES
        # =================================================================
        categorized = []
        seen_texts = set()

        for n in raw_notes:
            note_date = n.get("date") or n.get("datetime")
            note_date_obj = parse_note_date(note_date)

            # Skip if outside 2-year window (but allow if no date)
            if note_date_obj and note_date_obj < two_years_cutoff:
                continue

            full_text = n.get("body", "") or n.get("text", "") or n.get("content", "")
            if not full_text:
                continue

            # =================================================================
            # REPORT MODE: Split into separate leave-related sections
            # =================================================================
            if is_report_mode:
                # Extract individual leave sections from the report
                report_entries = extract_leave_sections_from_report(full_text, note_date)
                print(f"[MOJ-LEAVE] 3g: Extracted {len(report_entries)} leave sections from report")

                for entry in report_entries:
                    # Dedupe by snippet text
                    text_sig = entry.get("snippet", "")[:100].strip()
                    if text_sig and text_sig not in seen_texts:
                        seen_texts.add(text_sig)
                        categorized.append(entry)
            else:
                # =================================================================
                # NOTES MODE: Process each note as a single entry
                # =================================================================
                categories = get_matching_categories(full_text)
                if not categories:
                    continue

                text_sig = full_text[:200].strip()
                if text_sig in seen_texts:
                    continue
                seen_texts.add(text_sig)

                # Create snippet (first 2 lines)
                lines = [l.strip() for l in full_text.split('\n') if l.strip()]
                snippet = '\n'.join(lines[:2])
                if len(lines) > 2:
                    snippet += "..."

                categorized.append({
                    "text": full_text,
                    "snippet": snippet,
                    "date": note_date,
                    "date_obj": note_date_obj,
                    "categories": categories
                })

        # Sort by date descending
        categorized.sort(key=lambda x: x.get("date_obj") or datetime.min, reverse=True)

        print(f"[MOJ-LEAVE] 3g: Found {len(categorized)} categorized leave entries")

        # Limit to prevent performance issues (show most recent 150)
        MAX_DISPLAY = 150
        if len(categorized) > MAX_DISPLAY:
            print(f"[MOJ-LEAVE] Limiting display to {MAX_DISPLAY} most recent entries")
            categorized = categorized[:MAX_DISPLAY]

        # Store for filtering
        self._leave_all_categorized = categorized

        # =================================================================
        # AUTO-DETECT LEAVE SUSPENSION - set suspended radio if found
        # =================================================================
        suspension_found = False
        for entry in categorized:
            if "Leave Suspension" in entry.get("categories", []):
                suspension_found = True
                break

        if suspension_found:
            print(f"[MOJ-LEAVE] 3g: Leave suspension detected - setting suspended = Yes")
            if hasattr(self, 'suspended_yes'):
                self.suspended_yes.setChecked(True)
                # Show suspension details container
                if hasattr(self, 'suspension_details_container'):
                    self.suspension_details_container.setVisible(True)
        else:
            print(f"[MOJ-LEAVE] 3g: No leave suspension detected - keeping default (No)")

        # Display entries
        self._display_leave_entries(categorized, format_date_nice, None)

    def _display_leave_entries(self, categorized: list, format_date_nice, filter_category: str = None):
        """Display leave entries with optional category filter."""
        import re
        import html

        if not hasattr(self, 'leave_import_layout') or not self.leave_import_layout:
            return

        CATEGORY_COLORS = self._leave_category_colors
        LEAVE_CATEGORIES = self._leave_categories

        def highlight_keywords(text, matched_categories):
            """Highlight keywords in text that triggered the category matches."""
            escaped = html.escape(text)
            keywords_to_highlight = []
            for cat in matched_categories:
                keywords_to_highlight.extend(LEAVE_CATEGORIES.get(cat, []))
            keywords_to_highlight = sorted(set(keywords_to_highlight), key=len, reverse=True)
            for kw in keywords_to_highlight:
                color = CATEGORY_COLORS.get(matched_categories[0], "#fef08a") if matched_categories else "#fef08a"
                # Use word boundaries for short keywords (<=5 chars) to avoid false matches
                if len(kw) <= 5:
                    pattern = re.compile(r'(?<!\w)' + re.escape(kw) + r'(?!\w)', re.IGNORECASE)
                else:
                    pattern = re.compile(re.escape(kw), re.IGNORECASE)
                escaped = pattern.sub(
                    lambda m: f'<span style="background-color: {color}; color: white; padding: 3px 6px; border-radius: 2px; font-weight: 600;">{m.group()}</span>',
                    escaped
                )
            return escaped.replace('\n', '<br>')

        # Clear existing content
        while self.leave_import_layout.count():
            item = self.leave_import_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
            elif item.layout():
                while item.layout().count():
                    sub_item = item.layout().takeAt(0)
                    if sub_item.widget():
                        sub_item.widget().deleteLater()

        self.leave_import_checkboxes = []

        # Filter if category specified
        if filter_category:
            display_entries = [(e, e["categories"]) for e in categorized if filter_category in e.get("categories", [])]
        else:
            display_entries = [(e, e["categories"]) for e in categorized]

        # Update subtitle
        if hasattr(self, 'leave_import_subtitle'):
            self.leave_import_subtitle.setText(f"Showing {len(display_entries)} leave entries from last 2 years - tick to include in preview")

        if not display_entries:
            placeholder = QLabel("No leave entries found. Use Import Data to load clinical notes.")
            placeholder.setStyleSheet("color: #92400e; font-style: italic; font-size: 14px; background: transparent;")
            self.leave_import_layout.addWidget(placeholder)
            return

        # Filter header row (only show when filter is active) - red box style
        if filter_category:
            filter_frame = QFrame()
            filter_frame.setStyleSheet("QFrame { background: #fef2f2; border: 1px solid #dc2626; border-radius: 4px; }")
            filter_row = QHBoxLayout(filter_frame)
            filter_row.setContentsMargins(8, 4, 8, 4)
            filter_row.setSpacing(8)

            filter_label = QLabel(f"Filtered by:")
            filter_label.setStyleSheet("font-size: 14px; color: #991b1b; background: transparent;")
            filter_row.addWidget(filter_label)

            color = CATEGORY_COLORS.get(filter_category, "#6b7280")
            cat_label = QLabel(filter_category)
            cat_label.setStyleSheet(f"font-size: 14px; font-weight: 600; color: {color}; background: transparent;")
            filter_row.addWidget(cat_label)

            filter_row.addStretch()

            remove_btn = QPushButton("Remove filter")
            remove_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            remove_btn.setStyleSheet("""
                QPushButton {
                    font-size: 14px; color: #dc2626; background: transparent;
                    border: 1px solid #dc2626; border-radius: 3px; padding: 4px 10px;
                }
                QPushButton:hover { background: #fee2e2; }
            """)
            remove_btn.clicked.connect(lambda: self._filter_leave_by_category(None))
            filter_row.addWidget(remove_btn)

            self.leave_import_layout.addWidget(filter_frame)

        # Select All / Deselect All buttons
        btn_row = QHBoxLayout()
        btn_row.setSpacing(6)

        select_all_btn = QPushButton("Select All")
        select_all_btn.setStyleSheet("""
            QPushButton { background: #d97706; color: white; border: none; border-radius: 4px; padding: 6px 14px; font-size: 14px; font-weight: 600; }
            QPushButton:hover { background: #b45309; }
        """)
        select_all_btn.clicked.connect(self._select_all_leave_imports)
        btn_row.addWidget(select_all_btn)

        deselect_all_btn = QPushButton("Deselect All")
        deselect_all_btn.setStyleSheet("""
            QPushButton { background: #92400e; color: white; border: none; border-radius: 4px; padding: 6px 14px; font-size: 14px; font-weight: 600; }
            QPushButton:hover { background: #78350f; }
        """)
        deselect_all_btn.clicked.connect(self._deselect_all_leave_imports)
        btn_row.addWidget(deselect_all_btn)

        btn_row.addStretch()

        # Send to Preview button - user must click to add selected items to preview
        send_preview_btn = QPushButton("Send to Preview")
        send_preview_btn.setStyleSheet("""
            QPushButton { background: #059669; color: white; border: none; border-radius: 4px; padding: 6px 16px; font-size: 14px; font-weight: 600; }
            QPushButton:hover { background: #047857; }
        """)
        send_preview_btn.clicked.connect(self._send_selected_leave_to_preview)
        btn_row.addWidget(send_preview_btn)

        self.leave_import_layout.addLayout(btn_row)

        # Add each entry (4A style - white rounded container, toggle left, checkbox right)
        for entry, categories in display_entries:
            full_text = entry["text"]
            date_obj = entry.get("date_obj")
            date_raw = entry.get("date", "")

            # Create entry frame (4A style)
            entry_frame = QFrame()
            entry_frame.setObjectName("entryFrame")
            entry_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            entry_frame.setStyleSheet("""
                QFrame#entryFrame {
                    background: rgba(255, 255, 255, 0.95);
                    border: 1px solid rgba(180, 150, 50, 0.4);
                    border-radius: 8px;
                    padding: 4px;
                }
            """)
            entry_layout_v = QVBoxLayout(entry_frame)
            entry_layout_v.setContentsMargins(10, 4, 16, 4)
            entry_layout_v.setSpacing(6)

            # Header row: toggle_btn → category tags → date → stretch → checkbox
            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            # Toggle button (left side)
            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(180, 150, 50, 0.2);
                    border: none;
                    border-radius: 4px;
                    font-size: 15px;
                    font-weight: bold;
                    color: #806000;
                }
                QPushButton:hover { background: rgba(180, 150, 50, 0.35); }
            """)
            header_row.addWidget(toggle_btn)

            # Date label (amber) — before tags
            date_str = format_date_nice(date_obj) if date_obj else str(date_raw) if date_raw else ""
            date_label = None
            if date_str:
                date_label = QLabel(f"\U0001f4c5 {date_str}")
                date_label.setStyleSheet("""
                    QLabel {
                        font-size: 15px; font-weight: 600; color: #806000;
                        background: transparent; border: none;
                    }
                """)
                date_label.setCursor(Qt.CursorShape.PointingHandCursor)
                header_row.addWidget(date_label)

            # Category tags (clickable) — after date
            if categories:
                for cat in categories:
                    tag = QPushButton(cat)
                    tag.setCursor(Qt.CursorShape.PointingHandCursor)
                    color = CATEGORY_COLORS.get(cat, "#6b7280")
                    tag.setStyleSheet(f"""
                        QPushButton {{
                            font-size: 14px; font-weight: 600; color: white;
                            background: {color}; padding: 3px 8px; border-radius: 3px; border: none;
                        }}
                        QPushButton:hover {{ background: {color}; opacity: 0.8; }}
                    """)
                    tag.clicked.connect(lambda checked, c=cat: self._filter_leave_by_category(c))
                    header_row.addWidget(tag)

            header_row.addStretch()

            # Checkbox (right side, with margin)
            cb = QCheckBox()
            cb.setFixedSize(20, 20)
            cb.setStyleSheet("""
                QCheckBox { background: transparent; margin-right: 4px; }
                QCheckBox::indicator { width: 18px; height: 18px; }
            """)
            header_row.addWidget(cb)

            entry_layout_v.addLayout(header_row)

            # Body text (hidden by default, with keyword highlighting)
            full_highlighted = highlight_keywords(full_text, categories)
            body_text = QTextEdit()
            body_text.setHtml(full_highlighted)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("""
                QTextEdit {
                    font-size: 15px;
                    color: #333;
                    background: rgba(255, 248, 220, 0.5);
                    border: none;
                    padding: 8px;
                    border-radius: 6px;
                }
            """)
            body_text.document().setTextWidth(body_text.viewport().width() if body_text.viewport().width() > 0 else 350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            entry_layout_v.addWidget(body_text)

            # Toggle function
            def make_toggle(btn, body, frame):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    frame.updateGeometry()
                return toggle

            toggle_fn = make_toggle(toggle_btn, body_text, entry_frame)
            toggle_btn.clicked.connect(toggle_fn)
            if date_label:
                date_label.mousePressEvent = lambda e, fn=toggle_fn: fn()

            self.leave_import_layout.addWidget(entry_frame)
            self.leave_import_checkboxes.append((cb, entry))

    def _update_leave_preview_from_imports(self):
        """Auto-update the leave report preview when import checkboxes change."""
        if not hasattr(self, 'leave_import_checkboxes') or not self.leave_import_checkboxes:
            return

        # Collect checked entries
        texts = []
        for checkbox, entry in self.leave_import_checkboxes:
            if checkbox.isChecked():
                text = entry.get("text", "").strip()
                date_obj = entry.get("date_obj")
                if text:
                    if date_obj:
                        date_str = date_obj.strftime("%d/%m/%Y")
                        texts.append(f"[{date_str}] {text}")
                    else:
                        texts.append(text)

        # Update preview - append to generated content
        if hasattr(self, 'leave_report_preview'):
            # First regenerate the base preview from input fields
            self._update_leave_report_preview()

            # Then append imported notes if any are selected
            if texts:
                current = self.leave_report_preview.text()
                imported_section = "\n\n--- Imported Leave Notes ---\n" + "\n\n".join(texts)
                if current:
                    self.leave_report_preview.setText(current + imported_section)
                else:
                    self.leave_report_preview.setText(imported_section.strip())

    def _filter_leave_by_category(self, category: str):
        """Filter leave entries by category."""
        self._leave_current_filter = category

        def format_date_nice(date_obj):
            if not date_obj:
                return ""
            if isinstance(date_obj, str):
                return date_obj
            day = date_obj.day
            suffix = "th" if 11 <= day <= 13 else {1: "st", 2: "nd", 3: "rd"}.get(day % 10, "th")
            return date_obj.strftime(f"{day}{suffix} %b %Y")

        self._display_leave_entries(self._leave_all_categorized, format_date_nice, category)

    def _select_all_leave_imports(self):
        """Select all leave import checkboxes."""
        for checkbox, _ in self.leave_import_checkboxes:
            checkbox.setChecked(True)

    def _deselect_all_leave_imports(self):
        """Deselect all leave import checkboxes."""
        for checkbox, _ in self.leave_import_checkboxes:
            checkbox.setChecked(False)

    def _send_selected_leave_to_preview(self):
        """Send selected leave import entries to the preview.

        User must explicitly click this button to add imported data to preview.
        """
        if not hasattr(self, 'leave_import_checkboxes') or not self.leave_import_checkboxes:
            return

        # Collect checked entries
        texts = []
        for checkbox, entry in self.leave_import_checkboxes:
            if checkbox.isChecked():
                text = entry.get("text", "").strip()
                date_obj = entry.get("date_obj")
                if text:
                    if date_obj:
                        date_str = date_obj.strftime("%d/%m/%Y")
                        texts.append(f"[{date_str}] {text[:300]}..." if len(text) > 300 else f"[{date_str}] {text}")
                    else:
                        texts.append(text[:300] + "..." if len(text) > 300 else text)

        if not texts:
            from PySide6.QtWidgets import QMessageBox
            QMessageBox.information(self, "No Selection", "Please tick at least one entry to send to preview.")
            return

        # Update preview - append to generated content
        if hasattr(self, 'leave_report_preview'):
            # Get current preview content
            current = self.leave_report_preview.text()
            imported_section = "\n\n--- Imported Leave Notes ---\n" + "\n\n".join(texts)
            if current:
                self.leave_report_preview.setText(current + imported_section)
            else:
                self.leave_report_preview.setText(imported_section.strip())

            from PySide6.QtWidgets import QMessageBox
            QMessageBox.information(self, "Sent", f"{len(texts)} leave entries sent to preview.")

    def _populate_leave_imports_from_items(self, items: list):
        """Populate leave imports from pre-categorized items (from data extractor)."""
        from datetime import datetime

        if not items:
            self._clear_leave_imports()
            return

        if not hasattr(self, 'leave_import_layout') or not self.leave_import_layout:
            return

        # Clear existing
        self._clear_leave_imports()

        # Limit items to prevent performance issues
        MAX_DISPLAY = 100
        display_items = items[:MAX_DISPLAY] if len(items) > MAX_DISPLAY else items
        print(f"[MOJ-LEAVE] Displaying {len(display_items)} leave items (of {len(items)} total)")

        # Update subtitle
        if hasattr(self, 'leave_import_subtitle'):
            self.leave_import_subtitle.setText(f"Imported entries ({len(display_items)} shown)")

        self.leave_import_checkboxes = []

        for item in display_items:
            text = item.get("text", "").strip()
            if not text:
                continue

            # Parse date
            date_str = ""
            date_obj = item.get("date_obj")
            if date_obj:
                date_str = date_obj.strftime("%d/%m/%Y")
            elif item.get("date"):
                date_str = str(item["date"])[:10]

            # Create entry frame (4A style - white rounded container)
            entry_frame = QFrame()
            entry_frame.setObjectName("entryFrame")
            entry_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            entry_frame.setStyleSheet("""
                QFrame#entryFrame {
                    background: rgba(255, 255, 255, 0.95);
                    border: 1px solid rgba(180, 150, 50, 0.4);
                    border-radius: 8px;
                    padding: 4px;
                }
            """)
            entry_layout = QVBoxLayout(entry_frame)
            entry_layout.setContentsMargins(10, 4, 16, 4)
            entry_layout.setSpacing(6)


            # Header row: toggle_btn → date → stretch → checkbox
            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            # Toggle button (left side)
            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(180, 150, 50, 0.2);
                    border: none;
                    border-radius: 4px;
                    font-size: 15px;
                    font-weight: bold;
                    color: #806000;
                }
                QPushButton:hover { background: rgba(180, 150, 50, 0.35); }
            """)
            header_row.addWidget(toggle_btn)

            # Date label
            if date_str:
                date_label = QLabel(f"\U0001f4c5 {date_str}")
                date_label.setStyleSheet("""
                    QLabel {
                        font-size: 15px; font-weight: 600; color: #806000;
                        background: transparent; border: none;
                    }
                """)
                date_label.setCursor(Qt.CursorShape.PointingHandCursor)
                header_row.addWidget(date_label)

            header_row.addStretch()

            # Checkbox (right side, with margin)
            cb = QCheckBox()
            cb.setFixedSize(20, 20)
            cb.setStyleSheet("""
                QCheckBox { background: transparent; margin-right: 4px; }
                QCheckBox::indicator { width: 18px; height: 18px; }
            """)
            header_row.addWidget(cb)

            entry_layout.addLayout(header_row)

            # Body text (hidden by default)
            body_text = QTextEdit()
            body_text.setPlainText(text)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("""
                QTextEdit {
                    font-size: 15px;
                    color: #333;
                    background: rgba(255, 248, 220, 0.5);
                    border: none;
                    padding: 8px;
                    border-radius: 6px;
                }
            """)
            body_text.document().setTextWidth(body_text.viewport().width() if body_text.viewport().width() > 0 else 350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            entry_layout.addWidget(body_text)

            # Toggle function
            def make_toggle(btn, body, frame):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    frame.updateGeometry()
                return toggle

            toggle_fn = make_toggle(toggle_btn, body_text, entry_frame)
            toggle_btn.clicked.connect(toggle_fn)
            if date_str:
                date_label.mousePressEvent = lambda e, fn=toggle_fn: fn()

            self.leave_import_layout.addWidget(entry_frame)
            self.leave_import_checkboxes.append((cb, item))

    def _populate_psych_imports_from_items(self, items: list):
        """Populate psych imports from pre-categorized items (from data extractor)."""
        from datetime import datetime

        if not items:
            self._clear_psych_imports()
            return

        if not hasattr(self, 'psych_import_layout') or not self.psych_import_layout:
            return

        # Clear existing
        self._clear_psych_imports()

        # Limit items to prevent performance issues
        MAX_DISPLAY = 100
        display_items = items[:MAX_DISPLAY] if len(items) > MAX_DISPLAY else items
        print(f"[MOJ-LEAVE] Displaying {len(display_items)} psych items (of {len(items)} total)")

        # Update subtitle
        if hasattr(self, 'psych_import_subtitle'):
            self.psych_import_subtitle.setText(f"Imported entries ({len(display_items)} shown)")

        self.psych_import_checkboxes = []

        for item in display_items:
            text = item.get("text", "").strip()
            if not text:
                continue

            # Create entry frame
            entry_frame = QFrame()
            entry_frame.setStyleSheet("QFrame { background: #fef3c7; border: 1px solid #fcd34d; border-radius: 4px; }")
            entry_layout = QHBoxLayout(entry_frame)
            entry_layout.setContentsMargins(6, 4, 6, 4)
            entry_layout.setSpacing(6)

            # Checkbox
            cb = QCheckBox()
            cb.setStyleSheet("QCheckBox { background: transparent; }")
            cb.stateChanged.connect(self._update_psych_preview_from_imports)
            entry_layout.addWidget(cb)

            # Text preview (first 150 chars)
            preview = text[:150] + "..." if len(text) > 150 else text
            text_label = QLabel(preview)
            text_label.setWordWrap(True)
            text_label.setStyleSheet("font-size: 14px; color: #78350f; background: transparent;")
            entry_layout.addWidget(text_label, 1)

            self.psych_import_layout.addWidget(entry_frame)
            self.psych_import_checkboxes.append((cb, item))

    def _clear_leave_imports(self):
        """Clear the imported leave entries."""
        self.leave_imported_entries = []
        self.leave_import_checkboxes = []
        self._leave_all_categorized = []
        self._leave_current_filter = None

        if not hasattr(self, 'leave_import_layout') or not self.leave_import_layout:
            return

        while self.leave_import_layout.count():
            item = self.leave_import_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
            elif item.layout():
                while item.layout().count():
                    sub_item = item.layout().takeAt(0)
                    if sub_item.widget():
                        sub_item.widget().deleteLater()

        placeholder = QLabel("No entries found. Use Import Data to load clinical notes.")
        placeholder.setStyleSheet("color: #92400e; font-style: italic; font-size: 14px; background: transparent;")
        self.leave_import_layout.addWidget(placeholder)

        if hasattr(self, 'leave_import_subtitle') and self.leave_import_subtitle:
            self.leave_import_subtitle.setText("Leave evidence from notes (last 2 years)")

    def _send_leave_imports_to_preview(self):
        """Send selected (checked) leave entries to the preview text area."""
        if not hasattr(self, 'leave_import_checkboxes') or not self.leave_import_checkboxes:
            QMessageBox.information(self, "No Entries", "No leave entries available to send.")
            return

        texts = []
        for checkbox, entry in self.leave_import_checkboxes:
            if checkbox.isChecked():
                text = entry.get("text", "").strip()
                date_obj = entry.get("date_obj")
                if text:
                    if date_obj:
                        date_str = date_obj.strftime("%d/%m/%Y")
                        texts.append(f"[{date_str}] {text}")
                    else:
                        texts.append(text)

        if not texts:
            QMessageBox.information(self, "No Selection", "Please tick at least one entry to send to the preview.")
            return

        combined = "\n\n".join(texts)

        if hasattr(self, 'leave_report_preview'):
            current = self.leave_report_preview.text()
            if current:
                self.leave_report_preview.setText(current + "\n\n--- Imported Leave Notes ---\n" + combined)
            else:
                self.leave_report_preview.setText(combined)

        QMessageBox.information(self, "Sent", f"{len(texts)} leave entries sent to preview.")

    def _create_procedures_popup(self) -> QWidget:
        """Create procedures popup with escorts, transport, handcuffs, exclusion zones, etc."""
        popup = QWidget()
        popup.setStyleSheet("background: #f9fafb;")
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        # Hidden label to store text for auto-sync to card
        self.leave_procedures = QLabel()
        self.leave_procedures.hide()

        # === INPUT SECTIONS (scrollable) ===
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        scroll_area.setStyleSheet("QScrollArea { border: none; background: transparent; }")

        scroll_content = QWidget()
        scroll_content.setStyleSheet("background: transparent;")
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setContentsMargins(0, 0, 8, 0)
        scroll_layout.setSpacing(8)

        # Label style without borders
        label_style = "font-size: 13px; color: #374151; background: transparent; border: none;"
        cb_style = "font-size: 13px; color: #374151; background: transparent; border: none;"

        # === SECTION 1: Escorts/Transport ===
        self.section1_collapsed = True
        section1_header = QHBoxLayout()
        self.section1_btn = QPushButton("+")
        self.section1_btn.setFixedSize(20, 20)
        self.section1_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.section1_btn.setStyleSheet("""
            QPushButton { font-size: 16px; font-weight: 700; color: #374151; background: #e5e7eb; border: none; border-radius: 4px; }
            QPushButton:hover { background: #d1d5db; }
        """)
        section1_header.addWidget(self.section1_btn)
        section1_title = QLabel("Escorts / Transport")
        section1_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #1f2937; background: transparent;")
        section1_header.addWidget(section1_title)
        section1_header.addStretch()
        scroll_layout.addLayout(section1_header)

        self.section1_content = QWidget()
        self.section1_content.setStyleSheet("background: transparent;")
        section1_layout = QVBoxLayout(self.section1_content)
        section1_layout.setContentsMargins(28, 4, 0, 8)
        section1_layout.setSpacing(6)

        # Escorts
        escorts_row = QHBoxLayout()
        escorts_row.setSpacing(8)
        escorts_lbl = QLabel("Escorts:")
        escorts_lbl.setStyleSheet(label_style)
        escorts_row.addWidget(escorts_lbl)
        self.escorts_dropdown = QComboBox()
        self.escorts_dropdown.addItems(["Select...", "1", "2", "3"])
        self.escorts_dropdown.setFixedWidth(100)
        self.escorts_dropdown.setStyleSheet("font-size: 13px;")
        self.escorts_dropdown.currentTextChanged.connect(self._update_section_3h_text)
        escorts_row.addWidget(self.escorts_dropdown)
        escorts_row.addStretch()
        section1_layout.addLayout(escorts_row)

        # Transport
        transport_lbl = QLabel("Transport:")
        transport_lbl.setStyleSheet(label_style)
        section1_layout.addWidget(transport_lbl)
        transport_row = QHBoxLayout()
        transport_row.setSpacing(12)
        self.transport_checkboxes = {}
        for key, label in [("secure", "Secure"), ("hospital", "Hospital"), ("taxi", "Taxi"), ("public", "Public")]:
            cb = QCheckBox(label)
            cb.setStyleSheet(cb_style)
            cb.stateChanged.connect(self._update_section_3h_text)
            self.transport_checkboxes[key] = cb
            transport_row.addWidget(cb)
        transport_row.addStretch()
        section1_layout.addLayout(transport_row)

        # Handcuffs
        self.handcuffs_cb = QCheckBox("Handcuffs to be carried")
        self.handcuffs_cb.setStyleSheet(cb_style)
        self.handcuffs_cb.stateChanged.connect(self._update_section_3h_text)
        section1_layout.addWidget(self.handcuffs_cb)

        # Exclusion Zone
        excl_row = QHBoxLayout()
        excl_row.setSpacing(8)
        excl_lbl = QLabel("Exclusion Zone:")
        excl_lbl.setStyleSheet(label_style)
        excl_row.addWidget(excl_lbl)
        self.exclusion_group = QButtonGroup(self)
        self.exclusion_yes = QRadioButton("Yes")
        self.exclusion_yes.setStyleSheet(cb_style)
        self.exclusion_na = QRadioButton("N/A")
        self.exclusion_na.setStyleSheet(cb_style)
        self.exclusion_na.setChecked(True)
        self.exclusion_group.addButton(self.exclusion_yes)
        self.exclusion_group.addButton(self.exclusion_na)
        excl_row.addWidget(self.exclusion_yes)
        excl_row.addWidget(self.exclusion_na)
        excl_row.addStretch()
        section1_layout.addLayout(excl_row)

        self.exclusion_details = QLineEdit()
        self.exclusion_details.setPlaceholderText("Exclusion zone details...")
        self.exclusion_details.setStyleSheet("font-size: 13px; padding: 6px 12px; border: 1px solid #d1d5db; border-radius: 4px;")
        self.exclusion_details.setVisible(False)
        self.exclusion_yes.toggled.connect(lambda checked: self.exclusion_details.setVisible(checked))
        self.exclusion_yes.toggled.connect(self._update_section_3h_text)
        self.exclusion_na.toggled.connect(self._update_section_3h_text)
        self.exclusion_details.textChanged.connect(self._update_section_3h_text)
        section1_layout.addWidget(self.exclusion_details)

        scroll_layout.addWidget(self.section1_content)
        self.section1_content.setVisible(False)

        def toggle_section1():
            self.section1_collapsed = not self.section1_collapsed
            self.section1_content.setVisible(not self.section1_collapsed)
            self.section1_btn.setText("+" if self.section1_collapsed else "−")
        self.section1_btn.clicked.connect(toggle_section1)

        # === SECTION 2: Public Protection Pre-leave ===
        self.section2_collapsed = True
        section2_header = QHBoxLayout()
        self.section2_btn = QPushButton("+")
        self.section2_btn.setFixedSize(20, 20)
        self.section2_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.section2_btn.setStyleSheet("""
            QPushButton { font-size: 16px; font-weight: 700; color: #374151; background: #e5e7eb; border: none; border-radius: 4px; }
            QPushButton:hover { background: #d1d5db; }
        """)
        section2_header.addWidget(self.section2_btn)
        section2_title = QLabel("Public Protection - Pre-leave")
        section2_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #1f2937; background: transparent;")
        section2_header.addWidget(section2_title)
        section2_header.addStretch()
        scroll_layout.addLayout(section2_header)

        self.section2_content = QWidget()
        self.section2_content.setStyleSheet("background: transparent;")
        section2_layout = QVBoxLayout(self.section2_content)
        section2_layout.setContentsMargins(28, 4, 0, 8)
        section2_layout.setSpacing(4)

        self.pre_leave_checkboxes = {}
        pre_leave_options = [
            ("risk_free", "Risk free > 24 hours"),
            ("mental_state", "Mental state assessment prior to leave"),
            ("escorts_confirmed", "Escorts confirmed as known to patient"),
            ("no_drugs", "No permission for drug and alcohol use"),
            ("timings", "Timings monitored"),
        ]
        for key, label in pre_leave_options:
            cb = QCheckBox(label)
            cb.setStyleSheet(cb_style)
            cb.stateChanged.connect(self._update_section_3h_text)
            self.pre_leave_checkboxes[key] = cb
            section2_layout.addWidget(cb)

        # Pre-leave Select All / Deselect All buttons
        preleave_btn_row = QHBoxLayout()
        preleave_btn_row.setSpacing(8)
        preleave_select_all = QPushButton("Select All")
        preleave_select_all.setStyleSheet("""
            QPushButton { background: #3b82f6; color: white; border: none; border-radius: 4px; padding: 6px 14px; font-size: 13px; font-weight: 600; }
            QPushButton:hover { background: #2563eb; }
        """)
        preleave_select_all.clicked.connect(lambda: [cb.setChecked(True) for cb in self.pre_leave_checkboxes.values()])
        preleave_btn_row.addWidget(preleave_select_all)
        preleave_deselect_all = QPushButton("Deselect All")
        preleave_deselect_all.setStyleSheet("""
            QPushButton { background: #6b7280; color: white; border: none; border-radius: 4px; padding: 6px 14px; font-size: 13px; font-weight: 600; }
            QPushButton:hover { background: #4b5563; }
        """)
        preleave_deselect_all.clicked.connect(lambda: [cb.setChecked(False) for cb in self.pre_leave_checkboxes.values()])
        preleave_btn_row.addWidget(preleave_deselect_all)
        preleave_btn_row.addStretch()
        section2_layout.addLayout(preleave_btn_row)

        scroll_layout.addWidget(self.section2_content)
        self.section2_content.setVisible(False)

        def toggle_section2():
            self.section2_collapsed = not self.section2_collapsed
            self.section2_content.setVisible(not self.section2_collapsed)
            self.section2_btn.setText("+" if self.section2_collapsed else "−")
        self.section2_btn.clicked.connect(toggle_section2)

        # === SECTION 3: Public Protection On Return ===
        self.section3_collapsed = True
        section3_header = QHBoxLayout()
        self.section3_btn = QPushButton("+")
        self.section3_btn.setFixedSize(20, 20)
        self.section3_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.section3_btn.setStyleSheet("""
            QPushButton { font-size: 16px; font-weight: 700; color: #374151; background: #e5e7eb; border: none; border-radius: 4px; }
            QPushButton:hover { background: #d1d5db; }
        """)
        section3_header.addWidget(self.section3_btn)
        section3_title = QLabel("Public Protection - On Return")
        section3_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #1f2937; background: transparent;")
        section3_header.addWidget(section3_title)
        section3_header.addStretch()
        scroll_layout.addLayout(section3_header)

        self.section3_content = QWidget()
        self.section3_content.setStyleSheet("background: transparent;")
        section3_layout = QVBoxLayout(self.section3_content)
        section3_layout.setContentsMargins(28, 4, 0, 8)
        section3_layout.setSpacing(4)

        # On return checkboxes
        self.on_return_checkboxes = {}
        for key, label in [("search", "Search"), ("drug_testing", "Drug testing")]:
            cb = QCheckBox(label)
            cb.setStyleSheet(cb_style)
            cb.stateChanged.connect(self._update_section_3h_text)
            self.on_return_checkboxes[key] = cb
            section3_layout.addWidget(cb)

        # Breaches subsection
        breach_lbl = QLabel("Breaches:")
        breach_lbl.setStyleSheet(label_style + " margin-top: 6px;")
        section3_layout.addWidget(breach_lbl)

        self.breach_checkboxes = {}
        for key, label in [("suspension", "Suspension of leave"), ("inform_moj", "Inform MOJ")]:
            cb = QCheckBox(label)
            cb.setStyleSheet(cb_style)
            cb.stateChanged.connect(self._update_section_3h_text)
            self.breach_checkboxes[key] = cb
            section3_layout.addWidget(cb)

        # On Return Select All / Deselect All buttons
        onreturn_btn_row = QHBoxLayout()
        onreturn_btn_row.setSpacing(8)
        onreturn_select_all = QPushButton("Select All")
        onreturn_select_all.setStyleSheet("""
            QPushButton { background: #3b82f6; color: white; border: none; border-radius: 4px; padding: 6px 14px; font-size: 13px; font-weight: 600; }
            QPushButton:hover { background: #2563eb; }
        """)
        def select_all_onreturn():
            for cb in self.on_return_checkboxes.values():
                cb.setChecked(True)
            for cb in self.breach_checkboxes.values():
                cb.setChecked(True)
        onreturn_select_all.clicked.connect(select_all_onreturn)
        onreturn_btn_row.addWidget(onreturn_select_all)
        onreturn_deselect_all = QPushButton("Deselect All")
        onreturn_deselect_all.setStyleSheet("""
            QPushButton { background: #6b7280; color: white; border: none; border-radius: 4px; padding: 6px 14px; font-size: 13px; font-weight: 600; }
            QPushButton:hover { background: #4b5563; }
        """)
        def deselect_all_onreturn():
            for cb in self.on_return_checkboxes.values():
                cb.setChecked(False)
            for cb in self.breach_checkboxes.values():
                cb.setChecked(False)
        onreturn_deselect_all.clicked.connect(deselect_all_onreturn)
        onreturn_btn_row.addWidget(onreturn_deselect_all)
        onreturn_btn_row.addStretch()
        section3_layout.addLayout(onreturn_btn_row)

        # Specific to patient
        self.specific_to_patient = QCheckBox("I confirm measures are specific to this patient")
        self.specific_to_patient.setStyleSheet(cb_style + " margin-top: 6px;")
        self.specific_to_patient.stateChanged.connect(self._update_section_3h_text)
        section3_layout.addWidget(self.specific_to_patient)

        scroll_layout.addWidget(self.section3_content)
        self.section3_content.setVisible(False)

        def toggle_section3():
            self.section3_collapsed = not self.section3_collapsed
            self.section3_content.setVisible(not self.section3_collapsed)
            self.section3_btn.setText("+" if self.section3_collapsed else "−")
        self.section3_btn.clicked.connect(toggle_section3)

        scroll_layout.addStretch()
        scroll_area.setWidget(scroll_content)
        main_layout.addWidget(scroll_area, 1)

        return popup

    def _update_section_3h_text(self):
        """Update the procedures text based on selections."""
        p = self._get_pronouns()
        parts = []

        # Escorts
        escorts = self.escorts_dropdown.currentText()
        if escorts and escorts != "Select...":
            parts.append(f"{p['subj']} will be accompanied by {escorts} escort{'s' if escorts != '1' else ''}")

        # Transport
        transport_selected = []
        for key, cb in self.transport_checkboxes.items():
            if cb.isChecked():
                if key == "public":
                    transport_selected.append("public transport")
                elif key == "hospital":
                    transport_selected.append("hospital transport")
                elif key == "secure":
                    transport_selected.append("secure transport")
                else:
                    transport_selected.append(key)
        if transport_selected:
            if len(transport_selected) == 1:
                parts.append(f"{p['subj']} will travel by {transport_selected[0]}")
            else:
                parts.append(f"{p['subj']} will travel by {' and by '.join(transport_selected)}")

        # Handcuffs
        if self.handcuffs_cb.isChecked():
            parts.append("Handcuffs will be carried")

        # Exclusion zone
        if self.exclusion_yes.isChecked():
            details = self.exclusion_details.text().strip()
            if details:
                parts.append(f"An exclusion zone applies: {details}")
            else:
                parts.append("An exclusion zone applies")
        elif self.exclusion_na.isChecked():
            parts.append("There is no exclusion zone")

        # Pre-leave checks
        pre_leave_parts = []
        if self.pre_leave_checkboxes["risk_free"].isChecked():
            pre_leave_parts.append(f"{p['subj_l']} must be risk free for more than 24 hours")
        if self.pre_leave_checkboxes["mental_state"].isChecked():
            pre_leave_parts.append(f"{p['pos_l']} mental state will be assessed prior to leave")
        if self.pre_leave_checkboxes["escorts_confirmed"].isChecked():
            pre_leave_parts.append("escorts will be confirmed as known to the patient")
        if self.pre_leave_checkboxes["timings"].isChecked():
            pre_leave_parts.append("all timings will be monitored")

        if pre_leave_parts:
            parts.append(f"Prior to leave, {' and '.join(pre_leave_parts)}")

        # No drugs/alcohol (separate sentence)
        if self.pre_leave_checkboxes["no_drugs"].isChecked():
            parts.append(f"{p['subj']} will not be permitted to take drugs or alcohol")

        # On return
        on_return_parts = []
        if self.on_return_checkboxes["search"].isChecked():
            on_return_parts.append(f"{p['subj_l']} will be searched")
        if self.on_return_checkboxes["drug_testing"].isChecked():
            on_return_parts.append(f"{p['subj_l']} will undergo drug testing")

        if on_return_parts:
            if len(on_return_parts) == 2:
                parts.append(f"On return {on_return_parts[0]} and {on_return_parts[1]}")
            else:
                parts.append(f"On return {on_return_parts[0]}")

        # Breaches
        breach_parts = []
        if self.breach_checkboxes["suspension"].isChecked():
            breach_parts.append("leave will be suspended")
        if self.breach_checkboxes["inform_moj"].isChecked():
            breach_parts.append("the MOJ will be informed")

        if breach_parts:
            parts.append(f"In the event of any breach {' and '.join(breach_parts)}")

        # Specific to patient
        if self.specific_to_patient.isChecked():
            parts.append("I can confirm the measures proposed are specifically defined for this patient")

        text = ". ".join(parts) + "." if parts else ""
        self.leave_procedures.setText(text)
        # Auto-sync to card - preserve user additions
        if "procedures" in self.cards and text:
            self._update_text_preserving_additions(self.cards["procedures"].editor, text, "procedures")

    def _create_hospital_admissions_popup(self) -> QWidget:
        """Create hospital admissions popup matching Tribunal Section 6 layout:
        3 CollapsibleSections - Detected Admissions, Clerking Notes, Imported Data."""
        from background_history_popup import CollapsibleSection

        popup = QWidget()
        popup.setStyleSheet("background: white;")

        root = QVBoxLayout(popup)
        root.setContentsMargins(0, 0, 0, 0)
        root.setSpacing(0)

        # Hidden label to store text for auto-sync to card
        self.hospital_admissions = QLabel()
        self.hospital_admissions.hide()

        # Main scroll area
        main_scroll = QScrollArea()
        main_scroll.setWidgetResizable(True)
        main_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        main_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        main_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)

        main_container = QWidget()
        self._4a_main_layout = QVBoxLayout(main_container)
        self._4a_main_layout.setContentsMargins(4, 4, 4, 4)
        self._4a_main_layout.setSpacing(8)

        # ====================================================
        # SECTION 1: DETECTED ADMISSIONS (table only)
        # ====================================================
        self._4a_detected_section = CollapsibleSection("Detected Admissions", start_collapsed=True)
        self._4a_detected_section.set_content_height(180)
        self._4a_detected_section._min_height = 80
        self._4a_detected_section._max_height = 400
        self._4a_detected_section.set_header_style("""
            QFrame {
                background: rgba(37, 99, 235, 0.15);
                border: 1px solid rgba(37, 99, 235, 0.3);
                border-radius: 6px 6px 0 0;
            }
        """)
        self._4a_detected_section.set_title_style("""
            QLabel {
                font-size: 14px;
                font-weight: 600;
                color: #1d4ed8;
                background: transparent;
                border: none;
            }
        """)

        detected_content = QWidget()
        detected_content.setStyleSheet("""
            QWidget {
                background: rgba(239, 246, 255, 0.95);
                border: 1px solid rgba(37, 99, 235, 0.3);
                border-top: none;
                border-radius: 0 0 12px 12px;
            }
        """)

        detected_layout = QVBoxLayout(detected_content)
        detected_layout.setContentsMargins(12, 12, 12, 12)
        detected_layout.setSpacing(8)

        # Detected admissions table (read-only, auto-populated)
        self._4a_detected_table = QTableWidget(0, 3)
        self._4a_detected_table.setHorizontalHeaderLabels(["Admission Date", "Discharge Date", "Duration"])
        self._4a_detected_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self._4a_detected_table.setMinimumHeight(60)
        self._4a_detected_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self._4a_detected_table.setStyleSheet("""
            QTableWidget {
                background: white;
                border: 1px solid #93c5fd;
                border-radius: 4px;
            }
            QHeaderView::section {
                background: #dbeafe;
                padding: 6px;
                border: none;
                border-bottom: 1px solid #93c5fd;
                font-weight: 600;
                color: #1e40af;
            }
        """)
        detected_layout.addWidget(self._4a_detected_table)

        # Export to Preview container
        export_container = QFrame()
        export_container.setStyleSheet("""
            QFrame {
                background: rgba(219, 234, 254, 0.6);
                border: 1px solid #93c5fd;
                border-radius: 6px;
            }
        """)
        export_layout = QHBoxLayout(export_container)
        export_layout.setContentsMargins(8, 4, 8, 4)

        self._4a_export_table_cb = QCheckBox("Include Table in Report")
        self._4a_export_table_cb.setStyleSheet("""
            QCheckBox {
                font-size: 13px;
                font-weight: 600;
                color: #1e40af;
                background: transparent;
            }
            QCheckBox::indicator {
                width: 14px;
                height: 14px;
            }
        """)
        self._4a_export_table_cb.stateChanged.connect(self._update_psych_preview_from_imports)
        export_layout.addWidget(self._4a_export_table_cb)
        export_layout.addStretch()

        detected_layout.addWidget(export_container)

        self._4a_detected_section.set_content(detected_content)
        self._4a_detected_section.setVisible(False)  # Hidden until data loaded
        self._4a_main_layout.addWidget(self._4a_detected_section)

        # ====================================================
        # SECTION 2: ADMISSION CLERKING NOTES
        # ====================================================
        self._4a_clerking_section = CollapsibleSection("Admission Clerking Notes", start_collapsed=True)
        self._4a_clerking_section.set_content_height(250)
        self._4a_clerking_section._min_height = 100
        self._4a_clerking_section._max_height = 500
        self._4a_clerking_section.set_header_style("""
            QFrame {
                background: rgba(37, 99, 235, 0.15);
                border: 1px solid rgba(37, 99, 235, 0.3);
                border-radius: 6px 6px 0 0;
            }
        """)
        self._4a_clerking_section.set_title_style("""
            QLabel {
                font-size: 14px;
                font-weight: 600;
                color: #1d4ed8;
                background: transparent;
                border: none;
            }
        """)

        clerking_content = QWidget()
        clerking_content.setStyleSheet("""
            QWidget {
                background: rgba(239, 246, 255, 0.95);
                border: 1px solid rgba(37, 99, 235, 0.3);
                border-top: none;
                border-radius: 0 0 12px 12px;
            }
        """)

        clerking_content_layout = QVBoxLayout(clerking_content)
        clerking_content_layout.setContentsMargins(12, 12, 12, 12)
        clerking_content_layout.setSpacing(8)

        # Scrollable container for clerking entries
        clerking_scroll = QScrollArea()
        clerking_scroll.setWidgetResizable(True)
        clerking_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        clerking_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        clerking_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        clerking_scroll.setStyleSheet("""
            QScrollArea { background: transparent; border: none; }
            QScrollArea > QWidget > QWidget { background: transparent; }
        """)

        self._4a_clerking_container = QWidget()
        self._4a_clerking_container.setStyleSheet("background: transparent;")
        self._4a_clerking_entries_layout = QVBoxLayout(self._4a_clerking_container)
        self._4a_clerking_entries_layout.setContentsMargins(2, 2, 2, 2)
        self._4a_clerking_entries_layout.setSpacing(8)
        self._4a_clerking_entries_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        clerking_scroll.setWidget(self._4a_clerking_container)
        clerking_content_layout.addWidget(clerking_scroll)

        self._4a_clerking_checkboxes = []

        self._4a_clerking_section.set_content(clerking_content)
        self._4a_clerking_section.setVisible(False)  # Hidden until data loaded
        self._4a_main_layout.addWidget(self._4a_clerking_section)

        # ====================================================
        # SECTION 3: IMPORTED DATA (collapsible, yellow/amber)
        # ====================================================
        self._4a_imported_section = CollapsibleSection("Imported Data", start_collapsed=True)
        self._4a_imported_section.set_content_height(150)
        self._4a_imported_section._min_height = 60
        self._4a_imported_section._max_height = 400
        self._4a_imported_section.set_header_style("""
            QFrame {
                background: rgba(255, 248, 220, 0.95);
                border: 1px solid rgba(180, 150, 50, 0.4);
                border-radius: 6px 6px 0 0;
            }
        """)
        self._4a_imported_section.set_title_style("""
            QLabel {
                font-size: 14px;
                font-weight: 600;
                color: #806000;
                background: transparent;
                border: none;
            }
        """)

        imported_content = QWidget()
        imported_content.setStyleSheet("""
            QWidget {
                background: rgba(255, 248, 220, 0.95);
                border: 1px solid rgba(180, 150, 50, 0.4);
                border-top: none;
                border-radius: 0 0 12px 12px;
            }
            QCheckBox {
                background: transparent;
                border: none;
                padding: 4px;
                font-size: 14px;
                color: #4a4a4a;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
        """)

        imported_layout = QVBoxLayout(imported_content)
        imported_layout.setContentsMargins(12, 10, 12, 10)
        imported_layout.setSpacing(6)

        imported_scroll = QScrollArea()
        imported_scroll.setWidgetResizable(True)
        imported_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        imported_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        imported_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        imported_scroll.setStyleSheet("""
            QScrollArea { background: transparent; border: none; }
            QScrollArea > QWidget > QWidget { background: transparent; }
        """)

        self.psych_import_content = QWidget()
        self.psych_import_content.setStyleSheet("background: transparent;")
        self.psych_import_layout = QVBoxLayout(self.psych_import_content)
        self.psych_import_layout.setContentsMargins(2, 2, 2, 2)
        self.psych_import_layout.setSpacing(12)
        self.psych_import_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        imported_scroll.setWidget(self.psych_import_content)
        imported_layout.addWidget(imported_scroll)

        self._4a_imported_section.set_content(imported_content)
        self._4a_imported_section.setVisible(False)  # Hidden until data loaded
        self._4a_main_layout.addWidget(self._4a_imported_section)

        self._4a_main_layout.addStretch()
        main_scroll.setWidget(main_container)
        root.addWidget(main_scroll)

        # Storage for imported entries and checkboxes
        self.psych_imported_entries = []
        self.psych_import_checkboxes = []
        self._psych_current_filter = None
        self._psych_all_categorized = []

        # Populate from stored extracted data if available
        if hasattr(self, '_extracted_psych_items') and self._extracted_psych_items:
            print(f"[MOJ-LEAVE] 4a popup created - populating with {len(self._extracted_psych_items)} stored psych items")
            from PySide6.QtCore import QTimer
            QTimer.singleShot(100, lambda: self._populate_psych_imports_from_categorized(self._extracted_psych_items))

        # Run timeline analysis if raw notes already available
        if hasattr(self, '_extracted_raw_notes') and self._extracted_raw_notes:
            print(f"[MOJ-LEAVE] 4a popup created - running timeline analysis with {len(self._extracted_raw_notes)} raw notes")
            from PySide6.QtCore import QTimer
            QTimer.singleShot(200, lambda: self._run_4a_timeline_analysis(self._extracted_raw_notes))

        return popup

    def _select_all_psych_imports(self):
        """Select all checkboxes in psych imports."""
        if hasattr(self, 'psych_import_checkboxes'):
            for entry in self.psych_import_checkboxes:
                entry.get("checkbox").setChecked(True)

    def _deselect_all_psych_imports(self):
        """Deselect all checkboxes in psych imports."""
        if hasattr(self, 'psych_import_checkboxes'):
            for entry in self.psych_import_checkboxes:
                entry.get("checkbox").setChecked(False)

    def _populate_psych_imports_from_categorized(self, items: list):
        """Populate imported data section matching Tribunal Section 6 yellow/amber style."""
        from datetime import datetime

        if not hasattr(self, 'psych_import_layout') or not self.psych_import_layout:
            print("[MOJ-LEAVE] psych_import_layout not available")
            return

        # Clear existing content
        while self.psych_import_layout.count():
            item = self.psych_import_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
            elif item.layout():
                while item.layout().count():
                    sub_item = item.layout().takeAt(0)
                    if sub_item.widget():
                        sub_item.widget().deleteLater()

        self.psych_import_checkboxes = []

        if not items:
            if hasattr(self, '_4a_imported_section'):
                self._4a_imported_section.setVisible(False)
            return

        # Sort by date (newest first)
        def get_sort_date(item):
            dt = item.get("date")
            if dt is None:
                return ""
            if hasattr(dt, "strftime"):
                return dt.strftime("%Y-%m-%d")
            return str(dt)

        sorted_items = sorted(items, key=get_sort_date, reverse=True)

        for item in sorted_items:
            text = (item.get("text", "") or item.get("body", "")).strip()
            if not text:
                continue

            dt = item.get("date")
            if dt:
                if hasattr(dt, "strftime"):
                    date_str = dt.strftime("%d %b %Y")
                else:
                    date_str = str(dt)
            else:
                date_str = "No date"

            # Create entry frame (yellow/amber style matching tribunal)
            entry_frame = QFrame()
            entry_frame.setObjectName("entryFrame")
            entry_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            entry_frame.setStyleSheet("""
                QFrame#entryFrame {
                    background: rgba(255, 255, 255, 0.95);
                    border: 1px solid rgba(180, 150, 50, 0.4);
                    border-radius: 8px;
                    padding: 4px;
                }
            """)
            entry_layout = QVBoxLayout(entry_frame)
            entry_layout.setContentsMargins(10, 4, 16, 4)
            entry_layout.setSpacing(6)


            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            # Toggle button
            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(180, 150, 50, 0.2);
                    border: none;
                    border-radius: 4px;
                    font-size: 15px;
                    font-weight: bold;
                    color: #806000;
                }
                QPushButton:hover { background: rgba(180, 150, 50, 0.35); }
            """)
            header_row.addWidget(toggle_btn)

            # Date label
            date_label = QLabel(f"\U0001f4c5 {date_str}")
            date_label.setStyleSheet("""
                QLabel {
                    font-size: 15px;
                    font-weight: 600;
                    color: #806000;
                    background: transparent;
                    border: none;
                }
            """)
            date_label.setCursor(Qt.CursorShape.PointingHandCursor)
            header_row.addWidget(date_label)
            header_row.addStretch()

            # Checkbox (right side, with margin)
            cb = QCheckBox()
            cb.setProperty("full_text", text)
            cb.setFixedSize(20, 20)
            cb.setStyleSheet("""
                QCheckBox { background: transparent; margin-right: 4px; }
                QCheckBox::indicator { width: 18px; height: 18px; }
            """)
            cb.stateChanged.connect(self._update_psych_preview_from_imports)
            header_row.addWidget(cb)

            entry_layout.addLayout(header_row)

            # Body text (hidden by default)
            body_text = QTextEdit()
            body_text.setPlainText(text)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("""
                QTextEdit {
                    font-size: 15px;
                    color: #333;
                    background: rgba(255, 248, 220, 0.5);
                    border: none;
                    padding: 8px;
                    border-radius: 6px;
                }
            """)
            body_text.document().setTextWidth(body_text.viewport().width() if body_text.viewport().width() > 0 else 350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            entry_layout.addWidget(body_text)

            # Toggle function
            def make_toggle(btn, body, frame, popup_self):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    frame.updateGeometry()
                    if hasattr(popup_self, 'psych_import_content'):
                        popup_self.psych_import_content.updateGeometry()
                        popup_self.psych_import_content.update()
                return toggle

            toggle_fn = make_toggle(toggle_btn, body_text, entry_frame, self)
            toggle_btn.clicked.connect(toggle_fn)
            date_label.mousePressEvent = lambda e, fn=toggle_fn: fn()

            self.psych_import_layout.addWidget(entry_frame)

            # Store reference
            self.psych_import_checkboxes.append({
                "checkbox": cb,
                "text": text,
                "date": date_str,
                "frame": entry_frame
            })

        # Show the imported data section if we have entries
        if self.psych_import_checkboxes and hasattr(self, '_4a_imported_section'):
            self._4a_imported_section.setVisible(True)

        print(f"[MOJ-LEAVE] Displayed {len(self.psych_import_checkboxes)} psych import entries (tribunal style)")

    def _clear_psych_imports(self):
        self.psych_imported_entries = []
        self.psych_import_checkboxes = []
        self._psych_all_categorized = []
        self._psych_current_filter = None

        # Clear imported data section
        if hasattr(self, 'psych_import_layout') and self.psych_import_layout:
            while self.psych_import_layout.count():
                item = self.psych_import_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()
                elif item.layout():
                    while item.layout().count():
                        sub_item = item.layout().takeAt(0)
                        if sub_item.widget():
                            sub_item.widget().deleteLater()

        if hasattr(self, '_4a_imported_section'):
            self._4a_imported_section.setVisible(False)

        # Clear detected admissions table
        if hasattr(self, '_4a_detected_table'):
            self._4a_detected_table.setRowCount(0)
        if hasattr(self, '_4a_detected_section'):
            self._4a_detected_section.setVisible(False)

        # Clear clerking notes
        if hasattr(self, '_4a_clerking_checkboxes'):
            for cb in self._4a_clerking_checkboxes:
                cb.deleteLater()
            self._4a_clerking_checkboxes = []
        if hasattr(self, '_4a_clerking_entries_layout'):
            while self._4a_clerking_entries_layout.count():
                item = self._4a_clerking_entries_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()
        if hasattr(self, '_4a_clerking_section'):
            self._4a_clerking_section.setVisible(False)

        if hasattr(self, 'hospital_admissions'):
            self.hospital_admissions.clear()

    def _run_4a_timeline_analysis(self, notes: list):
        """Analyze notes using timeline to detect admissions and find clerking notes.
        Matches TribunalPsychHistoryPopup.set_notes() exactly."""
        from timeline_builder import build_rio_timeline
        from datetime import timedelta
        from PySide6.QtWidgets import QTableWidgetItem

        print(f"[MOJ-LEAVE-4A] _run_4a_timeline_analysis called with {len(notes)} notes")

        if not notes:
            print("[MOJ-LEAVE-4A] No notes - returning early")
            if hasattr(self, '_4a_detected_section'):
                self._4a_detected_section.setVisible(False)
            if hasattr(self, '_4a_clerking_section'):
                self._4a_clerking_section.setVisible(False)
            return

        # Run timeline analysis
        try:
            print(f"[MOJ-LEAVE-4A] Running timeline analysis...")
            episodes = build_rio_timeline(notes, debug=False)
            print(f"[MOJ-LEAVE-4A] Timeline returned {len(episodes)} episodes")
        except Exception as e:
            print(f"[MOJ-LEAVE-4A] Timeline error: {e}")
            import traceback
            traceback.print_exc()
            if hasattr(self, '_4a_detected_section'):
                self._4a_detected_section.setVisible(False)
            if hasattr(self, '_4a_clerking_section'):
                self._4a_clerking_section.setVisible(False)
            return

        # Filter for inpatient admissions only
        admissions = [ep for ep in episodes if ep.get("type") == "inpatient"]
        print(f"[MOJ-LEAVE-4A] Found {len(admissions)} inpatient admissions")

        if not admissions:
            print("[MOJ-LEAVE-4A] No admissions - hiding sections")
            if hasattr(self, '_4a_detected_section'):
                self._4a_detected_section.setVisible(False)
            if hasattr(self, '_4a_clerking_section'):
                self._4a_clerking_section.setVisible(False)
            return

        # Check widget exists
        if not hasattr(self, '_4a_detected_table'):
            print("[MOJ-LEAVE-4A] Detected table widget not ready")
            return

        # Clear and populate detected admissions table
        self._4a_detected_table.setRowCount(len(admissions))

        for row, adm in enumerate(admissions):
            start_date = adm.get("start")
            end_date = adm.get("end")

            # Format dates
            if start_date:
                start_str = start_date.strftime("%d %b %Y") if hasattr(start_date, "strftime") else str(start_date)
            else:
                start_str = "Unknown"

            if end_date:
                end_str = end_date.strftime("%d %b %Y") if hasattr(end_date, "strftime") else str(end_date)
            else:
                end_str = "Ongoing"

            # Calculate duration
            if start_date and end_date:
                try:
                    duration_days = (end_date - start_date).days
                    if duration_days < 7:
                        duration_str = f"{duration_days} days"
                    elif duration_days < 30:
                        weeks = round(duration_days / 7)
                        if weeks < 1:
                            weeks = 1
                        duration_str = f"{weeks} week{'s' if weeks > 1 else ''}"
                    else:
                        months = round(duration_days / 30)
                        if months < 1:
                            months = 1
                        duration_str = f"{months} month{'s' if months > 1 else ''}"
                except:
                    duration_str = "Unknown"
            else:
                duration_str = "Ongoing"

            # Add to table
            self._4a_detected_table.setItem(row, 0, QTableWidgetItem(start_str))
            self._4a_detected_table.setItem(row, 1, QTableWidgetItem(end_str))
            self._4a_detected_table.setItem(row, 2, QTableWidgetItem(duration_str))

        # --- Find clerking/admission notes for each admission ---
        # Clear existing clerking entries
        if hasattr(self, '_4a_clerking_checkboxes'):
            for cb in self._4a_clerking_checkboxes:
                cb.deleteLater()
            self._4a_clerking_checkboxes = []

        if hasattr(self, '_4a_clerking_entries_layout'):
            while self._4a_clerking_entries_layout.count():
                item = self._4a_clerking_entries_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()

        # Admission entry keywords
        ADMISSION_KEYWORDS = [
            "admission to ward", "admitted to ward", "admitted to the ward",
            "brought to ward", "brought to the ward", "brought into ward",
            "brought onto ward", "brought onto the ward",
            "arrived on ward", "arrived on the ward", "arrived to ward",
            "transferred to ward", "transferred to the ward",
            "escorted to ward", "escorted to the ward",
            "on admission", "admission clerking", "clerking",
            "duty doctor admission", "admission note",
            "accepted to ward", "accepted onto ward",
            "admitted under", "accepted under",
            "detained under", "sectioned", "section 2", "section 3",
            "136 suite", "sec 136", "section 136",
            "nursing admission", "admission assessment",
            "initial assessment", "ward admission",
            "new admission", "patient admitted",
        ]

        clerking_notes = []
        seen_keys = set()

        for adm in admissions:
            adm_start = adm.get("start")
            if not adm_start:
                continue

            window_end = adm_start + timedelta(days=14)

            admission_window_notes = []
            for note in notes:
                note_date = note.get("date")
                if not note_date:
                    continue

                if hasattr(note_date, "date"):
                    note_date_obj = note_date.date()
                else:
                    note_date_obj = note_date

                if adm_start <= note_date_obj <= window_end:
                    admission_window_notes.append((note_date_obj, note))

            admission_window_notes.sort(key=lambda x: x[0])

            found_admission_note = None
            for note_date_obj, note in admission_window_notes:
                text = (note.get("text", "") or note.get("content", "")).lower()

                if any(kw in text for kw in ADMISSION_KEYWORDS):
                    key = (note_date_obj, text[:100])
                    if key not in seen_keys:
                        seen_keys.add(key)
                        found_admission_note = {
                            "date": note.get("date"),
                            "text": note.get("text", "") or note.get("content", ""),
                            "admission_label": adm.get("label", "Admission")
                        }
                    break

            if found_admission_note:
                clerking_notes.append(found_admission_note)

        # Create collapsible entry boxes for each clerking note (blue UI)
        for clerking in clerking_notes:
            dt = clerking.get("date")
            text = clerking.get("text", "").strip()
            adm_label = clerking.get("admission_label", "")

            if not text:
                continue

            # Format date
            if dt:
                if hasattr(dt, "strftime"):
                    date_str = dt.strftime("%d %b %Y")
                else:
                    date_str = str(dt)
            else:
                date_str = "No date"

            # Create entry frame (blue style)
            entry_frame = QFrame()
            entry_frame.setObjectName("clerkingEntryFrame")
            entry_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            entry_frame.setStyleSheet("""
                QFrame#clerkingEntryFrame {
                    background: rgba(255, 255, 255, 0.95);
                    border: 1px solid rgba(37, 99, 235, 0.4);
                    border-radius: 8px;
                    padding: 4px;
                }
            """)
            entry_layout = QVBoxLayout(entry_frame)
            entry_layout.setContentsMargins(10, 8, 10, 8)
            entry_layout.setSpacing(6)


            # Header row
            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            # Toggle button on the LEFT
            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(37, 99, 235, 0.2);
                    border: none;
                    border-radius: 4px;
                    font-size: 16px;
                    font-weight: bold;
                    color: #1e40af;
                }
                QPushButton:hover { background: rgba(37, 99, 235, 0.35); }
            """)
            header_row.addWidget(toggle_btn)

            # Admission label badge
            if adm_label:
                badge = QLabel(adm_label)
                badge.setStyleSheet("""
                    QLabel {
                        font-size: 13px;
                        font-weight: 600;
                        color: white;
                        background: #2563eb;
                        border: none;
                        border-radius: 3px;
                        padding: 2px 6px;
                    }
                """)
                header_row.addWidget(badge)

            # Date label
            date_label = QLabel(f"\U0001f4c5 {date_str}")
            date_label.setStyleSheet("""
                QLabel {
                    font-size: 15px;
                    font-weight: 600;
                    color: #1e40af;
                    background: transparent;
                    border: none;
                }
            """)
            date_label.setCursor(Qt.CursorShape.PointingHandCursor)
            header_row.addWidget(date_label)
            header_row.addStretch()

            # Checkbox on the RIGHT
            cb = QCheckBox()
            cb.setProperty("full_text", text)
            cb.setFixedSize(18, 18)
            cb.setStyleSheet("""
                QCheckBox { background: transparent; }
                QCheckBox::indicator { width: 16px; height: 16px; }
            """)
            cb.stateChanged.connect(self._update_psych_preview_from_imports)
            header_row.addWidget(cb)

            entry_layout.addLayout(header_row)

            # Body text (hidden by default)
            body_text = QTextEdit()
            body_text.setPlainText(text)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("""
                QTextEdit {
                    font-size: 15px;
                    color: #333;
                    background: rgba(219, 234, 254, 0.5);
                    border: none;
                    padding: 8px;
                    border-radius: 6px;
                }
            """)
            body_text.document().setTextWidth(body_text.viewport().width() if body_text.viewport().width() > 0 else 350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            entry_layout.addWidget(body_text)

            # Toggle function
            def make_toggle(btn, body, frame, popup_self):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    frame.updateGeometry()
                    if hasattr(popup_self, '_4a_clerking_container'):
                        popup_self._4a_clerking_container.updateGeometry()
                        popup_self._4a_clerking_container.update()
                return toggle

            toggle_fn = make_toggle(toggle_btn, body_text, entry_frame, self)
            toggle_btn.clicked.connect(toggle_fn)
            date_label.mousePressEvent = lambda e, fn=toggle_fn: fn()

            self._4a_clerking_entries_layout.addWidget(entry_frame)
            self._4a_clerking_checkboxes.append(cb)

        # Show the sections (both stay collapsed)
        self._4a_detected_section.setVisible(True)
        if clerking_notes:
            self._4a_clerking_section.setVisible(True)

        print(f"[MOJ-LEAVE-4A] Detected {len(admissions)} admissions, {len(clerking_notes)} clerking notes")

    def _update_psych_preview_from_imports(self):
        """Auto-update the psych history card combining all 3 sources:
        table data, clerking notes, and imported data entries.
        Matches TribunalPsychHistoryPopup._send_to_card() format."""
        table_parts = []
        clerking_parts = []
        extracted_parts = []

        # 1. Export table if checkbox is checked
        if hasattr(self, '_4a_export_table_cb') and self._4a_export_table_cb.isChecked():
            if hasattr(self, '_4a_detected_table'):
                table_lines = []
                for row in range(self._4a_detected_table.rowCount()):
                    adm_date = self._4a_detected_table.item(row, 0)
                    dis_date = self._4a_detected_table.item(row, 1)
                    duration = self._4a_detected_table.item(row, 2)

                    adm_str = adm_date.text() if adm_date else ""
                    dis_str = dis_date.text() if dis_date else ""
                    dur_str = duration.text() if duration else ""

                    if adm_str:
                        table_lines.append(f"Admission {row + 1}: {adm_str} - {dis_str} ({dur_str})")

                if table_lines:
                    table_parts.append("HOSPITAL ADMISSIONS:\n" + "\n".join(table_lines))

        # 2. Checked clerking entries
        if hasattr(self, '_4a_clerking_checkboxes'):
            for cb in self._4a_clerking_checkboxes:
                if cb.isChecked():
                    full_text = cb.property("full_text")
                    if full_text:
                        clerking_parts.append(full_text)

        # 3. Checked imported data entries
        if hasattr(self, 'psych_import_checkboxes') and self.psych_import_checkboxes:
            for entry in self.psych_import_checkboxes:
                cb = entry.get("checkbox")
                if cb and cb.isChecked():
                    text = entry.get("text", "").strip()
                    date_str = entry.get("date", "")
                    if text:
                        if date_str:
                            extracted_parts.append(f"[{date_str}] {text}")
                        else:
                            extracted_parts.append(text)

        # Combine (matching tribunal format)
        all_parts = []
        if table_parts:
            all_parts.extend(table_parts)
        if clerking_parts:
            all_parts.append("ADMISSION NOTES:\n" + "\n\n".join(clerking_parts))
        if extracted_parts:
            all_parts.append("FROM NOTES:\n" + "\n\n".join(extracted_parts))

        combined = "\n\n".join(all_parts) if all_parts else ""

        if hasattr(self, 'hospital_admissions'):
            self.hospital_admissions.setText(combined)

        # Auto-sync to card (only during auto-fill or when user is on this card)
        if "hospital_admissions" in self.cards:
            if self._auto_fill_phase or self._selected_card_key == "hospital_admissions" or getattr(self, '_gender_update_in_progress', False):
                self.cards["hospital_admissions"].editor.setPlainText(combined)

    def _create_index_offence_popup(self) -> QWidget:
        """Create index offence popup with entries section."""
        popup = QWidget()
        popup.setStyleSheet("background: white;")
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)

        # Hidden label to store text for auto-sync to card
        self.index_offence_preview = QLabel()
        self.index_offence_preview.hide()

        # Imported Data container (CollapsibleSection matching 4a style)
        self._4b_imported_section = CollapsibleSection("Imported Data", start_collapsed=True)
        self._4b_imported_section.set_content_height(200)
        self._4b_imported_section._min_height = 80
        self._4b_imported_section._max_height = 500
        self._4b_imported_section.set_header_style("""
            QFrame {
                background: rgba(255, 248, 220, 0.95);
                border: 1px solid rgba(180, 150, 50, 0.4);
                border-radius: 6px 6px 0 0;
            }
        """)
        self._4b_imported_section.set_title_style("""
            QLabel {
                font-size: 14px;
                font-weight: 600;
                color: #806000;
                background: transparent;
                border: none;
            }
        """)

        forensic_import_content = QWidget()
        forensic_import_content.setStyleSheet("""
            QWidget {
                background: rgba(255, 248, 220, 0.95);
                border: 1px solid rgba(180, 150, 50, 0.4);
                border-top: none;
                border-radius: 0 0 12px 12px;
            }
            QCheckBox {
                background: transparent;
                border: none;
                padding: 4px;
                font-size: 14px;
                color: #4a4a4a;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
        """)

        forensic_panel_layout = QVBoxLayout(forensic_import_content)
        forensic_panel_layout.setContentsMargins(12, 10, 12, 10)
        forensic_panel_layout.setSpacing(6)

        # Subtitle
        self.forensic_import_subtitle = QLabel("Forensic History Entries - tick to include")
        self.forensic_import_subtitle.setStyleSheet("font-size: 14px; font-weight: 600; color: #806000; background: transparent; border: none;")
        forensic_panel_layout.addWidget(self.forensic_import_subtitle)

        # Scrollable content area for entries
        forensic_import_scroll = QScrollArea()
        forensic_import_scroll.setWidgetResizable(True)
        forensic_import_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        forensic_import_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        forensic_import_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        forensic_import_scroll.setStyleSheet("""
            QScrollArea { background: transparent; border: none; }
            QScrollArea > QWidget > QWidget { background: transparent; }
        """)

        # Content widget for entries
        self.forensic_import_content = QWidget()
        self.forensic_import_content.setStyleSheet("background: transparent;")
        self.forensic_import_layout = QVBoxLayout(self.forensic_import_content)
        self.forensic_import_layout.setContentsMargins(2, 2, 2, 2)
        self.forensic_import_layout.setSpacing(6)
        self.forensic_import_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        forensic_import_scroll.setWidget(self.forensic_import_content)

        # Placeholder
        self.forensic_import_placeholder = QLabel("No entries found. Use Import Data to load clinical notes.")
        self.forensic_import_placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 13px; background: transparent; border: none;")
        self.forensic_import_layout.addWidget(self.forensic_import_placeholder)

        forensic_panel_layout.addWidget(forensic_import_scroll, 1)

        # Button row
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(8)

        select_all_btn = QPushButton("Select All")
        select_all_btn.setStyleSheet("""
            QPushButton { background: rgba(255, 248, 220, 0.95); color: #806000; border: 1px solid rgba(180, 150, 50, 0.4); padding: 8px 16px; border-radius: 6px; font-weight: 500; font-size: 13px; }
            QPushButton:hover { background: #fef3c7; }
        """)
        select_all_btn.clicked.connect(self._select_all_forensic_imports)
        btn_layout.addWidget(select_all_btn)

        deselect_all_btn = QPushButton("Deselect All")
        deselect_all_btn.setStyleSheet("""
            QPushButton { background: rgba(255, 248, 220, 0.95); color: #806000; border: 1px solid rgba(180, 150, 50, 0.4); padding: 8px 16px; border-radius: 6px; font-weight: 500; font-size: 13px; }
            QPushButton:hover { background: #fef3c7; }
        """)
        deselect_all_btn.clicked.connect(self._deselect_all_forensic_imports)
        btn_layout.addWidget(deselect_all_btn)

        btn_layout.addStretch()

        clear_btn = QPushButton("Clear")
        clear_btn.setStyleSheet("""
            QPushButton { background: rgba(255, 248, 220, 0.95); color: #991b1b; border: 1px solid rgba(180, 150, 50, 0.4); padding: 8px 16px; border-radius: 6px; font-weight: 500; font-size: 13px; }
            QPushButton:hover { background: #fef3c7; }
        """)
        clear_btn.clicked.connect(self._clear_forensic_imports)
        btn_layout.addWidget(clear_btn)

        forensic_panel_layout.addLayout(btn_layout)

        self._4b_imported_section.set_content(forensic_import_content)
        main_layout.addWidget(self._4b_imported_section, 1)

        # Storage for imported entries and checkboxes
        self.forensic_imported_entries = []
        self.forensic_import_checkboxes = []

        # Populate from stored extracted data if available
        if hasattr(self, '_extracted_forensic_items') and self._extracted_forensic_items:
            print(f"[MOJ-LEAVE] 4b popup created - populating with {len(self._extracted_forensic_items)} stored forensic items")
            from PySide6.QtCore import QTimer
            QTimer.singleShot(100, lambda: self._populate_forensic_imports_from_categorized(self._extracted_forensic_items))

        return popup

    def _select_all_forensic_imports(self):
        """Select all checkboxes in forensic imports."""
        if hasattr(self, 'forensic_import_checkboxes'):
            for entry in self.forensic_import_checkboxes:
                entry.get("checkbox").setChecked(True)

    def _deselect_all_forensic_imports(self):
        """Deselect all checkboxes in forensic imports."""
        if hasattr(self, 'forensic_import_checkboxes'):
            for entry in self.forensic_import_checkboxes:
                entry.get("checkbox").setChecked(False)

    def _clear_forensic_imports(self):
        """Clear all forensic imports."""
        self.forensic_imported_entries = []
        self.forensic_import_checkboxes = []

        if not hasattr(self, 'forensic_import_layout') or not self.forensic_import_layout:
            return

        while self.forensic_import_layout.count():
            item = self.forensic_import_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
            elif item.layout():
                while item.layout().count():
                    sub_item = item.layout().takeAt(0)
                    if sub_item.widget():
                        sub_item.widget().deleteLater()

        placeholder = QLabel("No entries found. Use Import Data to load clinical notes.")
        placeholder.setStyleSheet("color: #9ca3af; font-style: italic; font-size: 14px; background: transparent; border: none;")
        self.forensic_import_layout.addWidget(placeholder)

        if hasattr(self, 'forensic_import_subtitle'):
            self.forensic_import_subtitle.setText("Forensic History Entries - tick to include in preview")

        if hasattr(self, 'index_offence_preview'):
            self.index_offence_preview.clear()

    def _populate_forensic_imports_from_categorized(self, items: list):
        """Populate forensic imports section matching 4a style - each entry in own container,
        expand arrow on left, checkbox on right."""
        from datetime import datetime

        if not hasattr(self, 'forensic_import_layout') or not self.forensic_import_layout:
            print("[MOJ-LEAVE] forensic_import_layout not available")
            return

        # Clear existing content
        while self.forensic_import_layout.count():
            item = self.forensic_import_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
            elif item.layout():
                while item.layout().count():
                    sub_item = item.layout().takeAt(0)
                    if sub_item.widget():
                        sub_item.widget().deleteLater()

        self.forensic_import_checkboxes = []

        if not items:
            placeholder = QLabel("No forensic history entries found.")
            placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 14px; background: transparent; border: none;")
            self.forensic_import_layout.addWidget(placeholder)
            if hasattr(self, 'forensic_import_subtitle'):
                self.forensic_import_subtitle.setText("No forensic history entries")
            return

        if hasattr(self, 'forensic_import_subtitle'):
            self.forensic_import_subtitle.setText(f"Showing {len(items)} forensic history entries - tick to include")

        # Sort by date (newest first)
        def get_sort_date(item):
            dt = item.get("date")
            if dt is None:
                return ""
            if hasattr(dt, "strftime"):
                return dt.strftime("%Y-%m-%d")
            return str(dt)

        sorted_items = sorted(items, key=get_sort_date, reverse=True)

        for item in sorted_items:
            text = (item.get("text", "") or item.get("body", "")).strip()
            if not text:
                continue

            dt = item.get("date")
            if dt:
                if hasattr(dt, "strftime"):
                    date_str = dt.strftime("%d %b %Y")
                else:
                    date_str = str(dt)
            else:
                date_str = "No date"

            # Create entry frame (matching 4a style)
            entry_frame = QFrame()
            entry_frame.setObjectName("entryFrame")
            entry_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            entry_frame.setStyleSheet("""
                QFrame#entryFrame {
                    background: rgba(255, 255, 255, 0.95);
                    border: 1px solid rgba(180, 150, 50, 0.4);
                    border-radius: 8px;
                    padding: 4px;
                }
            """)
            entry_layout = QVBoxLayout(entry_frame)
            entry_layout.setContentsMargins(10, 4, 16, 4)
            entry_layout.setSpacing(4)

            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            # Toggle button (left side)
            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(180, 150, 50, 0.2);
                    border: none;
                    border-radius: 4px;
                    font-size: 15px;
                    font-weight: bold;
                    color: #806000;
                }
                QPushButton:hover { background: rgba(180, 150, 50, 0.35); }
            """)
            header_row.addWidget(toggle_btn)

            # Date label
            date_label = QLabel(f"\U0001f4c5 {date_str}")
            date_label.setStyleSheet("""
                QLabel {
                    font-size: 15px;
                    font-weight: 600;
                    color: #806000;
                    background: transparent;
                    border: none;
                }
            """)
            date_label.setCursor(Qt.CursorShape.PointingHandCursor)
            header_row.addWidget(date_label)
            header_row.addStretch()

            # Checkbox (right side, with margin)
            cb = QCheckBox()
            cb.setProperty("full_text", text)
            cb.setFixedSize(20, 20)
            cb.setStyleSheet("""
                QCheckBox { background: transparent; margin-right: 4px; }
                QCheckBox::indicator { width: 18px; height: 18px; }
            """)
            cb.stateChanged.connect(self._update_forensic_preview_from_imports)
            header_row.addWidget(cb)

            entry_layout.addLayout(header_row)

            # Body text (hidden by default)
            body_text = QTextEdit()
            body_text.setPlainText(text)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("""
                QTextEdit {
                    font-size: 15px;
                    color: #333;
                    background: rgba(255, 248, 220, 0.5);
                    border: none;
                    padding: 8px;
                    border-radius: 6px;
                }
            """)
            body_text.document().setTextWidth(body_text.viewport().width() if body_text.viewport().width() > 0 else 350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            entry_layout.addWidget(body_text)

            # Toggle function
            def make_toggle(btn, body, frame, popup_self):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    frame.updateGeometry()
                    if hasattr(popup_self, 'forensic_import_content'):
                        popup_self.forensic_import_content.updateGeometry()
                        popup_self.forensic_import_content.update()
                return toggle

            toggle_fn = make_toggle(toggle_btn, body_text, entry_frame, self)
            toggle_btn.clicked.connect(toggle_fn)
            date_label.mousePressEvent = lambda e, fn=toggle_fn: fn()

            self.forensic_import_layout.addWidget(entry_frame)

            # Store reference
            self.forensic_import_checkboxes.append({
                "checkbox": cb,
                "text": text,
                "date": date_str,
                "frame": entry_frame
            })

        print(f"[MOJ-LEAVE] Displayed {len(self.forensic_import_checkboxes)} forensic import entries (4a style)")

    def _update_forensic_preview_from_imports(self):
        """Auto-update the forensic history preview when import checkboxes change."""
        if not hasattr(self, 'forensic_import_checkboxes') or not self.forensic_import_checkboxes:
            print(f"[MOJ-LEAVE] _update_forensic_preview: No checkboxes available")
            return

        texts = []
        checked_count = 0
        for entry in self.forensic_import_checkboxes:
            cb = entry.get("checkbox")
            if cb and cb.isChecked():
                checked_count += 1
                text = entry.get("text", "").strip()
                date_str = entry.get("date", "")
                if text:
                    if date_str:
                        texts.append(f"[{date_str}] {text}")
                    else:
                        texts.append(text)

        print(f"[MOJ-LEAVE] _update_forensic_preview: {checked_count} checked, {len(texts)} texts")

        if hasattr(self, 'index_offence_preview'):
            if texts:
                combined = "\n\n".join(texts)
                self.index_offence_preview.setText(combined)
                print(f"[MOJ-LEAVE] _update_forensic_preview: Set preview with {len(combined)} chars")
                # Auto-sync to card (only during auto-fill or when user is on this card)
                if "index_offence" in self.cards:
                    if self._auto_fill_phase or self._selected_card_key == "index_offence" or getattr(self, '_gender_update_in_progress', False):
                        self.cards["index_offence"].editor.setPlainText(combined)
            else:
                self.index_offence_preview.clear()
                print(f"[MOJ-LEAVE] _update_forensic_preview: Cleared preview (no texts)")
                # Auto-sync clear to card (only during auto-fill or when user is on this card)
                if "index_offence" in self.cards:
                    if self._auto_fill_phase or self._selected_card_key == "index_offence" or getattr(self, '_gender_update_in_progress', False):
                        self.cards["index_offence"].editor.clear()
        else:
            print(f"[MOJ-LEAVE] _update_forensic_preview: index_offence_preview widget not found!")

    def _update_index_offence_preview(self):
        """Update the index offence preview with content."""
        if not hasattr(self, 'index_offence_preview'):
            return
        text = self.index_offence.toPlainText().strip() if hasattr(self, 'index_offence') else ""
        self.index_offence_preview.setText(text if text else "")
        # Auto-sync to card - preserve user additions
        if "index_offence" in self.cards and text:
            self._update_text_preserving_additions(self.cards["index_offence"].editor, text, "index_offence")

    def _create_simple_text_popup(self, label_text: str, placeholder: str, attr_name: str, key: str) -> QWidget:
        """Create a simple popup with preview panel and a text area."""
        popup, layout = self._create_popup_container(key)

        layout.addWidget(QLabel(label_text))

        text_edit = QTextEdit()
        text_edit.setPlaceholderText(placeholder)
        text_edit.setMinimumHeight(150)
        text_edit.setStyleSheet("""
            QTextEdit {
                background: white;
                border: 1px solid #d1d5db;
                border-radius: 6px;
                padding: 8px;
                font-size: 14px;
            }
        """)
        setattr(self, attr_name, text_edit)
        zoom_row = create_zoom_row(text_edit, base_size=12)
        layout.addLayout(zoom_row)
        layout.addWidget(text_edit)

        layout.addStretch()

        # Setup preview - simply shows the text content
        def generate_text():
            return text_edit.toPlainText().strip()

        self._setup_popup_preview(key, generate_text)
        self._connect_preview_updates(key, [text_edit])

        return popup

    def _create_mental_disorder_popup(self) -> QWidget:
        """Create mental disorder popup with separate collapsible containers for Mental Disorder Data and Imported Data."""
        popup = QWidget()
        popup.setStyleSheet("background: white;")
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)

        # Hidden label to store text for auto-sync to card
        self.mental_disorder_preview = QLabel()
        self.mental_disorder_preview.hide()

        # === SCROLLABLE AREA FOR BOTH COLLAPSIBLE SECTIONS ===
        sections_scroll = QScrollArea()
        sections_scroll.setWidgetResizable(True)
        sections_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        sections_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        sections_scroll.setStyleSheet("QScrollArea { background: transparent; border: none; }")

        sections_content = QWidget()
        sections_content.setStyleSheet("background: transparent;")
        sections_content.setSizePolicy(QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Preferred)
        sections_layout = QVBoxLayout(sections_content)
        sections_layout.setContentsMargins(0, 0, 0, 0)
        sections_layout.setSpacing(8)

        # ============================================================
        # SECTION 1: MENTAL DISORDER DATA (collapsible)
        # ============================================================
        md_header = QHBoxLayout()
        md_header.setSpacing(6)
        self.mental_disorder_arrow = QLabel("▾")
        self.mental_disorder_arrow.setFixedWidth(16)
        self.mental_disorder_arrow.setStyleSheet("font-size: 14px; color: #991b1b; font-weight: bold;")
        md_header.addWidget(self.mental_disorder_arrow)
        md_header_title = QLabel("<b>Mental Disorder Data</b>")
        md_header_title.setStyleSheet("font-size: 14px; color: #991b1b;")
        md_header_title.setCursor(Qt.CursorShape.PointingHandCursor)
        md_header.addWidget(md_header_title)
        md_header.addStretch()
        sections_layout.addLayout(md_header)

        # Mental Disorder container (bordered, collapsible)
        self.mental_disorder_main_container = QWidget()
        self.mental_disorder_main_container.setStyleSheet("QWidget#mental_disorder_main_container { background: #fef2f2; border: 1px solid #fecaca; border-radius: 6px; }")
        self.mental_disorder_main_container.setObjectName("mental_disorder_main_container")

        md_container_layout = QVBoxLayout(self.mental_disorder_main_container)
        md_container_layout.setContentsMargins(12, 12, 12, 12)
        md_container_layout.setSpacing(8)

        # Toggle for Mental Disorder container
        def toggle_md_container(event):
            visible = not self.mental_disorder_main_container.isVisible()
            self.mental_disorder_main_container.setVisible(visible)
            self.mental_disorder_arrow.setText("▾" if visible else "▸")

        md_header_title.mousePressEvent = toggle_md_container
        self.mental_disorder_arrow.mousePressEvent = toggle_md_container

        # === ICD-10 SECTION ===
        md_container_layout.addWidget(QLabel("<b>ICD-10 Diagnoses:</b>"))

        # ICD container
        icd_container_layout = QVBoxLayout()
        icd_container_layout.setContentsMargins(0, 0, 0, 0)
        icd_container_layout.setSpacing(4)

        # Create 3 ICD-10 dropdown combos
        self.popup_dx_combos = []
        combo_style = """
            QComboBox {
                padding: 6px 28px 6px 8px;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                font-size: 14px;
                background: white;
            }
            QComboBox:hover { border-color: #991b1b; }
            QComboBox::drop-down {
                subcontrol-origin: padding;
                subcontrol-position: center right;
                width: 24px;
                border-left: 1px solid #d1d5db;
                background: #f9fafb;
                border-top-right-radius: 4px;
                border-bottom-right-radius: 4px;
            }
            QComboBox::down-arrow {
                width: 10px; height: 10px; image: none;
                border-left: 4px solid transparent;
                border-right: 4px solid transparent;
                border-top: 5px solid #374151;
            }
            QComboBox QAbstractItemView { background: white; selection-background-color: #fee2e2; }
        """

        for i in range(3):
            lbl = QLabel(f"Diagnosis {i+1}:")
            lbl.setStyleSheet("font-weight: 500; color: #374151; font-size: 13px;")
            icd_container_layout.addWidget(lbl)

            combo = QComboBox()
            combo.setEditable(True)
            combo.setStyleSheet(combo_style)
            combo.setMinimumHeight(32)
            combo.setSizeAdjustPolicy(QComboBox.SizeAdjustPolicy.AdjustToMinimumContentsLengthWithIcon)
            combo.setMinimumContentsLength(20)
            combo.addItem("")

            if ICD10_DICT:
                for diagnosis_name, meta in sorted(ICD10_DICT.items()):
                    icd_code = meta.get("icd10", "") if isinstance(meta, dict) else ""
                    display_text = f"{diagnosis_name} ({icd_code})" if icd_code else diagnosis_name
                    combo.addItem(display_text, diagnosis_name)

            combo.setInsertPolicy(QComboBox.InsertPolicy.NoInsert)
            if ICD10_DICT:
                items = [f"{dn} ({m.get('icd10', '')})" if m.get('icd10') else dn for dn, m in ICD10_DICT.items()]
                completer = QCompleter(items)
                completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
                completer.setFilterMode(Qt.MatchFlag.MatchContains)
                combo.setCompleter(completer)

            combo.currentTextChanged.connect(self._update_mental_disorder_preview)
            icd_container_layout.addWidget(combo)
            self.popup_dx_combos.append(combo)

        md_container_layout.addLayout(icd_container_layout)

        md_container_layout.addSpacing(8)
        md_container_layout.addWidget(QLabel("<b>Clinical Description:</b>"))
        self.popup_disorder_desc = QTextEdit()
        self.popup_disorder_desc.setMaximumHeight(60)
        self.popup_disorder_desc.setPlaceholderText("Additional clinical details...")
        self.popup_disorder_desc.setStyleSheet("border: 1px solid #d1d5db; border-radius: 4px; padding: 6px; font-size: 13px; background: white;")
        self.popup_disorder_desc.textChanged.connect(self._update_mental_disorder_preview)
        md_container_layout.addWidget(self.popup_disorder_desc)

        # === 1. FACTORS EXACERBATING ILLNESS AT TIME OF I/O ===
        md_container_layout.addSpacing(12)
        md_container_layout.addWidget(QLabel("<b>1. Factors Exacerbating Illness at Time of I/O:</b>"))
        self.exacerbating_factors = {}
        factors = ["Alcohol", "Substance misuse", "Non-compliance", "Financial", "Personal relationships", "Family stress", "Physical health", "Use of weapons"]
        factors_grid = QGridLayout()
        factors_grid.setSpacing(4)
        for i, factor in enumerate(factors):
            cb = QCheckBox(factor)
            cb.setStyleSheet("QCheckBox { font-size: 13px; color: #374151; background: transparent; }")
            cb.stateChanged.connect(self._update_mental_disorder_preview)
            # Default: Non-compliance is checked
            if factor == "Non-compliance":
                cb.setChecked(True)
            factors_grid.addWidget(cb, i // 3, i % 3)
            self.exacerbating_factors[factor] = cb
        md_container_layout.addLayout(factors_grid)

        # === 2. CURRENT MENTAL STATE ===
        md_container_layout.addSpacing(10)
        md_container_layout.addWidget(QLabel("<b>2. Current Mental State (Symptoms):</b>"))
        mental_state_row = QHBoxLayout()
        mental_state_row.setSpacing(8)
        self.mental_state_options = ["Stable", "Minor", "Moderate", "Significant", "Severe"]
        self.mental_state_label = QLabel(self.mental_state_options[0])
        self.mental_state_label.setStyleSheet("color: #991b1b; font-weight: 600; min-width: 90px;")
        self.mental_state_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.mental_state_slider.setRange(0, len(self.mental_state_options) - 1)
        self.mental_state_slider.setValue(0)
        self.mental_state_slider.setStyleSheet("""
            QSlider::groove:horizontal { height: 6px; background: #e5e7eb; border-radius: 3px; }
            QSlider::handle:horizontal { width: 16px; margin: -5px 0; background: #991b1b; border-radius: 8px; }
            QSlider::sub-page:horizontal { background: #991b1b; border-radius: 3px; }
        """)
        self.mental_state_slider.valueChanged.connect(
            lambda v: self.mental_state_label.setText(self.mental_state_options[v])
        )
        self.mental_state_slider.valueChanged.connect(self._update_mental_disorder_preview)
        mental_state_row.addWidget(self.mental_state_slider, 1)
        mental_state_row.addWidget(self.mental_state_label)
        md_container_layout.addLayout(mental_state_row)

        # Insight slider
        insight_row = QHBoxLayout()
        insight_row.setSpacing(8)
        insight_row.addWidget(QLabel("Insight:"))
        self.insight_options = ["Nil", "Some", "Partial", "Moderate", "Good", "Full"]
        self.insight_label = QLabel(self.insight_options[2])
        self.insight_label.setStyleSheet("color: #991b1b; font-weight: 600; min-width: 80px;")
        self.insight_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.insight_slider.setRange(0, len(self.insight_options) - 1)
        self.insight_slider.setValue(2)
        self.insight_slider.setStyleSheet("""
            QSlider::groove:horizontal { height: 6px; background: #e5e7eb; border-radius: 3px; }
            QSlider::handle:horizontal { width: 16px; margin: -5px 0; background: #991b1b; border-radius: 8px; }
            QSlider::sub-page:horizontal { background: #991b1b; border-radius: 3px; }
        """)
        self.insight_slider.valueChanged.connect(
            lambda v: self.insight_label.setText(self.insight_options[v])
        )
        self.insight_slider.valueChanged.connect(self._update_mental_disorder_preview)
        insight_row.addWidget(self.insight_slider, 1)
        insight_row.addWidget(self.insight_label)
        md_container_layout.addLayout(insight_row)

        # === 3. CURRENT OBSERVATIONS ===
        md_container_layout.addSpacing(10)
        md_container_layout.addWidget(QLabel("<b>3. Current Observations:</b>"))
        self.observations_dropdown = QComboBox()
        self.observations_dropdown.addItems([
            "",
            "General",
            "Once/day & night",
            "Twice/day & night",
            "3 hourly",
            "2 hourly",
            "Hourly",
            "2x/hour",
            "3x/hour",
            "4x/hour",
            "1:1 eyesight",
            "1:1 arms length",
            "2:1",
            "3:1",
            "4:1"
        ])
        self.observations_dropdown.setStyleSheet("""
            QComboBox { padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white; }
            QComboBox:hover { border-color: #991b1b; }
        """)
        self.observations_dropdown.currentTextChanged.connect(self._update_mental_disorder_preview)
        md_container_layout.addWidget(self.observations_dropdown)

        # === 4. IMPACT OF PHYSICAL HEALTH ISSUES ===
        md_container_layout.addSpacing(10)
        phys_header = QLabel("<b>4. Impact of Physical Health Issues:</b>")
        phys_header.setStyleSheet("font-size: 14px; color: #374151;")
        md_container_layout.addWidget(phys_header)

        # Impact slider
        impact_row = QHBoxLayout()
        impact_row.setSpacing(8)
        impact_row.addWidget(QLabel("Impact level:"))
        self.phys_impact_options = ["Minimal", "Mild", "Some", "Moderate", "Significant", "High"]
        self.phys_impact_label = QLabel(self.phys_impact_options[0])
        self.phys_impact_label.setStyleSheet("color: #991b1b; font-weight: 600; min-width: 90px;")
        self.phys_impact_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.phys_impact_slider.setRange(0, len(self.phys_impact_options) - 1)
        self.phys_impact_slider.setValue(0)
        self.phys_impact_slider.setStyleSheet("""
            QSlider::groove:horizontal { height: 6px; background: #e5e7eb; border-radius: 3px; }
            QSlider::handle:horizontal { width: 16px; margin: -5px 0; background: #991b1b; border-radius: 8px; }
            QSlider::sub-page:horizontal { background: #991b1b; border-radius: 3px; }
        """)
        self.phys_impact_slider.valueChanged.connect(
            lambda v: self.phys_impact_label.setText(self.phys_impact_options[v])
        )
        self.phys_impact_slider.valueChanged.connect(self._update_mental_disorder_preview)
        impact_row.addWidget(self.phys_impact_slider, 1)
        impact_row.addWidget(self.phys_impact_label)
        md_container_layout.addLayout(impact_row)

        # Physical health conditions checkboxes
        self.phys_health_checkboxes = {}
        HEALTH_CONDITIONS = {
            "Cardiac": ["diabetes", "hypertension", "MI", "arrhythmias", "high cholesterol"],
            "Respiratory": ["asthma", "COPD", "bronchitis"],
            "Gastric": ["gastric ulcer", "GORD", "irritable bowel syndrome"],
            "Neurological": ["multiple sclerosis", "Parkinson's disease", "epilepsy"],
            "Hepatic": ["hepatitis C", "fatty liver", "alcohol-related liver disease"],
            "Renal": ["chronic kidney disease", "end-stage renal disease"],
            "Cancer": ["lung", "prostate", "bladder", "uterine", "breast", "brain", "kidney"]
        }

        for category, conditions in HEALTH_CONDITIONS.items():
            cat_frame = QFrame()
            cat_frame.setStyleSheet("QFrame { background: transparent; border: none; }")
            cat_layout = QVBoxLayout(cat_frame)
            cat_layout.setContentsMargins(0, 4, 0, 0)
            cat_layout.setSpacing(2)

            cat_header = QHBoxLayout()
            cat_arrow = QLabel("▸")
            cat_arrow.setFixedWidth(16)
            cat_arrow.setStyleSheet("font-size: 14px; color: #6b7280;")
            cat_header.addWidget(cat_arrow)
            cat_label = QLabel(f"{category}:")
            cat_label.setStyleSheet("font-size: 13px; font-weight: 500; color: #374151;")
            cat_label.setCursor(Qt.CursorShape.PointingHandCursor)
            cat_header.addWidget(cat_label)
            cat_header.addStretch()
            cat_layout.addLayout(cat_header)

            cond_container = QWidget()
            cond_container.setVisible(False)
            cond_layout = QVBoxLayout(cond_container)
            cond_layout.setContentsMargins(20, 2, 0, 2)
            cond_layout.setSpacing(1)

            self.phys_health_checkboxes[category] = []
            for cond in conditions:
                cb = QCheckBox(cond)
                cb.setStyleSheet("QCheckBox { font-size: 13px; color: #374151; background: transparent; }")
                cb.stateChanged.connect(self._update_mental_disorder_preview)
                cond_layout.addWidget(cb)
                self.phys_health_checkboxes[category].append(cb)

            cat_layout.addWidget(cond_container)

            def make_toggle(container, arrow):
                def toggle(event):
                    visible = not container.isVisible()
                    container.setVisible(visible)
                    arrow.setText("▾" if visible else "▸")
                return toggle

            cat_label.mousePressEvent = make_toggle(cond_container, cat_arrow)
            cat_arrow.mousePressEvent = make_toggle(cond_container, cat_arrow)

            md_container_layout.addWidget(cat_frame)

        sections_layout.addWidget(self.mental_disorder_main_container)

        # ============================================================
        # SECTION 2: IMPORTED DATA (separate collapsible container)
        # ============================================================
        import_header = QHBoxLayout()
        import_header.setSpacing(6)
        self.imported_data_arrow = QLabel("▾")
        self.imported_data_arrow.setFixedWidth(16)
        self.imported_data_arrow.setStyleSheet("font-size: 14px; color: #92400e; font-weight: bold;")
        import_header.addWidget(self.imported_data_arrow)
        import_header_title = QLabel("<b>Imported Data</b>")
        import_header_title.setStyleSheet("font-size: 14px; color: #92400e;")
        import_header_title.setCursor(Qt.CursorShape.PointingHandCursor)
        import_header.addWidget(import_header_title)
        import_header.addStretch()
        sections_layout.addLayout(import_header)

        # Imported Data container (bordered, collapsible)
        self.imported_data_container = QWidget()
        self.imported_data_container.setStyleSheet("QWidget#imported_data_container { background: #fffbeb; border: 1px solid #fcd34d; border-radius: 6px; }")
        self.imported_data_container.setObjectName("imported_data_container")

        import_container_layout = QVBoxLayout(self.imported_data_container)
        import_container_layout.setContentsMargins(12, 8, 12, 8)
        import_container_layout.setSpacing(6)

        # Toggle for Imported Data container
        def toggle_import_container(event):
            visible = not self.imported_data_container.isVisible()
            self.imported_data_container.setVisible(visible)
            self.imported_data_arrow.setText("▾" if visible else "▸")

        import_header_title.mousePressEvent = toggle_import_container
        self.imported_data_arrow.mousePressEvent = toggle_import_container

        self.mental_disorder_import_subtitle = QLabel("<b>Imported Diagnosis Entries</b> - tick to include")
        self.mental_disorder_import_subtitle.setStyleSheet("font-size: 13px; font-weight: 500; color: #92400e; background: transparent; border: none;")
        import_container_layout.addWidget(self.mental_disorder_import_subtitle)

        # Scrollable entries (resizable)
        self.mental_disorder_import_scroll = QScrollArea()
        self.mental_disorder_import_scroll.setWidgetResizable(True)
        self.mental_disorder_import_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        self.mental_disorder_import_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.mental_disorder_import_scroll.setMinimumHeight(80)
        self.mental_disorder_import_scroll.setStyleSheet("QScrollArea { background: white; border: 1px solid #d1d5db; border-radius: 4px; }")

        self.mental_disorder_import_content = QWidget()
        self.mental_disorder_import_content.setStyleSheet("background: white;")
        self.mental_disorder_import_layout = QVBoxLayout(self.mental_disorder_import_content)
        self.mental_disorder_import_layout.setContentsMargins(2, 2, 2, 2)
        self.mental_disorder_import_layout.setSpacing(8)
        self.mental_disorder_import_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        self.mental_disorder_import_scroll.setWidget(self.mental_disorder_import_content)

        placeholder = QLabel("No entries found. Use Import Data to load clinical notes.")
        placeholder.setStyleSheet("color: #9ca3af; font-style: italic; font-size: 13px; background: transparent; border: none;")
        self.mental_disorder_import_layout.addWidget(placeholder)

        import_container_layout.addWidget(self.mental_disorder_import_scroll)

        # Drag bar for resizing imported data
        md_import_drag = QWidget()
        md_import_drag.setFixedHeight(8)
        md_import_drag.setCursor(Qt.CursorShape.SizeVerCursor)
        md_import_drag.setStyleSheet("QWidget { background: #fcd34d; border-radius: 4px; margin: 2px 40px; } QWidget:hover { background: #92400e; }")
        md_import_drag._dragging = False
        md_import_drag._start_y = 0
        md_import_drag._start_height = 0

        def md_import_press(event):
            md_import_drag._dragging = True
            md_import_drag._start_y = event.globalPosition().y()
            md_import_drag._start_height = self.mental_disorder_import_scroll.height()

        def md_import_move(event):
            if md_import_drag._dragging:
                delta = event.globalPosition().y() - md_import_drag._start_y
                new_height = max(60, min(400, int(md_import_drag._start_height + delta)))
                self.mental_disorder_import_scroll.setFixedHeight(new_height)

        def md_import_release(event):
            md_import_drag._dragging = False

        md_import_drag.mousePressEvent = md_import_press
        md_import_drag.mouseMoveEvent = md_import_move
        md_import_drag.mouseReleaseEvent = md_import_release
        import_container_layout.addWidget(md_import_drag)

        # Button row
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(8)

        select_all_btn = QPushButton("Select All")
        select_all_btn.setStyleSheet("""
            QPushButton { background: white; color: #374151; border: 1px solid #d1d5db; padding: 6px 14px; border-radius: 4px; font-size: 13px; }
            QPushButton:hover { background: #e5e7eb; }
        """)
        select_all_btn.clicked.connect(self._select_all_mental_disorder_imports)
        btn_layout.addWidget(select_all_btn)

        deselect_all_btn = QPushButton("Deselect All")
        deselect_all_btn.setStyleSheet("""
            QPushButton { background: white; color: #374151; border: 1px solid #d1d5db; padding: 6px 14px; border-radius: 4px; font-size: 13px; }
            QPushButton:hover { background: #e5e7eb; }
        """)
        deselect_all_btn.clicked.connect(self._deselect_all_mental_disorder_imports)
        btn_layout.addWidget(deselect_all_btn)

        btn_layout.addStretch()

        clear_btn = QPushButton("Clear")
        clear_btn.setStyleSheet("""
            QPushButton { background: #fee2e2; color: #991b1b; border: 1px solid #fecaca; padding: 6px 14px; border-radius: 4px; font-size: 13px; }
            QPushButton:hover { background: #fecaca; }
        """)
        clear_btn.clicked.connect(self._clear_mental_disorder_imports)
        btn_layout.addWidget(clear_btn)

        import_container_layout.addLayout(btn_layout)
        sections_layout.addWidget(self.imported_data_container)

        # Add stretch at the bottom to push content up
        sections_layout.addStretch()

        # Finish the scrollable sections area
        sections_scroll.setWidget(sections_content)
        main_layout.addWidget(sections_scroll, 1)

        # Storage
        self.mental_disorder_import_checkboxes = []

        # Populate from stored data if available
        if hasattr(self, '_extracted_mental_disorder_items') and self._extracted_mental_disorder_items:
            from PySide6.QtCore import QTimer
            QTimer.singleShot(100, lambda: self._populate_mental_disorder_imports(self._extracted_mental_disorder_items))

        # Apply extracted diagnoses from patient details (ICD-10 prefill)
        # Then update preview with correct pronouns
        from PySide6.QtCore import QTimer
        def apply_and_update():
            self._apply_extracted_patient_details()
            self._update_mental_disorder_preview()
        QTimer.singleShot(0, apply_and_update)

        return popup

    def _select_all_mental_disorder_imports(self):
        """Select all mental disorder import checkboxes."""
        if hasattr(self, 'mental_disorder_import_checkboxes'):
            for entry in self.mental_disorder_import_checkboxes:
                entry.get("checkbox").setChecked(True)

    def _deselect_all_mental_disorder_imports(self):
        """Deselect all mental disorder import checkboxes."""
        if hasattr(self, 'mental_disorder_import_checkboxes'):
            for entry in self.mental_disorder_import_checkboxes:
                entry.get("checkbox").setChecked(False)

    def _clear_mental_disorder_imports(self):
        """Clear all mental disorder imports."""
        self.mental_disorder_import_checkboxes = []

        if not hasattr(self, 'mental_disorder_import_layout') or not self.mental_disorder_import_layout:
            return

        while self.mental_disorder_import_layout.count():
            item = self.mental_disorder_import_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        placeholder = QLabel("No entries found. Use Import Data to load clinical notes.")
        placeholder.setStyleSheet("color: #9ca3af; font-style: italic; font-size: 14px; background: transparent; border: none;")
        self.mental_disorder_import_layout.addWidget(placeholder)

        if hasattr(self, 'mental_disorder_import_subtitle'):
            self.mental_disorder_import_subtitle.setText("Imported Diagnosis Entries - tick to include")

        self._update_mental_disorder_preview()

    def _populate_mental_disorder_imports(self, items: list):
        """Populate mental disorder imports with +/- expand like 4a/4b."""
        if not hasattr(self, 'mental_disorder_import_layout') or not self.mental_disorder_import_layout:
            return

        # Keywords for highlighting relevant diagnosis/mental state terms
        DIAGNOSIS_HIGHLIGHT_KEYWORDS = [
            # Diagnoses
            r"\bschizophren\w*", r"\bpsychos[ie]s\b", r"\bpsychotic\b", r"\bbipolar\b",
            r"\bdepress\w*", r"\bmania\b", r"\bmanic\b", r"\banxi\w*", r"\bptsd\b",
            r"personality disorder", r"\bautis\w*", r"\badhd\b", r"\bdementia\b",
            r"\bdelirium\b", r"eating disorder", r"\bocd\b",
            r"obsessive.compulsive", r"post.traumatic", r"substance.*(?:misuse|disorder|abuse)",
            r"intellectual disability", r"learning disability",
            r"\bparanoi\w*", r"\bschizoaffective\b", r"\bcyclothymi\w*",
            r"mental illness", r"mental disorder",
            # Diagnosis terms
            r"\bdiagnos\w*", r"\bicd.10\b", r"\bdsm\b", r"\bformulation\b",
            # Mental state
            r"\bdelusion\w*", r"\bhallucin\w*", r"\binsight\b",
            r"thought\s*(?:form|content|disorder|broadcast|insertion|withdrawal|block)",
            r"ideas\s*of\s*reference", r"flight\s*of\s*ideas", r"pressure\w*\s*speech",
            r"\bneologism\w*", r"\btangential\w*", r"\bcircumstantial\w*",
            r"\bflattened\b", r"\bblunted\b", r"\bincongruous\b",
            r"\belated\b", r"\belation\b", r"\beuthymi\w*", r"\bdysthymi\w*",
            # Symptoms
            r"\bsymptom\w*", r"\brelapse\w*", r"\bremission\b", r"\bdeteriorat\w*",
            r"\bexacerbat\w*", r"\bacute\b", r"\bchronic\b",
            # Treatment
            r"\bmedication\b", r"\bclozapine\b", r"\bantipsychotic\w*",
            r"\bantidepressant\w*", r"\bmood\s*stabili[sz]\w*",
            r"\bdepot\b", r"\bsection\w*\s*(?:2|3|37|41|47|48|49)\b",
        ]

        def highlight_diagnosis_keywords(text):
            """Highlight diagnosis/mental-state keywords with amber background."""
            import html as html_mod
            escaped = html_mod.escape(text)
            sorted_kws = sorted(DIAGNOSIS_HIGHLIGHT_KEYWORDS, key=len, reverse=True)
            for kw in sorted_kws:
                pattern = re.compile(kw, re.IGNORECASE)
                escaped = pattern.sub(
                    lambda m: f'<span style="background-color: #fef08a; font-weight: 600;">{m.group()}</span>',
                    escaped
                )
            return escaped.replace('\n', '<br>')

        # Clear existing
        while self.mental_disorder_import_layout.count():
            item = self.mental_disorder_import_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self.mental_disorder_import_checkboxes = []

        if not items:
            placeholder = QLabel("No diagnosis-related entries found.")
            placeholder.setStyleSheet("color: #92400e; font-style: italic; font-size: 14px; background: transparent; border: none;")
            self.mental_disorder_import_layout.addWidget(placeholder)
            if hasattr(self, 'mental_disorder_import_subtitle'):
                self.mental_disorder_import_subtitle.setText("No diagnosis entries found")
            return

        if hasattr(self, 'mental_disorder_import_subtitle'):
            self.mental_disorder_import_subtitle.setText(f"Showing {len(items)} diagnosis entries - tick to include")

        for item in items:
            text = item.get("text", "") or item.get("body", "")
            if not text:
                continue

            full_text = text.strip()

            date_val = item.get("date")
            date_str = ""
            if date_val:
                if hasattr(date_val, "strftime"):
                    date_str = date_val.strftime("%d %b %Y")
                else:
                    date_str = str(date_val)

            # Create entry frame (4A style - white rounded container)
            entry_frame = QFrame()
            entry_frame.setObjectName("entryFrame")
            entry_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            entry_frame.setStyleSheet("""
                QFrame#entryFrame {
                    background: rgba(255, 255, 255, 0.95);
                    border: 1px solid rgba(180, 150, 50, 0.4);
                    border-radius: 8px;
                    padding: 4px;
                }
            """)
            entry_layout_v = QVBoxLayout(entry_frame)
            entry_layout_v.setContentsMargins(10, 4, 16, 4)
            entry_layout_v.setSpacing(6)

            # Header row: toggle_btn → date → stretch → checkbox
            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            # Toggle button (left side)
            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(180, 150, 50, 0.2);
                    border: none;
                    border-radius: 4px;
                    font-size: 15px;
                    font-weight: bold;
                    color: #806000;
                }
                QPushButton:hover { background: rgba(180, 150, 50, 0.35); }
            """)
            header_row.addWidget(toggle_btn)

            # Date label (amber)
            date_label = None
            if date_str:
                date_label = QLabel(f"\U0001f4c5 {date_str}")
                date_label.setStyleSheet("""
                    QLabel {
                        font-size: 15px; font-weight: 600; color: #806000;
                        background: transparent; border: none;
                    }
                """)
                date_label.setCursor(Qt.CursorShape.PointingHandCursor)
                header_row.addWidget(date_label)

            header_row.addStretch()

            # Checkbox (right side, with margin)
            cb = QCheckBox()
            cb.setFixedSize(20, 20)
            cb.setStyleSheet("""
                QCheckBox { background: transparent; margin-right: 4px; }
                QCheckBox::indicator { width: 18px; height: 18px; }
            """)
            cb.stateChanged.connect(self._update_mental_disorder_preview)
            header_row.addWidget(cb)

            entry_layout_v.addLayout(header_row)

            # Body text (hidden by default, with keyword highlighting)
            full_highlighted = highlight_diagnosis_keywords(full_text)
            body_text = QTextEdit()
            body_text.setHtml(full_highlighted)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("""
                QTextEdit {
                    font-size: 15px;
                    color: #333;
                    background: rgba(255, 248, 220, 0.5);
                    border: none;
                    padding: 8px;
                    border-radius: 6px;
                }
            """)
            body_text.document().setTextWidth(body_text.viewport().width() if body_text.viewport().width() > 0 else 350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            entry_layout_v.addWidget(body_text)

            # Toggle function
            def make_toggle(btn, body, frame):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    frame.updateGeometry()
                    if hasattr(self, 'mental_disorder_import_content'):
                        self.mental_disorder_import_content.adjustSize()
                return toggle

            toggle_fn = make_toggle(toggle_btn, body_text, entry_frame)
            toggle_btn.clicked.connect(toggle_fn)
            if date_label:
                date_label.mousePressEvent = lambda e, fn=toggle_fn: fn()

            self.mental_disorder_import_layout.addWidget(entry_frame)
            self.mental_disorder_import_checkboxes.append({"checkbox": cb, "text": full_text, "date": date_str, "frame": entry_frame})

        print(f"[MOJ-LEAVE] Displayed {len(self.mental_disorder_import_checkboxes)} mental disorder import entries")

    def _update_mental_disorder_preview(self):
        """Update mental disorder preview with full narrative output."""
        parts = []

        # ICD-10 narrative
        diagnoses = []
        if hasattr(self, 'popup_dx_combos'):
            for combo in self.popup_dx_combos:
                data = combo.currentData()
                if data:
                    diagnoses.append(data)
                else:
                    text = combo.currentText().strip()
                    if text:
                        clean = re.sub(r'\s*\([A-Z]\d+\.?\d*\)\s*$', '', text).strip()
                        diagnoses.append(clean if clean else text)

        if diagnoses:
            if len(diagnoses) == 1:
                parts.append(f"Main diagnosis is {diagnoses[0]}.")
            elif len(diagnoses) == 2:
                parts.append(f"Main diagnosis is {diagnoses[0]} with comorbid {diagnoses[1]}.")
            else:
                parts.append(f"Main diagnosis is {diagnoses[0]} with comorbid {diagnoses[1]} and {diagnoses[2]}.")

        # Clinical description
        if hasattr(self, 'popup_disorder_desc'):
            desc = self.popup_disorder_desc.toPlainText().strip()
            if desc:
                parts.append(desc)

        # 1. Factors exacerbating illness at time of I/O
        if hasattr(self, 'exacerbating_factors'):
            selected_factors = [name for name, cb in self.exacerbating_factors.items() if cb.isChecked()]
            if selected_factors:
                if len(selected_factors) == 1:
                    parts.append(f"Factors exacerbating illness at time of index offence included {selected_factors[0].lower()}.")
                else:
                    factors_text = ", ".join([f.lower() for f in selected_factors[:-1]]) + f" and {selected_factors[-1].lower()}"
                    parts.append(f"Factors exacerbating illness at time of index offence included {factors_text}.")

        # 2. Current mental state (symptoms) + Insight
        if hasattr(self, 'mental_state_slider') and hasattr(self, 'mental_state_options'):
            ms_level = self.mental_state_options[self.mental_state_slider.value()].lower()
            if ms_level == "stable":
                ms_text = "Mental state is currently stable with no significant symptoms."
            else:
                ms_text = f"Current mental state shows {ms_level} symptoms."

            # Add insight
            if hasattr(self, 'insight_slider') and hasattr(self, 'insight_options'):
                insight_level = self.insight_options[self.insight_slider.value()].lower()
                ms_text += f" Insight is {insight_level}."

            parts.append(ms_text)

        # 3. Current observations
        if hasattr(self, 'observations_dropdown'):
            obs = self.observations_dropdown.currentText().strip()
            if obs:
                parts.append(f"Currently on {obs.lower()} observations.")

        # 4. Physical health narrative
        if hasattr(self, 'phys_health_checkboxes') and hasattr(self, 'phys_impact_slider'):
            # Collect all selected conditions as a flat list
            all_conditions = []
            for cat, cb_list in self.phys_health_checkboxes.items():
                for cb in cb_list:
                    if cb.isChecked():
                        all_conditions.append(cb.text())

            if all_conditions:
                impact_level = self.phys_impact_options[self.phys_impact_slider.value()].lower()

                # Format conditions list
                if len(all_conditions) == 1:
                    conditions_text = all_conditions[0]
                elif len(all_conditions) == 2:
                    conditions_text = f"{all_conditions[0]} and {all_conditions[1]}"
                else:
                    conditions_text = ", ".join(all_conditions[:-1]) + f" and {all_conditions[-1]}"

                # Build narrative: "There is [impact] impact on his mental health from the [conditions]"
                impact_narrative = f"There is {impact_level} impact on mental health from the {conditions_text}."
                parts.append(impact_narrative)

        # Imported entries
        if hasattr(self, 'mental_disorder_import_checkboxes'):
            for entry in self.mental_disorder_import_checkboxes:
                cb = entry.get("checkbox")
                if cb and cb.isChecked():
                    text = entry.get("text", "").strip()
                    date_str = entry.get("date", "")
                    if text:
                        if date_str:
                            parts.append(f"[{date_str}] {text}")
                        else:
                            parts.append(text)

        if hasattr(self, 'mental_disorder_preview'):
            if parts:
                text = " ".join(parts)
                self.mental_disorder_preview.setText(text)
                # Auto-sync to card - preserve user additions
                if "mental_disorder" in self.cards:
                    self._update_text_preserving_additions(self.cards["mental_disorder"].editor, text, "mental_disorder")
            else:
                self.mental_disorder_preview.clear()

    def _send_mental_disorder_to_card(self):
        """Send the mental disorder preview text to the card."""
        if not hasattr(self, 'mental_disorder_preview'):
            return

        text = self.mental_disorder_preview.text().strip()
        if not text:
            return

        key = "mental_disorder"
        if key in self.cards:
            current = self.cards[key].editor.toPlainText()
            if current:
                self.cards[key].editor.setPlainText(current + "\n\n" + text)
            else:
                self.cards[key].editor.setPlainText(text)

    def _generate_mental_disorder_text(self) -> str:
        """Generate mental disorder text from ICD-10 selections in narrative format."""
        diagnoses = []
        for combo in self.popup_dx_combos:
            data = combo.currentData()
            if data:
                diagnoses.append(data)
            else:
                text = combo.currentText().strip()
                if text:
                    # Strip ICD code in brackets
                    clean = re.sub(r'\s*\([A-Z]\d+\.?\d*\)\s*$', '', text).strip()
                    diagnoses.append(clean if clean else text)

        desc = self.popup_disorder_desc.toPlainText().strip()

        if not diagnoses:
            return desc if desc else ""

        # Build narrative format
        if len(diagnoses) == 1:
            narrative = f"Main diagnosis is {diagnoses[0]}."
        elif len(diagnoses) == 2:
            narrative = f"Main diagnosis is {diagnoses[0]} with comorbid {diagnoses[1]}."
        else:
            narrative = f"Main diagnosis is {diagnoses[0]} with comorbid {diagnoses[1]} and {diagnoses[2]}."

        if desc:
            narrative += f"\n\n{desc}"

        return narrative

    def _create_attitude_behaviour_popup(self) -> QWidget:
        """Build attitude & behaviour popup with Attitude, Relationships, Engagement, and Behaviour sections."""
        key = "attitude_behaviour"

        # Main container
        popup = QWidget()
        popup.setStyleSheet("background: white;")
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)

        combo_style = "QComboBox { padding: 5px 10px; border: 1px solid #d1d5db; border-radius: 4px; background: white; font-size: 14px; min-width: 90px; }"
        slider_style = """
            QSlider::groove:horizontal { height: 4px; background: #e5e7eb; border-radius: 2px; }
            QSlider::handle:horizontal { width: 12px; margin: -4px 0; background: #7c3aed; border-radius: 6px; }
            QSlider::sub-page:horizontal { background: #7c3aed; border-radius: 2px; }
        """

        # Hidden label to store text for auto-sync to card
        self.attitude_behaviour_preview = QLabel()
        self.attitude_behaviour_preview.hide()

        # Main scroll area for the rest
        content_scroll = QScrollArea()
        content_scroll.setWidgetResizable(True)
        content_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        content_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        content_scroll.setStyleSheet("QScrollArea { background: white; border: none; }")

        content_widget = QWidget()
        content_widget.setStyleSheet("background: white;")
        content_widget.setSizePolicy(QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Preferred)
        content_layout = QVBoxLayout(content_widget)
        content_layout.setContentsMargins(4, 0, 4, 0)
        content_layout.setSpacing(6)

        # ============================================
        # 1. ATTITUDE SECTION (collapsible) - ASR Section 6 style
        # ============================================
        attitude_header = QHBoxLayout()
        attitude_header.setSpacing(6)
        self.attitude_arrow = QLabel("▾")
        self.attitude_arrow.setFixedWidth(16)
        self.attitude_arrow.setStyleSheet("font-size: 14px; color: #7c3aed; font-weight: bold;")
        attitude_header.addWidget(self.attitude_arrow)
        attitude_title = QLabel("<b>Attitude</b>")
        attitude_title.setStyleSheet("font-size: 14px; color: #7c3aed;")
        attitude_title.setCursor(Qt.CursorShape.PointingHandCursor)
        attitude_header.addWidget(attitude_title)
        attitude_header.addStretch()
        content_layout.addLayout(attitude_header)

        self.attitude_container = QWidget()
        self.attitude_container.setObjectName("attitude_container")
        self.attitude_container.setStyleSheet("""
            QWidget#attitude_container { background: #f5f3ff; border: 1px solid #c4b5fd; border-radius: 6px; }
            QLabel { background: transparent; border: none; }
            QComboBox { background: white; }
        """)
        attitude_container_layout = QVBoxLayout(self.attitude_container)
        attitude_container_layout.setContentsMargins(10, 8, 10, 8)
        attitude_container_layout.setSpacing(4)

        # Understanding & Compliance Grid (from ASR section 6)
        header_lbl = QLabel("<b>Understanding & Compliance:</b>")
        header_lbl.setStyleSheet("font-size: 14px; color: #374151;")
        attitude_container_layout.addWidget(header_lbl)
        grid = QGridLayout()
        grid.setSpacing(4)
        grid.setColumnStretch(0, 0)  # Treatment label - fixed
        grid.setColumnStretch(1, 0)  # Understanding - fixed
        grid.setColumnStretch(2, 0)  # Compliance - fixed
        grid.setColumnStretch(3, 1)  # Spacer column - stretch to push left
        t_lbl = QLabel("Treatment")
        t_lbl.setStyleSheet("font-size: 14px; color: #6b7280;")
        u_lbl = QLabel("Understanding")
        u_lbl.setStyleSheet("font-size: 14px; color: #6b7280;")
        c_lbl = QLabel("Compliance")
        c_lbl.setStyleSheet("font-size: 14px; color: #6b7280;")
        grid.addWidget(t_lbl, 0, 0)
        grid.addWidget(u_lbl, 0, 1)
        grid.addWidget(c_lbl, 0, 2)

        self.att_treatments = {}
        treatment_names = ["Medical", "Nursing", "Psychology", "OT", "Social Work"]
        treatment_keys = ["medical", "nursing", "psychology", "ot", "social_work"]
        understanding_options = ["", "good", "fair", "poor"]
        compliance_options = ["", "full", "reasonable", "partial", "nil"]

        for i, (name, key) in enumerate(zip(treatment_names, treatment_keys), 1):
            lbl = QLabel(name)
            lbl.setStyleSheet("font-size: 14px; color: #374151;")
            grid.addWidget(lbl, i, 0)

            understanding = QComboBox()
            understanding.addItems(understanding_options)
            understanding.setStyleSheet(combo_style)
            understanding.currentIndexChanged.connect(self._update_attitude_behaviour_preview)
            grid.addWidget(understanding, i, 1)

            compliance = QComboBox()
            compliance.addItems(compliance_options)
            compliance.setStyleSheet(combo_style)
            compliance.currentIndexChanged.connect(self._update_attitude_behaviour_preview)
            grid.addWidget(compliance, i, 2)

            self.att_treatments[key] = {"understanding": understanding, "compliance": compliance}

        attitude_container_layout.addLayout(grid)

        # Ward Rules
        attitude_container_layout.addSpacing(4)
        ward_row = QHBoxLayout()
        ward_lbl = QLabel("Ward rules:")
        ward_lbl.setStyleSheet("font-size: 14px; color: #374151;")
        ward_row.addWidget(ward_lbl)
        self.ward_rules_combo = QComboBox()
        self.ward_rules_combo.addItems(["", "Compliant", "Mostly compliant", "Partially compliant", "Non-compliant"])
        self.ward_rules_combo.setStyleSheet("QComboBox { padding: 5px 10px; border: 1px solid #d1d5db; border-radius: 4px; background: white; font-size: 14px; min-width: 160px; }")
        self.ward_rules_combo.currentTextChanged.connect(self._update_attitude_behaviour_preview)
        ward_row.addWidget(self.ward_rules_combo)
        ward_row.addStretch()
        attitude_container_layout.addLayout(ward_row)

        # Response to Conflict
        conflict_row = QHBoxLayout()
        conflict_lbl = QLabel("Conflict:")
        conflict_lbl.setStyleSheet("font-size: 14px; color: #374151;")
        conflict_row.addWidget(conflict_lbl)
        self.conflict_combo = QComboBox()
        self.conflict_combo.addItems(["", "Avoids", "De-escalates", "Neutral", "Escalates", "Aggressive"])
        self.conflict_combo.setStyleSheet("QComboBox { padding: 5px 10px; border: 1px solid #d1d5db; border-radius: 4px; background: white; font-size: 14px; min-width: 140px; }")
        self.conflict_combo.currentTextChanged.connect(self._update_attitude_behaviour_preview)
        conflict_row.addWidget(self.conflict_combo)
        conflict_row.addStretch()
        attitude_container_layout.addLayout(conflict_row)

        content_layout.addWidget(self.attitude_container)

        def toggle_attitude(event):
            visible = not self.attitude_container.isVisible()
            self.attitude_container.setVisible(visible)
            self.attitude_arrow.setText("▾" if visible else "▸")
        attitude_title.mousePressEvent = toggle_attitude
        self.attitude_arrow.mousePressEvent = toggle_attitude

        # ============================================
        # 2. RELATIONSHIPS SECTION (collapsible)
        # ============================================
        rel_header = QHBoxLayout()
        rel_header.setSpacing(6)
        self.rel_arrow = QLabel("▾")
        self.rel_arrow.setFixedWidth(16)
        self.rel_arrow.setStyleSheet("font-size: 14px; color: #0891b2; font-weight: bold;")
        rel_header.addWidget(self.rel_arrow)
        rel_title = QLabel("<b>Relationships</b>")
        rel_title.setStyleSheet("font-size: 14px; color: #0891b2;")
        rel_title.setCursor(Qt.CursorShape.PointingHandCursor)
        rel_header.addWidget(rel_title)
        rel_header.addStretch()
        content_layout.addLayout(rel_header)

        self.rel_container = QWidget()
        self.rel_container.setObjectName("rel_container")
        self.rel_container.setStyleSheet("""
            QWidget#rel_container { background: #ecfeff; border: 1px solid #a5f3fc; border-radius: 6px; }
            QLabel { background: transparent; border: none; }
            QRadioButton { background: transparent; border: none; }
        """)
        rel_container_layout = QVBoxLayout(self.rel_container)
        rel_container_layout.setContentsMargins(10, 8, 10, 8)
        rel_container_layout.setSpacing(6)

        # Storage for relationship levels
        self.relationship_levels = {"staff": 2, "peers": 2, "family": 2, "friends": 2}
        self.current_relationship = "staff"

        # Radio buttons for relationship type
        rel_radio_row = QHBoxLayout()
        rel_radio_row.setSpacing(12)
        self.rel_radio_group = QButtonGroup(popup)
        self.rel_radios = {}
        for rel_type in ["Staff", "Peers", "Family", "Friends"]:
            rb = QRadioButton(rel_type)
            rb.setStyleSheet("font-size: 14px; color: #0e7490;")
            self.rel_radio_group.addButton(rb)
            self.rel_radios[rel_type.lower()] = rb
            rel_radio_row.addWidget(rb)
            rb.toggled.connect(lambda checked, rt=rel_type.lower(): self._on_relationship_radio_changed(rt, checked))
        self.rel_radios["staff"].setChecked(True)
        rel_radio_row.addStretch()
        rel_container_layout.addLayout(rel_radio_row)

        # Level slider
        level_row = QHBoxLayout()
        level_lbl = QLabel("Level:")
        level_lbl.setStyleSheet("font-size: 14px; color: #374151;")
        level_row.addWidget(level_lbl)
        self.rel_level_options = ["Limited", "Some", "Good", "Close", "Very good"]
        self.rel_level_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.rel_level_slider.setRange(0, len(self.rel_level_options) - 1)
        self.rel_level_slider.setValue(2)
        self.rel_level_slider.setStyleSheet(slider_style.replace("#7c3aed", "#0891b2"))
        self.rel_level_slider.valueChanged.connect(self._on_relationship_slider_changed)
        level_row.addWidget(self.rel_level_slider, 1)

        self.rel_level_label = QLabel(self.rel_level_options[2])
        self.rel_level_label.setStyleSheet("font-size: 14px; font-weight: 600; color: #0891b2; min-width: 80px;")
        level_row.addWidget(self.rel_level_label)
        rel_container_layout.addLayout(level_row)

        content_layout.addWidget(self.rel_container)

        def toggle_rel(event):
            visible = not self.rel_container.isVisible()
            self.rel_container.setVisible(visible)
            self.rel_arrow.setText("▾" if visible else "▸")
        rel_title.mousePressEvent = toggle_rel
        self.rel_arrow.mousePressEvent = toggle_rel

        # ============================================
        # 3. ATTITUDES TO ENGAGEMENT (collapsible) - ASR Section 5 Section 2
        # ============================================
        eng_header = QHBoxLayout()
        eng_header.setSpacing(6)
        self.eng_arrow = QLabel("▾")
        self.eng_arrow.setFixedWidth(16)
        self.eng_arrow.setStyleSheet("font-size: 14px; color: #059669; font-weight: bold;")
        eng_header.addWidget(self.eng_arrow)
        eng_title = QLabel("<b>Attitudes to Engagement</b>")
        eng_title.setStyleSheet("font-size: 14px; color: #059669;")
        eng_title.setCursor(Qt.CursorShape.PointingHandCursor)
        eng_header.addWidget(eng_title)
        eng_header.addStretch()
        content_layout.addLayout(eng_header)

        self.eng_container = QWidget()
        self.eng_container.setObjectName("eng_container")
        self.eng_container.setStyleSheet("""
            QWidget#eng_container { background: #ecfdf5; border: 1px solid #a7f3d0; border-radius: 6px; }
            QLabel { background: transparent; border: none; }
            QCheckBox { background: transparent; border: none; }
        """)
        eng_container_layout = QVBoxLayout(self.eng_container)
        eng_container_layout.setContentsMargins(10, 8, 10, 8)
        eng_container_layout.setSpacing(4)

        # OT Groups
        ot_header = QLabel("<b>OT Groups:</b>")
        ot_header.setStyleSheet("font-size: 14px; color: #374151;")
        eng_container_layout.addWidget(ot_header)
        ot_grid = QGridLayout()
        ot_grid.setSpacing(4)
        ot_items = [("breakfast_club", "Breakfast"), ("cooking", "Cooking"), ("current_affairs", "Current affairs"),
                    ("self_care", "Self care"), ("music", "Music"), ("art", "Art"), ("gym", "Gym"), ("horticulture", "Horticulture"),
                    ("woodwork", "Woodwork"), ("walking", "Walking group")]
        self.eng_ot_checkboxes = {}
        for i, (key, label) in enumerate(ot_items):
            cb = QCheckBox(label)
            cb.setStyleSheet("font-size: 14px; color: #374151;")
            cb.stateChanged.connect(self._update_attitude_behaviour_preview)
            ot_grid.addWidget(cb, i // 3, i % 3)
            self.eng_ot_checkboxes[key] = cb
        eng_container_layout.addLayout(ot_grid)

        # OT Engagement slider
        ot_eng_row = QHBoxLayout()
        ot_eng_lbl = QLabel("OT Engagement:")
        ot_eng_lbl.setStyleSheet("font-size: 14px; color: #374151;")
        ot_eng_row.addWidget(ot_eng_lbl)
        self.eng_ot_options = ["Limited", "Mixed", "Reasonable", "Good", "Very Good", "Excellent"]
        self.eng_ot_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.eng_ot_slider.setRange(0, len(self.eng_ot_options) - 1)
        self.eng_ot_slider.setValue(2)
        self.eng_ot_slider.setStyleSheet(slider_style.replace("#7c3aed", "#059669"))
        self.eng_ot_slider.valueChanged.connect(lambda v: self.eng_ot_label.setText(self.eng_ot_options[v]))
        self.eng_ot_slider.valueChanged.connect(self._update_attitude_behaviour_preview)
        ot_eng_row.addWidget(self.eng_ot_slider, 1)
        self.eng_ot_label = QLabel(self.eng_ot_options[2])
        self.eng_ot_label.setStyleSheet("font-size: 14px; font-weight: 600; color: #059669; min-width: 80px;")
        ot_eng_row.addWidget(self.eng_ot_label)
        eng_container_layout.addLayout(ot_eng_row)

        # Psychology
        eng_container_layout.addSpacing(4)
        psych_header = QLabel("<b>Psychology:</b>")
        psych_header.setStyleSheet("font-size: 14px; color: #374151;")
        eng_container_layout.addWidget(psych_header)
        psych_grid = QGridLayout()
        psych_grid.setSpacing(4)
        psych_items = [("one_to_one", "1-1"), ("risk", "Risk"), ("insight", "Insight"), ("psychoeducation", "Psychoed"),
                       ("managing_emotions", "Emotions"), ("drugs_alcohol", "Drugs/alcohol"), ("discharge_planning", "Discharge"),
                       ("relapse_prevention_group", "Relapse prev (group)"), ("relapse_prevention_1to1", "Relapse prev (1-1)")]
        self.eng_psych_checkboxes = {}
        for i, (key, label) in enumerate(psych_items):
            cb = QCheckBox(label)
            cb.setStyleSheet("font-size: 14px; color: #374151;")
            cb.stateChanged.connect(self._update_attitude_behaviour_preview)
            psych_grid.addWidget(cb, i // 3, i % 3)
            self.eng_psych_checkboxes[key] = cb
        eng_container_layout.addLayout(psych_grid)

        # Psychology Engagement slider
        psych_eng_row = QHBoxLayout()
        psych_eng_lbl = QLabel("Psychology Engagement:")
        psych_eng_lbl.setStyleSheet("font-size: 14px; color: #374151;")
        psych_eng_row.addWidget(psych_eng_lbl)
        self.eng_psych_options = ["Limited", "Mixed", "Reasonable", "Good", "Very Good", "Excellent"]
        self.eng_psych_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.eng_psych_slider.setRange(0, len(self.eng_psych_options) - 1)
        self.eng_psych_slider.setValue(2)
        self.eng_psych_slider.setStyleSheet(slider_style.replace("#7c3aed", "#059669"))
        self.eng_psych_slider.valueChanged.connect(lambda v: self.eng_psych_label.setText(self.eng_psych_options[v]))
        self.eng_psych_slider.valueChanged.connect(self._update_attitude_behaviour_preview)
        psych_eng_row.addWidget(self.eng_psych_slider, 1)
        self.eng_psych_label = QLabel(self.eng_psych_options[2])
        self.eng_psych_label.setStyleSheet("font-size: 14px; font-weight: 600; color: #059669; min-width: 80px;")
        psych_eng_row.addWidget(self.eng_psych_label)
        eng_container_layout.addLayout(psych_eng_row)

        content_layout.addWidget(self.eng_container)

        def toggle_eng(event):
            visible = not self.eng_container.isVisible()
            self.eng_container.setVisible(visible)
            self.eng_arrow.setText("▾" if visible else "▸")
        eng_title.mousePressEvent = toggle_eng
        self.eng_arrow.mousePressEvent = toggle_eng

        # ============================================
        # 4. BEHAVIOUR SECTION (collapsible) - ASR Section 4
        # ============================================
        behaviour_header = QHBoxLayout()
        behaviour_header.setSpacing(6)
        self.behaviour_arrow = QLabel("▾")
        self.behaviour_arrow.setFixedWidth(16)
        self.behaviour_arrow.setStyleSheet("font-size: 14px; color: #991b1b; font-weight: bold;")
        behaviour_header.addWidget(self.behaviour_arrow)
        behaviour_title = QLabel("<b>Behaviour</b>")
        behaviour_title.setStyleSheet("font-size: 14px; color: #991b1b;")
        behaviour_title.setCursor(Qt.CursorShape.PointingHandCursor)
        behaviour_header.addWidget(behaviour_title)
        behaviour_header.addStretch()
        content_layout.addLayout(behaviour_header)

        self.behaviour_container = QWidget()
        self.behaviour_container.setObjectName("behaviour_container")
        self.behaviour_container.setStyleSheet("""
            QWidget#behaviour_container { background: #fef2f2; border: 1px solid #fecaca; border-radius: 6px; }
            QLabel { background: transparent; border: none; }
            QRadioButton { background: transparent; border: none; }
            QLineEdit { background: white; }
        """)
        behaviour_container_layout = QVBoxLayout(self.behaviour_container)
        behaviour_container_layout.setContentsMargins(10, 8, 10, 8)
        behaviour_container_layout.setSpacing(4)

        beh_header = QLabel("<b>Behavioural concerns (last 12 months):</b>")
        beh_header.setStyleSheet("font-size: 14px; color: #374151;")
        behaviour_container_layout.addWidget(beh_header)

        self.behaviour_items = {}
        behaviour_categories = [
            ("verbal_physical", "Verbal/physical aggression", "no verbal or physical aggression"),
            ("substance_abuse", "Substance abuse", "no substance abuse"),
            ("self_harm", "Self-harm", "no self-harm"),
            ("fire_setting", "Fire-setting", "no fire-setting"),
            ("intimidation", "Intimidation/threats", "no intimidation or threats"),
            ("secretive", "Secretive/manipulative", "no secretive or manipulative behaviour"),
            ("subversive", "Subversive behaviour", "no subversive behaviour"),
            ("sexually_disinhibited", "Sexually inappropriate", "no sexually disinhibited behaviour"),
            ("extremist", "Extremist behaviour", "no extremist behaviour"),
            ("seclusion", "Periods of seclusion", "no periods of seclusion"),
        ]

        grid_widget = QWidget()
        grid_widget.setStyleSheet("background: transparent; border: none;")
        grid_layout = QGridLayout(grid_widget)
        grid_layout.setContentsMargins(0, 4, 0, 4)
        grid_layout.setSpacing(4)
        grid_layout.setColumnStretch(0, 1)
        grid_layout.setColumnStretch(1, 0)
        grid_layout.setColumnStretch(2, 0)

        for row, (bkey, label, negative_text) in enumerate(behaviour_categories):
            lbl = QLabel(label)
            lbl.setStyleSheet("font-size: 14px; color: #374151; background: transparent; border: none;")
            grid_layout.addWidget(lbl, row, 0)

            btn_widget = QWidget()
            btn_widget.setStyleSheet("background: transparent; border: none;")
            btn_widget.setFixedWidth(110)
            btn_layout = QHBoxLayout(btn_widget)
            btn_layout.setContentsMargins(0, 0, 0, 0)
            btn_layout.setSpacing(4)

            yes_rb = QRadioButton("Yes")
            yes_rb.setStyleSheet("font-size: 14px; color: #059669; background: transparent; border: none;")
            no_rb = QRadioButton("No")
            no_rb.setStyleSheet("font-size: 14px; color: #dc2626; background: transparent; border: none;")

            btn_group = QButtonGroup(btn_widget)
            btn_group.addButton(yes_rb, 1)
            btn_group.addButton(no_rb, 0)

            btn_layout.addWidget(yes_rb)
            btn_layout.addWidget(no_rb)
            grid_layout.addWidget(btn_widget, row, 1)

            details_input = QLineEdit()
            details_input.setPlaceholderText("Details")
            details_input.setStyleSheet("font-size: 14px; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 3px; background: white;")
            details_input.setFixedWidth(130)
            details_input.hide()
            grid_layout.addWidget(details_input, row, 2)

            yes_rb.toggled.connect(lambda checked, d=details_input: d.setVisible(checked))
            yes_rb.toggled.connect(self._update_attitude_behaviour_preview)
            no_rb.toggled.connect(self._update_attitude_behaviour_preview)
            details_input.textChanged.connect(self._update_attitude_behaviour_preview)

            self.behaviour_items[bkey] = {"yes": yes_rb, "no": no_rb, "details": details_input, "label": label, "negative": negative_text}

        behaviour_container_layout.addWidget(grid_widget)
        content_layout.addWidget(self.behaviour_container)

        def toggle_behaviour(event):
            visible = not self.behaviour_container.isVisible()
            self.behaviour_container.setVisible(visible)
            self.behaviour_arrow.setText("▾" if visible else "▸")
        behaviour_title.mousePressEvent = toggle_behaviour
        self.behaviour_arrow.mousePressEvent = toggle_behaviour

        # ============================================
        # 5. IMPORTED DATA SECTION (matching 4a style)
        # ============================================
        import_header = QHBoxLayout()
        import_header.setSpacing(6)
        self.att_import_arrow = QLabel("▸")
        self.att_import_arrow.setFixedWidth(16)
        self.att_import_arrow.setStyleSheet("font-size: 14px; color: #806000; font-weight: bold;")
        import_header.addWidget(self.att_import_arrow)
        import_title = QLabel("<b>Imported Data</b>")
        import_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #806000;")
        import_title.setCursor(Qt.CursorShape.PointingHandCursor)
        import_header.addWidget(import_title)
        import_header.addStretch()
        content_layout.addLayout(import_header)

        self.att_import_container = QWidget()
        self.att_import_container.setObjectName("att_import_container")
        self.att_import_container.setStyleSheet("""
            QWidget#att_import_container {
                background: rgba(255, 248, 220, 0.95);
                border: 1px solid rgba(180, 150, 50, 0.4);
                border-radius: 12px;
            }
            QLabel { background: transparent; border: none; }
            QCheckBox {
                background: transparent;
                border: none;
                padding: 4px;
                font-size: 14px;
                color: #4a4a4a;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
        """)
        self.att_import_container.setVisible(False)

        att_import_layout = QVBoxLayout(self.att_import_container)
        att_import_layout.setContentsMargins(12, 10, 12, 10)
        att_import_layout.setSpacing(6)

        self.att_import_subtitle = QLabel("Attitude & behaviour entries from imported data - tick to include")
        self.att_import_subtitle.setStyleSheet("font-size: 14px; font-weight: 500; color: #806000;")
        att_import_layout.addWidget(self.att_import_subtitle)

        # Scrollable entries (resizable)
        self.att_import_scroll = QScrollArea()
        self.att_import_scroll.setWidgetResizable(True)
        self.att_import_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        self.att_import_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.att_import_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.att_import_scroll.setMinimumHeight(80)
        self.att_import_scroll.setFixedHeight(250)
        self.att_import_scroll.setStyleSheet("""
            QScrollArea { background: transparent; border: none; }
            QScrollArea > QWidget > QWidget { background: transparent; }
        """)

        self.att_import_content = QWidget()
        self.att_import_content.setStyleSheet("background: transparent;")
        self.att_import_entries_layout = QVBoxLayout(self.att_import_content)
        self.att_import_entries_layout.setContentsMargins(2, 2, 2, 2)
        self.att_import_entries_layout.setSpacing(4)
        self.att_import_entries_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        self.att_import_scroll.setWidget(self.att_import_content)

        placeholder = QLabel("No entries found. Use Import Data to load clinical notes.")
        placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 14px;")
        self.att_import_entries_layout.addWidget(placeholder)

        att_import_layout.addWidget(self.att_import_scroll)

        # Drag bar for resizing imported data
        att_import_drag = QWidget()
        att_import_drag.setFixedHeight(8)
        att_import_drag.setCursor(Qt.CursorShape.SizeVerCursor)
        att_import_drag.setStyleSheet("QWidget { background: rgba(180, 150, 50, 0.4); border-radius: 4px; margin: 2px 40px; } QWidget:hover { background: #806000; }")
        att_import_drag._dragging = False
        att_import_drag._start_y = 0
        att_import_drag._start_height = 0

        def att_import_press(event):
            att_import_drag._dragging = True
            att_import_drag._start_y = event.globalPosition().y()
            att_import_drag._start_height = self.att_import_scroll.height()

        def att_import_move(event):
            if att_import_drag._dragging:
                delta = event.globalPosition().y() - att_import_drag._start_y
                new_height = max(60, min(400, int(att_import_drag._start_height + delta)))
                self.att_import_scroll.setFixedHeight(new_height)

        def att_import_release(event):
            att_import_drag._dragging = False

        att_import_drag.mousePressEvent = att_import_press
        att_import_drag.mouseMoveEvent = att_import_move
        att_import_drag.mouseReleaseEvent = att_import_release
        att_import_layout.addWidget(att_import_drag)

        content_layout.addWidget(self.att_import_container)

        # Storage for imported checkboxes
        self.att_import_checkboxes = []

        def toggle_att_import(event):
            visible = not self.att_import_container.isVisible()
            self.att_import_container.setVisible(visible)
            self.att_import_arrow.setText("▾" if visible else "▸")
        import_title.mousePressEvent = toggle_att_import
        self.att_import_arrow.mousePressEvent = toggle_att_import

        content_layout.addStretch()
        content_scroll.setWidget(content_widget)
        main_layout.addWidget(content_scroll, 1)

        # Apply any stored patient details from import (delayed to ensure widgets are ready)
        # Then update preview with correct pronouns
        from PySide6.QtCore import QTimer
        def apply_and_update():
            self._apply_extracted_patient_details()
            self._update_attitude_behaviour_preview()
        QTimer.singleShot(0, apply_and_update)

        return popup

    def _on_relationship_radio_changed(self, rel_type, checked):
        """Handle relationship radio button change - save current value and load new one."""
        if not checked:
            return
        # Save current slider value to previous relationship
        if hasattr(self, 'current_relationship') and hasattr(self, 'rel_level_slider'):
            self.relationship_levels[self.current_relationship] = self.rel_level_slider.value()
        # Update current relationship and load its value
        self.current_relationship = rel_type
        if hasattr(self, 'rel_level_slider'):
            self.rel_level_slider.blockSignals(True)
            self.rel_level_slider.setValue(self.relationship_levels.get(rel_type, 2))
            self.rel_level_label.setText(self.rel_level_options[self.rel_level_slider.value()])
            self.rel_level_slider.blockSignals(False)
        self._update_attitude_behaviour_preview()

    def _on_relationship_slider_changed(self, value):
        """Handle relationship slider change - save to current relationship."""
        if hasattr(self, 'current_relationship'):
            self.relationship_levels[self.current_relationship] = value
        if hasattr(self, 'rel_level_label'):
            self.rel_level_label.setText(self.rel_level_options[value])
        self._update_attitude_behaviour_preview()

    def _update_attitude_behaviour_preview(self):
        """Update the attitude/behaviour preview based on selections."""
        if not hasattr(self, 'attitude_behaviour_preview'):
            return

        parts = []
        p = self._get_pronouns()

        # Helper to format treatment name (ot -> OT, social_work -> social work)
        def format_treatment(name):
            if name == "ot":
                return "OT"
            return name.replace('_', ' ')

        # 1. ATTITUDE SECTION - Understanding & Compliance (grouped and ranked)
        if hasattr(self, 'att_treatments'):
            # Collect understanding and compliance by level
            understanding_by_level = {"good": [], "fair": [], "poor": []}
            compliance_by_level = {"full": [], "reasonable": [], "partial": [], "nil": []}
            discrepancies = []

            for name, widgets in self.att_treatments.items():
                und = widgets["understanding"].currentText()
                comp = widgets["compliance"].currentText()
                display_name = format_treatment(name)

                if und:
                    understanding_by_level.get(und, []).append(display_name)
                if comp:
                    compliance_by_level.get(comp, []).append(display_name)

                # Check for discrepancies (poor understanding but good compliance, or vice versa)
                if und and comp:
                    und_rank = {"good": 3, "fair": 2, "poor": 1}.get(und, 0)
                    comp_rank = {"full": 4, "reasonable": 3, "partial": 2, "nil": 1}.get(comp, 0)
                    if und_rank == 1 and comp_rank >= 3:  # poor understanding but reasonable/full compliance
                        discrepancies.append(f"despite only {und} understanding of {display_name} treatment, {p['subj'].lower()} {p['is']} {comp}ly compliant")
                    elif und_rank == 2 and comp_rank >= 4:  # fair understanding but full compliance
                        discrepancies.append(f"despite only {und} understanding of {display_name} treatment, {p['subj'].lower()} {p['is']} fully compliant")
                    elif und_rank >= 2 and comp_rank == 1:  # fair/good understanding but nil compliance
                        discrepancies.append(f"despite {und} understanding of {display_name} treatment, {p['subj'].lower()} {p['is']} not compliant")

            # Build understanding sentence (ranked: good > fair > poor)
            und_parts = []
            for level in ["good", "fair", "poor"]:
                treatments = understanding_by_level.get(level, [])
                if treatments:
                    if len(treatments) > 1:
                        treatment_text = ", ".join(treatments[:-1]) + " and " + treatments[-1]
                    else:
                        treatment_text = treatments[0]
                    und_parts.append(f"{level} for {treatment_text}")

            if und_parts:
                parts.append(f"{p['pos'].capitalize()} understanding of {p['pos'].lower()} treatment needs is {', '.join(und_parts)}.")

            # Build compliance sentence (ranked: full > reasonable > partial > nil)
            # Use 'but' once then 'and' for subsequent levels
            comp_phrases = []
            used_but = False
            for level in ["full", "reasonable", "partial", "nil"]:
                treatments = compliance_by_level.get(level, [])
                if treatments:
                    if len(treatments) > 1:
                        treatment_text = ", ".join(treatments[:-1]) + " and " + treatments[-1]
                    else:
                        treatment_text = treatments[0]
                    if level == "full":
                        phrase = f"fully compliant with {treatment_text}"
                    elif level == "reasonable":
                        phrase = f"reasonably compliant with {treatment_text}"
                    elif level == "partial":
                        phrase = f"only partially compliant with {treatment_text}"
                    elif level == "nil":
                        phrase = f"not compliant with {treatment_text}"

                    if not comp_phrases:
                        comp_phrases.append(phrase)
                    elif not used_but:
                        comp_phrases.append(f"but {phrase}")
                        used_but = True
                    else:
                        comp_phrases.append(f"and {phrase}")

            if comp_phrases:
                # Only use "Nevertheless" if there are discrepancies (understanding < compliance mismatch)
                if discrepancies:
                    parts.append(f"Nevertheless, {p['subj'].lower()} {p['is']} {', '.join(comp_phrases)}.")
                else:
                    parts.append(f"{p['subj'].capitalize()} {p['is']} {', '.join(comp_phrases)}.")

            # Add discrepancies
            if discrepancies:
                parts.append(f"Notably, {'; '.join(discrepancies)}.")

        # Ward rules (expand short values)
        if hasattr(self, 'ward_rules_combo'):
            ward = self.ward_rules_combo.currentText()
            if ward:
                ward_map = {"Mostly": "mostly compliant", "Partial": "partially compliant"}
                ward_text = ward_map.get(ward, ward.lower())
                parts.append(f"{p['subj'].capitalize()} {p['is']} {ward_text} with ward rules.")

        # Response to conflict - specific phrases per option
        if hasattr(self, 'conflict_combo'):
            conflict = self.conflict_combo.currentText().lower()
            if conflict:
                if conflict == "aggressive":
                    verb = "is" if p['subj'].lower() != "they" else "are"
                    parts.append(f"In response to conflict {p['subj'].lower()} {verb} noted to become aggressive.")
                elif conflict == "escalates":
                    parts.append(f"In response to conflict {p['subj'].lower()} can escalate the situation.")
                elif conflict == "neutral":
                    verb = "remains" if p['subj'].lower() != "they" else "remain"
                    parts.append(f"In response to conflict {p['subj'].lower()} {verb} neutral.")
                elif conflict == "de-escalates":
                    verb = "tends" if p['subj'].lower() != "they" else "tend"
                    parts.append(f"{p['subj'].capitalize()} {verb} to de-escalate when there is conflict on the ward.")
                elif conflict == "avoids":
                    verb = "avoids" if p['subj'].lower() != "they" else "avoid"
                    parts.append(f"{p['subj'].capitalize()} actively {verb} situations of conflict on the ward.")

        # 2. RELATIONSHIPS SECTION - group by level, use "but" for transition to lower levels
        if hasattr(self, 'relationship_levels') and hasattr(self, 'rel_level_options'):
            # Get levels with their indices for comparison
            level_order = ["very good", "close", "good", "some", "limited"]
            level_to_idx = {lvl: i for i, lvl in enumerate(level_order)}

            # Group relationship types by level
            level_groups = {}
            for rel_type, level_idx in self.relationship_levels.items():
                level = self.rel_level_options[level_idx].lower()
                if level not in level_groups:
                    level_groups[level] = []
                level_groups[level].append(rel_type)

            # Sort levels by their order (best first)
            sorted_levels = sorted(level_groups.keys(), key=lambda x: level_to_idx.get(x, 5))

            if sorted_levels:
                first_level_idx = level_to_idx.get(sorted_levels[0], 0)
                last_level_idx = level_to_idx.get(sorted_levels[-1], 0)
                has_level_change = len(sorted_levels) > 1

                rel_phrases = []
                for i, level in enumerate(sorted_levels):
                    types = level_groups[level]
                    is_last_level = (i == len(sorted_levels) - 1)

                    # Format the relationship types list
                    if len(types) > 1:
                        types_text = ", ".join(types[:-1]) + " and " + types[-1]
                    else:
                        types_text = types[0]

                    # Build phrase based on level
                    if level in ["some", "limited"]:
                        if len(types) > 1:
                            phrase = f"{level} relationships with {types_text}"
                        else:
                            phrase = f"{level} relationship with {types_text}"
                    else:
                        if len(types) > 1:
                            phrase = f"{level} relationships with {types_text}"
                        else:
                            phrase = f"a {level} relationship with {types_text}"

                    # Use "but" for transition to lower levels
                    if is_last_level and has_level_change:
                        rel_phrases.append(f"but {phrase}")
                    else:
                        rel_phrases.append(phrase)

                parts.append(f"\n{p['subj'].capitalize()} {p['has']} {', '.join(rel_phrases)}.")

        # 3. ATTITUDES TO ENGAGEMENT - OT (new line)
        if hasattr(self, 'eng_ot_checkboxes'):
            ot_selected = [cb.text().lower() for cb in self.eng_ot_checkboxes.values() if cb.isChecked()]
            if ot_selected:
                ot_level = self.eng_ot_options[self.eng_ot_slider.value()].lower() if hasattr(self, 'eng_ot_slider') else "reasonable"
                if len(ot_selected) > 1:
                    ot_text = ", ".join(ot_selected[:-1]) + " and " + ot_selected[-1]
                else:
                    ot_text = ot_selected[0]
                verb = "attend" if p['subj'].lower() == "they" else "attends"
                parts.append(f"\n{p['subj'].capitalize()} {verb} OT groups including {ot_text} with {ot_level} engagement.")

        # Psychology
        if hasattr(self, 'eng_psych_checkboxes'):
            psych_selected = [cb.text().lower() for cb in self.eng_psych_checkboxes.values() if cb.isChecked()]
            if psych_selected:
                psych_level = self.eng_psych_options[self.eng_psych_slider.value()].lower() if hasattr(self, 'eng_psych_slider') else "reasonable"
                if len(psych_selected) > 1:
                    psych_text = ", ".join(psych_selected[:-1]) + " and " + psych_selected[-1]
                else:
                    psych_text = psych_selected[0]
                verb = "engage" if p['subj'].lower() == "they" else "engages"
                parts.append(f"{p['subj'].capitalize()} {verb} in psychology work including {psych_text} with {psych_level} engagement.")

        # 4. BEHAVIOUR SECTION (new paragraph)
        if hasattr(self, 'behaviour_items'):
            yes_items = []
            no_items = []

            for bkey, data in self.behaviour_items.items():
                if data["yes"].isChecked():
                    detail = data["details"].text().strip()
                    if detail:
                        yes_items.append(f"{data['label'].lower()} ({detail})")
                    else:
                        yes_items.append(data["label"].lower())
                elif data["no"].isChecked():
                    no_items.append(data["negative"])

            behaviour_parts = []
            if yes_items:
                if len(yes_items) > 1:
                    items_text = ", ".join(yes_items[:-1]) + " and " + yes_items[-1]
                else:
                    items_text = yes_items[0]
                behaviour_parts.append(f"Regarding behaviours, there have been concerns about {items_text} in the last 12 months.")

            if no_items:
                if len(no_items) > 1:
                    no_text = ", ".join(no_items[:-1]) + " and " + no_items[-1]
                else:
                    no_text = no_items[0]
                if yes_items:
                    behaviour_parts.append(f"However, there has been {no_text}.")
                else:
                    behaviour_parts.append(f"Regarding behaviours, there has been {no_text} in the last 12 months.")

            if behaviour_parts:
                parts.append("\n" + " ".join(behaviour_parts))

        # 5. IMPORTED EVIDENCE - add checked items from imported data
        if hasattr(self, 'att_evidence_checkboxes') and self.att_evidence_checkboxes:
            checked_evidence = []
            for cb, frame, item in self.att_evidence_checkboxes:
                try:
                    if cb.isChecked():
                        evidence_text = item.get("evidence", "").strip()
                        if evidence_text:
                            # Clean up the evidence text (remove ... prefix/suffix)
                            evidence_text = evidence_text.strip('.')
                            if evidence_text.startswith('..'):
                                evidence_text = evidence_text[2:].strip()
                            if evidence_text.endswith('..'):
                                evidence_text = evidence_text[:-2].strip()
                            checked_evidence.append(evidence_text)
                except RuntimeError:
                    # Widget was deleted, skip it
                    continue

            if checked_evidence:
                parts.append("\n\nSupporting evidence: " + "; ".join(checked_evidence))

        if parts:
            text = " ".join(parts).strip()
            self.attitude_behaviour_preview.setText(text)
            # Auto-sync to card - preserve user additions
            if "attitude_behaviour" in self.cards:
                self._update_text_preserving_additions(self.cards["attitude_behaviour"].editor, text, "attitude_behaviour")
        else:
            self.attitude_behaviour_preview.setText("No selections made.")

    def _send_attitude_behaviour_to_card(self):
        """Send the attitude/behaviour preview text to the card."""
        if not hasattr(self, 'attitude_behaviour_preview'):
            return
        text = self.attitude_behaviour_preview.text().strip()
        if not text or text == "No selections made.":
            return
        key = "attitude_behaviour"
        if key in self.cards:
            current = self.cards[key].editor.toPlainText()
            if current:
                self.cards[key].editor.setPlainText(current + "\n\n" + text)
            else:
                self.cards[key].editor.setPlainText(text)

    def _populate_attitude_filtered_data(self, raw_notes: list, categorized_items: list = None):
        """
        Populate 4d Attitude & Behaviour with filtered notes from 1 year before the last entry.
        Also includes categorized items routed from 4c (progress/behaviour/capacity/insight).
        Filters: Mental State, Compliance, Attendance, Admission (same as ASR Section 6).
        Shows first 2 lines + lines containing filter keywords.
        """
        from datetime import datetime, timedelta

        if not raw_notes and not categorized_items:
            print("[MOJ-LEAVE] 4d Attitude: No data available")
            self._populate_attitude_import_entries([])
            return 0

        # Parse date helper
        def parse_note_date(date_val):
            if isinstance(date_val, datetime):
                return date_val
            if not date_val:
                return None
            date_str = str(date_val).strip()
            for fmt in ["%d/%m/%Y", "%Y-%m-%d", "%d-%m-%Y", "%Y/%m/%d", "%d/%m/%Y %H:%M", "%Y-%m-%d %H:%M:%S"]:
                try:
                    return datetime.strptime(date_str.split()[0] if ' ' in date_str else date_str, fmt.split()[0])
                except:
                    pass
            return None

        # Find the most recent note date
        all_dates = []
        if raw_notes:
            for n in raw_notes:
                dt = parse_note_date(n.get("date") or n.get("datetime"))
                if dt:
                    all_dates.append(dt)

        # Also check categorized items for dates
        if categorized_items:
            for item in categorized_items:
                dt = parse_note_date(item.get("date"))
                if dt:
                    all_dates.append(dt)

        if not all_dates:
            # No dates found - if we have categorized items, still process them
            if categorized_items:
                print("[MOJ-LEAVE] 4d Attitude: No parseable dates, but have categorized items")
                most_recent = datetime.now()
                one_year_cutoff = most_recent - timedelta(days=365)
            else:
                print("[MOJ-LEAVE] 4d Attitude: No parseable dates in notes")
                self._populate_attitude_import_entries([])
                return 0
        else:
            most_recent = max(all_dates)
            one_year_cutoff = most_recent - timedelta(days=365)

        print(f"[MOJ-LEAVE] 4d Attitude: Most recent date: {most_recent.strftime('%d/%m/%Y')}")
        print(f"[MOJ-LEAVE] 4d Attitude: 1-year cutoff: {one_year_cutoff.strftime('%d/%m/%Y')}")

        # Keywords for each category (same as ASR Section 6)
        FILTERS = {
            "Mental State": [
                "mental state", "mse", "mood", "affect", "thought", "delusion", "hallucination",
                "psychotic", "psychosis", "depression", "depressed", "anxiety", "anxious",
                "paranoid", "paranoia", "voices", "hearing voices", "suicidal", "self-harm",
                "presentation", "eye contact", "speech", "insight", "agitated", "elated",
                "flat affect", "blunted", "congruent", "incongruent", "thought disorder"
            ],
            "Compliance": [
                "compliant", "compliance", "non-compliant", "medication", "taking medication",
                "refusing medication", "depot", "injection", "oral medication", "tablets",
                "concordant", "concordance", "adherent", "adherence", "treatment plan",
                "accepted", "declined", "refused", "non-concordant", "not taking"
            ],
            "Attendance": [
                "appointment", "attended", "did not attend", "dna", "failed to attend",
                "engagement", "engaged", "engaging", "not engaging", "ward round",
                "review", "session", "meeting", "psychology", "ot session", "group",
                "1:1", "one to one", "1-1", "cpa", "absent", "present", "arrived"
            ]
        }

        def get_matching_categories(text: str) -> list:
            """Return list of categories that match the text."""
            if not text:
                return []
            text_lower = text.lower()
            matched = []
            for cat, keywords in FILTERS.items():
                if any(kw in text_lower for kw in keywords):
                    matched.append(cat)
            return matched

        def extract_relevant_lines(text: str, categories: list) -> str:
            """Extract first 2 lines + lines containing filter keywords."""
            if not text:
                return ""

            lines = text.split('\n')
            lines = [l.strip() for l in lines if l.strip()]

            if not lines:
                return text[:500]

            result_lines = []
            first_two = lines[:2]
            result_lines.extend(first_two)

            all_keywords = []
            for cat in categories:
                all_keywords.extend(FILTERS.get(cat, []))

            for i, line in enumerate(lines[2:], start=2):
                line_lower = line.lower()
                if any(kw in line_lower for kw in all_keywords):
                    if result_lines and i > len(result_lines):
                        if result_lines[-1] != "...":
                            result_lines.append("...")
                    result_lines.append(line)

            return '\n'.join(result_lines)

        # Filter and process notes
        attitude_entries = []
        seen_texts = set()

        for n in raw_notes:
            dt = parse_note_date(n.get("date") or n.get("datetime"))
            if not dt or dt < one_year_cutoff:
                continue

            full_text = (n.get("content") or n.get("text") or n.get("preview") or "").strip()
            if not full_text or full_text in seen_texts:
                continue

            categories = get_matching_categories(full_text)
            if not categories:
                continue

            seen_texts.add(full_text)
            display_text = extract_relevant_lines(full_text, categories)

            attitude_entries.append({
                "text": display_text,
                "full_text": full_text,
                "date": str(n.get("date") or n.get("datetime", "")),
                "categories": categories,
                "sort_date": dt
            })

        # Add categorized items (routed from 4c based on progress/behaviour/capacity/insight keywords)
        if categorized_items:
            for item in categorized_items:
                text = item.get("text", "") or item.get("body", "")
                if text and text not in seen_texts:
                    seen_texts.add(text)
                    dt = parse_note_date(item.get("date"))
                    attitude_entries.append({
                        "text": text,
                        "full_text": text,
                        "date": str(item.get("date", "")),
                        "categories": [item.get("category", "Progress/Behaviour")],
                        "sort_date": dt or datetime.min
                    })
            print(f"[MOJ-LEAVE] 4d Attitude: Added {len(categorized_items)} categorized items")

        # Sort by date (most recent first)
        attitude_entries.sort(key=lambda x: x.get("sort_date", datetime.min), reverse=True)

        # Remove sort_date before passing
        for e in attitude_entries:
            e.pop("sort_date", None)

        print(f"[MOJ-LEAVE] 4d Attitude: Total {len(attitude_entries)} entries")
        self._populate_attitude_import_entries(attitude_entries)
        return len(attitude_entries)

    def _populate_attitude_import_entries(self, entries: list):
        """Populate the 4d attitude imported data panel matching 4a style."""
        self.att_import_checkboxes = []

        if not hasattr(self, 'att_import_entries_layout') or not self.att_import_entries_layout:
            print("[MOJ-LEAVE] 4d Attitude import UI not available - skipping populate")
            return

        # Update subtitle
        if hasattr(self, 'att_import_subtitle') and self.att_import_subtitle:
            if entries:
                self.att_import_subtitle.setText(f"Showing {len(entries)} behaviour entries from last 1 year - tick to include")
            else:
                self.att_import_subtitle.setText("No entries found")

        # Clear existing content
        while self.att_import_entries_layout.count():
            item = self.att_import_entries_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        if not entries:
            placeholder = QLabel("No imported data. Use Import File to upload data.")
            placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 14px; background: transparent; border: none;")
            self.att_import_entries_layout.addWidget(placeholder)
            return

        # Select All / Deselect All buttons
        btn_row = QHBoxLayout()
        btn_row.setSpacing(8)

        select_all_btn = QPushButton("Select All")
        select_all_btn.setStyleSheet("""
            QPushButton { background: rgba(255, 248, 220, 0.95); color: #806000; border: 1px solid rgba(180, 150, 50, 0.4); border-radius: 4px; padding: 6px 14px; font-size: 14px; font-weight: 600; }
            QPushButton:hover { background: #fef3c7; }
        """)
        select_all_btn.clicked.connect(self._select_all_attitude_imports)
        btn_row.addWidget(select_all_btn)

        deselect_all_btn = QPushButton("Deselect All")
        deselect_all_btn.setStyleSheet("""
            QPushButton { background: rgba(255, 248, 220, 0.95); color: #806000; border: 1px solid rgba(180, 150, 50, 0.4); border-radius: 4px; padding: 6px 14px; font-size: 14px; font-weight: 600; }
            QPushButton:hover { background: #fef3c7; }
        """)
        deselect_all_btn.clicked.connect(self._deselect_all_attitude_imports)
        btn_row.addWidget(deselect_all_btn)
        btn_row.addStretch()

        btn_widget = QWidget()
        btn_widget.setStyleSheet("background: transparent; border: none;")
        btn_widget.setLayout(btn_row)
        self.att_import_entries_layout.addWidget(btn_widget)

        # Category tag colors (preserve section-specific labels)
        CATEGORY_COLORS = {
            "Mental State": "#3b82f6",
            "Compliance": "#10b981",
            "Attendance": "#f59e0b",
            "Admission": "#ef4444"
        }

        # Add each entry in 4a style
        for i, entry in enumerate(entries):
            text = entry.get("text", "") or entry.get("content", "")
            date = entry.get("date", "") or entry.get("datetime", "")
            categories = entry.get("categories", [])
            if not text:
                continue

            full_text = entry.get("full_text", text)

            entry_frame = QFrame()
            entry_frame.setObjectName("entryFrame")
            entry_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            entry_frame.setStyleSheet("""
                QFrame#entryFrame {
                    background: rgba(255, 255, 255, 0.95);
                    border: 1px solid rgba(180, 150, 50, 0.4);
                    border-radius: 8px;
                    padding: 4px;
                }
            """)
            entry_layout = QVBoxLayout(entry_frame)
            entry_layout.setContentsMargins(10, 4, 16, 4)
            entry_layout.setSpacing(6)


            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            # Toggle button (left side)
            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("QPushButton { background: rgba(180, 150, 50, 0.2); border: none; border-radius: 4px; font-size: 15px; font-weight: bold; color: #806000; } QPushButton:hover { background: rgba(180, 150, 50, 0.35); }")
            header_row.addWidget(toggle_btn)

            # Date label — before tags
            if date:
                date_label = QLabel(f"\U0001f4c5 {date}")
                date_label.setStyleSheet("font-size: 15px; font-weight: 600; color: #806000; background: transparent; border: none;")
                date_label.setCursor(Qt.CursorShape.PointingHandCursor)
                header_row.addWidget(date_label)

            # Category tags (preserve Behaviour-specific labels) — after date
            for cat in categories:
                tag = QLabel(cat)
                color = CATEGORY_COLORS.get(cat, "#6b7280")
                tag.setStyleSheet(f"QLabel {{ background: {color}; color: white; font-size: 13px; font-weight: 600; padding: 3px 8px; border-radius: 3px; }}")
                header_row.addWidget(tag)

            header_row.addStretch()

            # Checkbox (right side)
            cb = QCheckBox()
            cb.setFixedSize(20, 20)
            cb.setStyleSheet("QCheckBox { background: transparent; margin-right: 4px; } QCheckBox::indicator { width: 18px; height: 18px; }")
            cb.toggled.connect(self._update_attitude_behaviour_preview)
            header_row.addWidget(cb)

            entry_layout.addLayout(header_row)

            # Body text (hidden by default)
            body_text = QTextEdit()
            body_text.setPlainText(full_text)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("QTextEdit { font-size: 15px; color: #333; background: rgba(255, 248, 220, 0.5); border: none; padding: 8px; border-radius: 6px; }")
            body_text.document().setTextWidth(350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            entry_layout.addWidget(body_text)

            def make_toggle(btn, body, frame):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    frame.updateGeometry()
                return toggle
            toggle_fn = make_toggle(toggle_btn, body_text, entry_frame)
            toggle_btn.clicked.connect(toggle_fn)
            if date:
                date_label.mousePressEvent = lambda e, fn=toggle_fn: fn()

            self.att_import_entries_layout.addWidget(entry_frame)
            self.att_import_checkboxes.append({
                "checkbox": cb,
                "text": text,
                "full_text": full_text,
                "date": date,
                "categories": categories,
                "frame": entry_frame
            })

    def _select_all_attitude_imports(self):
        """Select all attitude import checkboxes."""
        if hasattr(self, 'att_import_checkboxes'):
            for entry in self.att_import_checkboxes:
                entry.get("checkbox").setChecked(True)

    def _deselect_all_attitude_imports(self):
        """Deselect all attitude import checkboxes."""
        if hasattr(self, 'att_import_checkboxes'):
            for entry in self.att_import_checkboxes:
                entry.get("checkbox").setChecked(False)

    def _create_risk_factors_popup(self) -> QWidget:
        """Create comprehensive risk factors popup with ASR 9 style risk management."""
        popup = QWidget()
        popup.setStyleSheet("background: white;")
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(6, 6, 6, 6)
        main_layout.setSpacing(6)

        # Hidden label to store text for auto-sync to card
        self.risk_factors_preview = QLabel()
        self.risk_factors_preview.hide()

        # === SCROLLABLE SECTIONS ===
        sections_scroll = QScrollArea()
        sections_scroll.setWidgetResizable(True)
        sections_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        sections_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        sections_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        sections_scroll.setStyleSheet("QScrollArea { background: transparent; border: none; }")

        sections_content = QWidget()
        sections_content.setStyleSheet("background: transparent;")
        sections_content.setSizePolicy(QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Preferred)
        sections_layout = QVBoxLayout(sections_content)
        sections_layout.setContentsMargins(2, 0, 2, 0)
        sections_layout.setSpacing(6)

        # Risk types used across the popup (shortened labels)
        RISK_TYPES = [
            ("violence_others", "Violence to others"),
            ("violence_property", "Violence to property"),
            ("self_harm", "Self-harm"),
            ("suicide", "Suicide"),
            ("self_neglect", "Self-neglect"),
            ("sexual", "Sexual assault/rape"),
            ("exploitation", "Exploitation"),
            ("substance", "Substance"),
            ("stalking", "Stalking"),
            ("vulnerability", "Vulnerability"),
            ("extremism", "Extremism"),
            ("deterioration", "Mental health deterioration"),
            ("non_compliance", "Non-compliance"),
        ]
        self.RISK_TYPES = RISK_TYPES

        # ============================================================
        # SECTION 1: RISK MANAGEMENT (ASR Section 9 style)
        # ============================================================
        risk_header = QHBoxLayout()
        risk_header.setSpacing(4)
        self.risk_mgmt_arrow = QLabel("▾")
        self.risk_mgmt_arrow.setFixedWidth(14)
        self.risk_mgmt_arrow.setStyleSheet("font-size: 14px; color: #dc2626; font-weight: bold;")
        risk_header.addWidget(self.risk_mgmt_arrow)
        risk_header_title = QLabel("<b>Risk Management</b>")
        risk_header_title.setStyleSheet("font-size: 14px; color: #dc2626;")
        risk_header_title.setCursor(Qt.CursorShape.PointingHandCursor)
        risk_header.addWidget(risk_header_title)
        risk_header.addStretch()
        sections_layout.addLayout(risk_header)

        self.risk_mgmt_container = QWidget()
        self.risk_mgmt_container.setObjectName("risk_mgmt_container")
        self.risk_mgmt_container.setStyleSheet("""
            QWidget#risk_mgmt_container { background: #fef2f2; border: 1px solid #fecaca; border-radius: 6px; }
            QLabel { background: transparent; border: none; }
            QCheckBox { background: transparent; border: none; }
        """)

        risk_mgmt_layout = QVBoxLayout(self.risk_mgmt_container)
        risk_mgmt_layout.setContentsMargins(8, 8, 8, 8)
        risk_mgmt_layout.setSpacing(6)

        def toggle_risk_mgmt(event):
            visible = not self.risk_mgmt_container.isVisible()
            self.risk_mgmt_container.setVisible(visible)
            self.risk_mgmt_arrow.setText("▾" if visible else "▸")

        risk_header_title.mousePressEvent = toggle_risk_mgmt
        self.risk_mgmt_arrow.mousePressEvent = toggle_risk_mgmt

        # Split into Current and Historical - vertical stack for narrower layout
        risk_split = QVBoxLayout()
        risk_split.setSpacing(6)

        # Current Risk panel
        current_panel = QFrame()
        current_panel.setStyleSheet("QFrame { background: white; border: 1px solid #fecaca; border-radius: 6px; }")
        current_layout = QVBoxLayout(current_panel)
        current_layout.setContentsMargins(6, 6, 6, 6)
        current_layout.setSpacing(2)

        current_header = QLabel("Current Risk")
        current_header.setStyleSheet("font-size: 14px; font-weight: 700; color: #991b1b; background: #fee2e2; padding: 5px 10px; border-radius: 4px;")
        current_layout.addWidget(current_header)

        # Current risks as grid (2 columns)
        self._current_risk_widgets = {}
        current_grid = QGridLayout()
        current_grid.setSpacing(2)
        for i, (key, label) in enumerate(RISK_TYPES):
            row_widget = self._create_risk_severity_row(key, label, "current")
            current_grid.addWidget(row_widget, i // 2, i % 2)
        current_layout.addLayout(current_grid)
        risk_split.addWidget(current_panel)

        # Historical Risk panel
        hist_panel = QFrame()
        hist_panel.setStyleSheet("QFrame { background: white; border: 1px solid #fcd34d; border-radius: 6px; }")
        hist_layout = QVBoxLayout(hist_panel)
        hist_layout.setContentsMargins(6, 6, 6, 6)
        hist_layout.setSpacing(2)

        hist_header = QLabel("Historical Risk")
        hist_header.setStyleSheet("font-size: 14px; font-weight: 700; color: #92400e; background: #fef3c7; padding: 5px 10px; border-radius: 4px;")
        hist_layout.addWidget(hist_header)

        # Historical risks as grid (2 columns)
        self._historical_risk_widgets = {}
        hist_grid = QGridLayout()
        hist_grid.setSpacing(2)
        for i, (key, label) in enumerate(RISK_TYPES):
            row_widget = self._create_risk_severity_row(key, label, "historical")
            hist_grid.addWidget(row_widget, i // 2, i % 2)
        hist_layout.addLayout(hist_grid)
        risk_split.addWidget(hist_panel)

        risk_mgmt_layout.addLayout(risk_split)
        sections_layout.addWidget(self.risk_mgmt_container)

        # ============================================================
        # SECTION 2: UNDERSTANDING OF RISKS (simplified - radios + single sliders)
        # ============================================================
        und_header = QHBoxLayout()
        und_header.setSpacing(4)
        self.risk_understanding_arrow = QLabel("▾")
        self.risk_understanding_arrow.setFixedWidth(14)
        self.risk_understanding_arrow.setStyleSheet("font-size: 14px; color: #7c3aed; font-weight: bold;")
        und_header.addWidget(self.risk_understanding_arrow)
        und_header_title = QLabel("<b>Understanding of Risks</b>")
        und_header_title.setStyleSheet("font-size: 14px; color: #7c3aed;")
        und_header_title.setCursor(Qt.CursorShape.PointingHandCursor)
        und_header.addWidget(und_header_title)
        und_header.addStretch()
        sections_layout.addLayout(und_header)

        self.risk_understanding_container = QWidget()
        self.risk_understanding_container.setObjectName("risk_understanding_container")
        self.risk_understanding_container.setStyleSheet("""
            QWidget#risk_understanding_container { background: #f5f3ff; border: 1px solid #c4b5fd; border-radius: 6px; }
            QLabel { background: transparent; border: none; }
            QRadioButton { background: transparent; border: none; }
        """)

        und_container_layout = QVBoxLayout(self.risk_understanding_container)
        und_container_layout.setContentsMargins(8, 8, 8, 8)
        und_container_layout.setSpacing(6)

        def toggle_understanding(event):
            visible = not self.risk_understanding_container.isVisible()
            self.risk_understanding_container.setVisible(visible)
            self.risk_understanding_arrow.setText("▾" if visible else "▸")

        und_header_title.mousePressEvent = toggle_understanding
        self.risk_understanding_arrow.mousePressEvent = toggle_understanding

        # Placeholder label when no risks selected
        self.und_placeholder = QLabel("Select risks above to configure understanding")
        self.und_placeholder.setStyleSheet("font-size: 14px; color: #6b7280; font-style: italic;")
        und_container_layout.addWidget(self.und_placeholder)

        # Container for radio buttons (selected risks)
        self.und_radios_widget = QWidget()
        self.und_radios_widget.setStyleSheet("background: transparent;")
        self.und_radios_layout = QGridLayout(self.und_radios_widget)
        self.und_radios_layout.setContentsMargins(0, 0, 0, 0)
        self.und_radios_layout.setSpacing(2)
        und_container_layout.addWidget(self.und_radios_widget)

        # Storage for understanding radio buttons
        self.risk_understanding = {}
        self.und_radio_group = QButtonGroup(popup)
        self.und_radio_group.setExclusive(True)

        # Storage for ALL understanding values (key -> {level, engagement})
        self._understanding_values = {}
        self._current_und_risk_key = None  # Track which risk is currently selected

        # Create radio buttons for each risk type (hidden by default)
        for i, (key, label) in enumerate(RISK_TYPES):
            rb = QRadioButton(label)
            rb.setStyleSheet("font-size: 14px; color: #374151;")
            rb.setVisible(False)
            rb.toggled.connect(lambda checked, k=key: self._on_understanding_radio_changed(k, checked))
            self.und_radio_group.addButton(rb)
            self.und_radios_layout.addWidget(rb, i // 2, i % 2)
            self.risk_understanding[key] = {"radio": rb, "visible": False}

        # Single Understanding slider
        und_slider_row = QHBoxLayout()
        und_slider_row.setSpacing(6)
        und_slider_lbl = QLabel("Understanding:")
        und_slider_lbl.setStyleSheet("font-size: 14px; color: #6b7280;")
        und_slider_row.addWidget(und_slider_lbl)

        slider_style = """
            QSlider::groove:horizontal { height: 4px; background: #e5e7eb; border-radius: 2px; }
            QSlider::handle:horizontal { width: 12px; margin: -4px 0; background: #7c3aed; border-radius: 6px; }
            QSlider::sub-page:horizontal { background: #7c3aed; border-radius: 2px; }
        """
        self.und_level_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.und_level_slider.setMinimum(0)
        self.und_level_slider.setMaximum(2)
        self.und_level_slider.setValue(1)
        self.und_level_slider.setStyleSheet(slider_style)
        self.und_level_slider.valueChanged.connect(self._save_current_understanding)
        self.und_level_slider.valueChanged.connect(self._update_risk_factors_preview)
        und_slider_row.addWidget(self.und_level_slider, 1)

        self.und_level_options = ["Poor", "Fair", "Good"]
        self.und_level_label = QLabel("Fair")
        self.und_level_label.setStyleSheet("font-size: 14px; font-weight: 600; color: #7c3aed; min-width: 55px;")
        self.und_level_slider.valueChanged.connect(lambda v: self.und_level_label.setText(self.und_level_options[v]))
        und_slider_row.addWidget(self.und_level_label)
        und_container_layout.addLayout(und_slider_row)

        # Single Engagement slider
        eng_slider_row = QHBoxLayout()
        eng_slider_row.setSpacing(6)
        eng_slider_lbl = QLabel("Engagement:")
        eng_slider_lbl.setStyleSheet("font-size: 14px; color: #6b7280;")
        eng_slider_row.addWidget(eng_slider_lbl)

        self.und_eng_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.und_eng_slider.setMinimum(0)
        self.und_eng_slider.setMaximum(4)
        self.und_eng_slider.setValue(2)
        self.und_eng_slider.setStyleSheet(slider_style)
        self.und_eng_slider.valueChanged.connect(self._save_current_understanding)
        self.und_eng_slider.valueChanged.connect(self._update_risk_factors_preview)
        eng_slider_row.addWidget(self.und_eng_slider, 1)

        self.und_eng_options = ["None", "Started", "Ongoing", "Advanced", "Complete"]
        self.und_eng_label = QLabel("Ongoing")
        self.und_eng_label.setStyleSheet("font-size: 14px; font-weight: 600; color: #7c3aed; min-width: 70px;")
        self.und_eng_slider.valueChanged.connect(lambda v: self.und_eng_label.setText(self.und_eng_options[v]))
        eng_slider_row.addWidget(self.und_eng_label)
        und_container_layout.addLayout(eng_slider_row)

        sections_layout.addWidget(self.risk_understanding_container)

        # ============================================================
        # SECTION 3: STABILISING / DESTABILISING FACTORS
        # ============================================================
        stab_header = QHBoxLayout()
        stab_header.setSpacing(4)
        self.stabilising_arrow = QLabel("▾")
        self.stabilising_arrow.setFixedWidth(14)
        self.stabilising_arrow.setStyleSheet("font-size: 14px; color: #059669; font-weight: bold;")
        stab_header.addWidget(self.stabilising_arrow)
        stab_header_title = QLabel("<b>Stabilising / Destabilising</b>")
        stab_header_title.setStyleSheet("font-size: 14px; color: #059669;")
        stab_header_title.setCursor(Qt.CursorShape.PointingHandCursor)
        stab_header.addWidget(stab_header_title)
        stab_header.addStretch()
        sections_layout.addLayout(stab_header)

        self.stabilising_container = QWidget()
        self.stabilising_container.setObjectName("stabilising_container")
        self.stabilising_container.setStyleSheet("""
            QWidget#stabilising_container { background: #ecfdf5; border: 1px solid #6ee7b7; border-radius: 6px; }
            QLabel { background: transparent; border: none; }
            QRadioButton { background: transparent; border: none; }
            QCheckBox { background: transparent; border: none; }
        """)

        stab_container_layout = QVBoxLayout(self.stabilising_container)
        stab_container_layout.setContentsMargins(8, 8, 8, 8)
        stab_container_layout.setSpacing(4)

        def toggle_stabilising(event):
            visible = not self.stabilising_container.isVisible()
            self.stabilising_container.setVisible(visible)
            self.stabilising_arrow.setText("▾" if visible else "▸")

        stab_header_title.mousePressEvent = toggle_stabilising
        self.stabilising_arrow.mousePressEvent = toggle_stabilising

        # Radio buttons for Stabilising/Destabilising
        radio_row = QHBoxLayout()
        radio_row.setSpacing(12)

        self.stab_radio_group = QButtonGroup(popup)
        self.stabilising_radio = QRadioButton("Stabilising")
        self.stabilising_radio.setStyleSheet("font-size: 14px; font-weight: 600; color: #059669;")
        self.destabilising_radio = QRadioButton("Destabilising")
        self.destabilising_radio.setStyleSheet("font-size: 14px; font-weight: 600; color: #dc2626;")

        self.stab_radio_group.addButton(self.stabilising_radio)
        self.stab_radio_group.addButton(self.destabilising_radio)

        radio_row.addWidget(self.stabilising_radio)
        radio_row.addWidget(self.destabilising_radio)
        radio_row.addStretch()
        stab_container_layout.addLayout(radio_row)

        # Storage for BOTH stabilising and destabilising factors
        self._stabilising_factors = set()
        self._destabilising_factors = set()

        # Factors checkboxes container
        self.stab_factors_container = QWidget()
        self.stab_factors_container.setVisible(False)
        stab_factors_layout = QVBoxLayout(self.stab_factors_container)
        stab_factors_layout.setContentsMargins(0, 4, 0, 0)
        stab_factors_layout.setSpacing(2)

        # Factor definitions with stabilising/destabilising text (shortened labels)
        self.STAB_FACTORS = [
            ("substance", "no substance misuse", "substance misuse"),
            ("relationships", "strong relationships", "poor relationships"),
            ("family", "no family stress", "family stress"),
            ("compliance", "medication compliance", "medication non-compliance"),
            ("physical", "good physical health", "poor physical health"),
            ("financial", "financial stability", "financial problems"),
            ("mha", "MHA provision in place", "absence of MHA provision"),
            ("cmht", "CMHT engagement", "lack of CMHT engagement"),
            ("accommodation", "supported accommodation", "social stress/housing instability"),
        ]

        self.stab_factors_checkboxes = {}
        factors_grid = QGridLayout()
        factors_grid.setSpacing(2)
        for i, (fkey, stab_text, destab_text) in enumerate(self.STAB_FACTORS):
            cb = QCheckBox(stab_text.capitalize())  # Default to stabilising text
            cb.setStyleSheet("QCheckBox { font-size: 14px; color: #374151; }")
            cb.stateChanged.connect(lambda state, k=fkey: self._on_stab_checkbox_changed(k, state))
            factors_grid.addWidget(cb, i // 2, i % 2)
            self.stab_factors_checkboxes[fkey] = {
                "checkbox": cb,
                "stab_text": stab_text,
                "destab_text": destab_text
            }
        stab_factors_layout.addLayout(factors_grid)

        stab_container_layout.addWidget(self.stab_factors_container)

        # Track previous radio state to detect change
        self._prev_stab_is_stabilising = None

        # Show factors and update labels when radio selected - SAVE/LOAD state
        def on_stab_radio_toggled(checked):
            if not checked:
                return
            is_visible = self.stabilising_radio.isChecked() or self.destabilising_radio.isChecked()
            self.stab_factors_container.setVisible(is_visible)

            is_stabilising = self.stabilising_radio.isChecked()

            # When switching between stabilising/destabilising, save current and load the other
            if self._prev_stab_is_stabilising is not None and self._prev_stab_is_stabilising != is_stabilising:
                # Save current checkbox states to the PREVIOUS storage
                for fkey, data in self.stab_factors_checkboxes.items():
                    if data["checkbox"].isChecked():
                        if self._prev_stab_is_stabilising:
                            self._stabilising_factors.add(data["stab_text"])
                        else:
                            self._destabilising_factors.add(data["destab_text"])

            self._prev_stab_is_stabilising = is_stabilising

            # Update checkbox labels and load saved state for current selection
            for fkey, data in self.stab_factors_checkboxes.items():
                cb = data["checkbox"]
                cb.blockSignals(True)
                if is_stabilising:
                    cb.setText(data["stab_text"].capitalize())
                    cb.setChecked(data["stab_text"] in self._stabilising_factors)
                else:
                    cb.setText(data["destab_text"].capitalize())
                    cb.setChecked(data["destab_text"] in self._destabilising_factors)
                cb.blockSignals(False)

            self._update_risk_factors_preview()

        self.stabilising_radio.toggled.connect(on_stab_radio_toggled)
        self.destabilising_radio.toggled.connect(on_stab_radio_toggled)

        sections_layout.addWidget(self.stabilising_container)

        # ============================================================
        # SECTION 4: IMPORTED DATA (matching 4a style)
        # ============================================================
        import_header = QHBoxLayout()
        import_header.setSpacing(6)
        self.risk_import_arrow = QLabel("▾")
        self.risk_import_arrow.setFixedWidth(16)
        self.risk_import_arrow.setStyleSheet("font-size: 14px; color: #806000; font-weight: bold;")
        import_header.addWidget(self.risk_import_arrow)
        import_header_title = QLabel("<b>Imported Data</b>")
        import_header_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #806000;")
        import_header_title.setCursor(Qt.CursorShape.PointingHandCursor)
        import_header.addWidget(import_header_title)
        import_header.addStretch()
        sections_layout.addLayout(import_header)

        self.risk_import_container = QWidget()
        self.risk_import_container.setObjectName("risk_import_container")
        self.risk_import_container.setStyleSheet("""
            QWidget#risk_import_container {
                background: rgba(255, 248, 220, 0.95);
                border: 1px solid rgba(180, 150, 50, 0.4);
                border-radius: 12px;
            }
            QLabel { background: transparent; border: none; }
            QCheckBox {
                background: transparent;
                border: none;
                padding: 4px;
                font-size: 14px;
                color: #4a4a4a;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
        """)

        import_container_layout = QVBoxLayout(self.risk_import_container)
        import_container_layout.setContentsMargins(12, 10, 12, 10)
        import_container_layout.setSpacing(6)

        def toggle_import(event):
            visible = not self.risk_import_container.isVisible()
            self.risk_import_container.setVisible(visible)
            self.risk_import_arrow.setText("▾" if visible else "▸")

        import_header_title.mousePressEvent = toggle_import
        self.risk_import_arrow.mousePressEvent = toggle_import

        self.risk_import_subtitle = QLabel("Risk-related entries from imported data - tick to include")
        self.risk_import_subtitle.setStyleSheet("font-size: 14px; font-weight: 500; color: #806000; background: transparent; border: none;")
        import_container_layout.addWidget(self.risk_import_subtitle)

        # Category buttons row (clickable labels to filter) - like ASR Section 10
        self.risk_category_buttons_frame = QFrame()
        self.risk_category_buttons_frame.setStyleSheet("QFrame { background: transparent; border: none; }")
        self.risk_category_buttons_frame.setFixedHeight(28)
        self.risk_category_buttons_layout = QHBoxLayout(self.risk_category_buttons_frame)
        self.risk_category_buttons_layout.setContentsMargins(0, 2, 0, 2)
        self.risk_category_buttons_layout.setSpacing(4)
        self.risk_category_buttons_layout.addStretch()
        import_container_layout.addWidget(self.risk_category_buttons_frame)
        self.risk_category_buttons_frame.setVisible(False)  # Hidden until populated

        # Filter bar (shows when filtering is active)
        self.risk_filter_bar = QFrame()
        self.risk_filter_bar.setFixedHeight(28)
        self.risk_filter_bar.setStyleSheet("QFrame { background: rgba(255, 248, 220, 0.95); border: 1px solid rgba(180, 150, 50, 0.4); border-radius: 4px; }")
        risk_filter_layout = QHBoxLayout(self.risk_filter_bar)
        risk_filter_layout.setContentsMargins(8, 0, 8, 0)
        risk_filter_layout.setSpacing(8)
        self.risk_filter_label = QLabel("Filtered by: ")
        self.risk_filter_label.setStyleSheet("font-size: 13px; font-weight: 600; color: #806000; background: transparent;")
        risk_filter_layout.addWidget(self.risk_filter_label)
        risk_filter_layout.addStretch()
        self.risk_remove_filter_btn = QPushButton("Remove filter")
        self.risk_remove_filter_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.risk_remove_filter_btn.setFixedHeight(20)
        self.risk_remove_filter_btn.setStyleSheet("""
            QPushButton { font-size: 13px; color: #dc2626; background: white; border: 1px solid #dc2626; border-radius: 4px; padding: 4px 12px; }
            QPushButton:hover { background: #fef2f2; }
        """)
        self.risk_remove_filter_btn.clicked.connect(self._clear_risk_filter)
        risk_filter_layout.addWidget(self.risk_remove_filter_btn)
        import_container_layout.addWidget(self.risk_filter_bar)
        self.risk_filter_bar.setVisible(False)  # Hidden until filter applied

        # Scrollable entries (resizable)
        self.risk_import_scroll = QScrollArea()
        self.risk_import_scroll.setWidgetResizable(True)
        self.risk_import_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        self.risk_import_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.risk_import_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.risk_import_scroll.setMinimumHeight(60)
        self.risk_import_scroll.setFixedHeight(120)
        self.risk_import_scroll.setStyleSheet("""
            QScrollArea { background: transparent; border: none; }
            QScrollArea > QWidget > QWidget { background: transparent; }
        """)

        self.risk_import_content = QWidget()
        self.risk_import_content.setStyleSheet("background: transparent;")
        self.risk_import_layout = QVBoxLayout(self.risk_import_content)
        self.risk_import_layout.setContentsMargins(2, 2, 2, 2)
        self.risk_import_layout.setSpacing(4)
        self.risk_import_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        self.risk_import_scroll.setWidget(self.risk_import_content)

        placeholder = QLabel("No entries found. Use Import Data to load clinical notes.")
        placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 13px; background: transparent; border: none;")
        self.risk_import_layout.addWidget(placeholder)

        import_container_layout.addWidget(self.risk_import_scroll)

        # Drag bar for resizing imported data
        risk_import_drag = QWidget()
        risk_import_drag.setFixedHeight(8)
        risk_import_drag.setCursor(Qt.CursorShape.SizeVerCursor)
        risk_import_drag.setStyleSheet("QWidget { background: rgba(180, 150, 50, 0.4); border-radius: 4px; margin: 2px 40px; } QWidget:hover { background: #806000; }")
        risk_import_drag._dragging = False
        risk_import_drag._start_y = 0
        risk_import_drag._start_height = 0

        def risk_import_press(event):
            risk_import_drag._dragging = True
            risk_import_drag._start_y = event.globalPosition().y()
            risk_import_drag._start_height = self.risk_import_scroll.height()

        def risk_import_move(event):
            if risk_import_drag._dragging:
                delta = event.globalPosition().y() - risk_import_drag._start_y
                new_height = max(60, min(400, int(risk_import_drag._start_height + delta)))
                self.risk_import_scroll.setFixedHeight(new_height)

        def risk_import_release(event):
            risk_import_drag._dragging = False

        risk_import_drag.mousePressEvent = risk_import_press
        risk_import_drag.mouseMoveEvent = risk_import_move
        risk_import_drag.mouseReleaseEvent = risk_import_release
        import_container_layout.addWidget(risk_import_drag)

        # Button row
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(8)

        select_all_btn = QPushButton("Select All")
        select_all_btn.setStyleSheet("""
            QPushButton { background: rgba(255, 248, 220, 0.95); color: #806000; border: 1px solid rgba(180, 150, 50, 0.4); padding: 6px 14px; border-radius: 4px; font-size: 13px; }
            QPushButton:hover { background: #fef3c7; }
        """)
        select_all_btn.clicked.connect(self._select_all_risk_imports)
        btn_layout.addWidget(select_all_btn)

        deselect_all_btn = QPushButton("Deselect All")
        deselect_all_btn.setStyleSheet("""
            QPushButton { background: rgba(255, 248, 220, 0.95); color: #806000; border: 1px solid rgba(180, 150, 50, 0.4); padding: 6px 14px; border-radius: 4px; font-size: 13px; }
            QPushButton:hover { background: #fef3c7; }
        """)
        deselect_all_btn.clicked.connect(self._deselect_all_risk_imports)
        btn_layout.addWidget(deselect_all_btn)

        btn_layout.addStretch()

        clear_btn = QPushButton("Clear")
        clear_btn.setStyleSheet("""
            QPushButton { background: rgba(255, 248, 220, 0.95); color: #991b1b; border: 1px solid rgba(180, 150, 50, 0.4); padding: 6px 14px; border-radius: 4px; font-size: 13px; }
            QPushButton:hover { background: #fef3c7; }
        """)
        clear_btn.clicked.connect(self._clear_risk_imports)
        btn_layout.addWidget(clear_btn)

        import_container_layout.addLayout(btn_layout)
        sections_layout.addWidget(self.risk_import_container)

        # Add stretch and finish
        sections_layout.addStretch()
        sections_scroll.setWidget(sections_content)
        main_layout.addWidget(sections_scroll, 1)

        # Storage
        self.risk_import_checkboxes = []

        # Populate from stored risk data if available (like ASR Section 10)
        if hasattr(self, '_extracted_risk_items') and self._extracted_risk_items:
            print(f"[MOJ-LEAVE] 4e popup created - populating with {len(self._extracted_risk_items)} stored risk items")
            from PySide6.QtCore import QTimer
            QTimer.singleShot(100, lambda: self._populate_risk_imports(self._extracted_risk_items))

        # Apply stored stabilising/destabilising data now that checkboxes exist
        if hasattr(self, '_extracted_stab_destab') and self._extracted_stab_destab:
            from PySide6.QtCore import QTimer
            QTimer.singleShot(150, self._apply_stab_destab_prefill)

        return popup

    def _create_risk_severity_row(self, key: str, label: str, risk_type: str) -> QWidget:
        """Create a compact risk row with checkbox and severity slider."""
        container = QWidget()
        container.setStyleSheet("background: transparent;")
        container_layout = QVBoxLayout(container)
        container_layout.setContentsMargins(0, 1, 0, 1)
        container_layout.setSpacing(1)

        cb = QCheckBox(label)
        cb.setStyleSheet("font-size: 15px; color: #374151;")
        cb.toggled.connect(self._update_risk_factors_preview)
        cb.toggled.connect(lambda checked, k=key: self._update_understanding_visibility(k, checked))
        container_layout.addWidget(cb)

        # Severity slider (hidden by default)
        slider_widget = QWidget()
        slider_widget.setStyleSheet("background: transparent;")
        slider_layout = QHBoxLayout(slider_widget)
        slider_layout.setContentsMargins(12, 0, 0, 1)
        slider_layout.setSpacing(2)

        slider = NoWheelSlider(Qt.Orientation.Horizontal)
        slider.setMinimum(1)
        slider.setMaximum(3)
        slider.setValue(2)
        slider.setFixedWidth(80)
        slider.valueChanged.connect(self._update_risk_factors_preview)
        slider_layout.addWidget(slider)

        level_lbl = QLabel("Med")
        level_lbl.setStyleSheet("font-size: 15px; color: #374151; font-weight: 500; min-width: 48px;")
        slider.valueChanged.connect(lambda v, l=level_lbl: l.setText(["Low", "Med", "High"][v-1]))
        slider_layout.addWidget(level_lbl)
        slider_layout.addStretch()

        slider_widget.setVisible(False)
        container_layout.addWidget(slider_widget)

        cb.toggled.connect(lambda checked, sw=slider_widget: sw.setVisible(checked))

        # Store widgets
        widgets_dict = self._current_risk_widgets if risk_type == "current" else self._historical_risk_widgets
        widgets_dict[key] = {
            "checkbox": cb,
            "slider": slider,
            "slider_widget": slider_widget,
            "level_label": level_lbl
        }

        # Auto-click historical when current is clicked
        if risk_type == "current":
            def on_current_checked(checked, risk_key=key):
                if checked and hasattr(self, '_historical_risk_widgets'):
                    hist_widgets = self._historical_risk_widgets.get(risk_key, {})
                    hist_cb = hist_widgets.get("checkbox")
                    hist_slider = hist_widgets.get("slider")
                    if hist_cb and not hist_cb.isChecked():
                        hist_cb.setChecked(True)
                        # Set historical to same level as current
                        current_level = slider.value()
                        if hist_slider:
                            hist_slider.setValue(current_level)
            cb.toggled.connect(on_current_checked)

        return container

    def _update_understanding_visibility(self, risk_key: str, checked: bool):
        """Show/hide understanding radio based on risk selection in Current or Historical."""
        if not hasattr(self, 'risk_understanding') or not hasattr(self, '_current_risk_widgets') or not hasattr(self, '_historical_risk_widgets'):
            return

        # Check if this risk is selected in either Current or Historical
        current_checked = self._current_risk_widgets.get(risk_key, {}).get("checkbox")
        historical_checked = self._historical_risk_widgets.get(risk_key, {}).get("checkbox")

        is_selected = (current_checked and current_checked.isChecked()) or (historical_checked and historical_checked.isChecked())

        # Show/hide the understanding radio button
        if risk_key in self.risk_understanding:
            self.risk_understanding[risk_key]["radio"].setVisible(is_selected)
            self.risk_understanding[risk_key]["visible"] = is_selected

            # If this radio was checked and is now hidden, uncheck it
            if not is_selected and self.risk_understanding[risk_key]["radio"].isChecked():
                self.risk_understanding[risk_key]["radio"].setChecked(False)

        # Update placeholder visibility - hide if any radios are visible
        any_visible = any(
            w.get("radio") and w["radio"].isVisible()
            for w in self.risk_understanding.values()
        )
        if hasattr(self, 'und_placeholder'):
            self.und_placeholder.setVisible(not any_visible)

        # Auto-select first visible radio if none selected
        if any_visible:
            any_checked = any(
                w.get("radio") and w["radio"].isChecked()
                for w in self.risk_understanding.values()
            )
            if not any_checked:
                for w in self.risk_understanding.values():
                    if w.get("radio") and w["radio"].isVisible():
                        w["radio"].setChecked(True)
                        break

    def _on_understanding_radio_changed(self, key: str, checked: bool):
        """Handle understanding radio button changes - save/load values."""
        if not checked:
            return

        # Save current values to the previous key before switching
        if self._current_und_risk_key and self._current_und_risk_key != key:
            self._understanding_values[self._current_und_risk_key] = {
                "level": self.und_level_slider.value(),
                "engagement": self.und_eng_slider.value()
            }

        # Load values for the new key (or defaults)
        if key in self._understanding_values:
            values = self._understanding_values[key]
            self.und_level_slider.blockSignals(True)
            self.und_eng_slider.blockSignals(True)
            self.und_level_slider.setValue(values["level"])
            self.und_eng_slider.setValue(values["engagement"])
            self.und_level_label.setText(self.und_level_options[values["level"]])
            self.und_eng_label.setText(self.und_eng_options[values["engagement"]])
            self.und_level_slider.blockSignals(False)
            self.und_eng_slider.blockSignals(False)
        else:
            # Initialize with current slider values for new risk
            self._understanding_values[key] = {
                "level": self.und_level_slider.value(),
                "engagement": self.und_eng_slider.value()
            }

        self._current_und_risk_key = key
        self._update_risk_factors_preview()

    def _save_current_understanding(self):
        """Save current slider values to storage for the selected risk."""
        if self._current_und_risk_key:
            self._understanding_values[self._current_und_risk_key] = {
                "level": self.und_level_slider.value(),
                "engagement": self.und_eng_slider.value()
            }

    def _on_stab_checkbox_changed(self, fkey: str, state: int):
        """Handle stabilising/destabilising checkbox changes - save to storage."""
        data = self.stab_factors_checkboxes.get(fkey, {})
        if not data:
            return

        is_stabilising = self.stabilising_radio.isChecked()
        is_checked = state == 2  # Qt.CheckState.Checked

        if is_stabilising:
            if is_checked:
                self._stabilising_factors.add(data["stab_text"])
            else:
                self._stabilising_factors.discard(data["stab_text"])
        else:
            if is_checked:
                self._destabilising_factors.add(data["destab_text"])
            else:
                self._destabilising_factors.discard(data["destab_text"])

        self._update_risk_factors_preview()

    def _update_risk_factors_preview(self):
        """Update risk factors preview with narrativised text."""
        if not hasattr(self, 'risk_factors_preview'):
            return

        p = self._get_pronouns()
        parts = []

        # Helper to get display label (exploitation -> exploitation of others)
        def get_display_label(key, label):
            if key == "exploitation":
                return "exploitation of others"
            return label.lower()

        # Helper to get risk level from widgets
        def get_risk_level(widgets):
            if widgets.get("checkbox") and widgets["checkbox"].isChecked():
                return ["low", "medium", "high"][widgets["slider"].value() - 1]
            return None

        # Compare current vs historical risks
        improvements = {"low_from_high": [], "low_from_medium": [], "medium_from_high": []}
        deteriorations = {"high_from_low": [], "high_from_medium": [], "medium_from_low": []}
        same_level = {"high": [], "medium": [], "low": []}
        current_only = {"high": [], "medium": [], "low": []}
        historical_only = {"high": [], "medium": [], "low": []}

        for key, label in self.RISK_TYPES:
            display_label = get_display_label(key, label)
            current_level = get_risk_level(self._current_risk_widgets.get(key, {}))
            historical_level = get_risk_level(self._historical_risk_widgets.get(key, {}))

            if current_level and historical_level:
                # Both exist - compare
                if current_level == historical_level:
                    same_level[current_level].append(display_label)
                elif current_level == "low" and historical_level == "high":
                    improvements["low_from_high"].append(display_label)
                elif current_level == "low" and historical_level == "medium":
                    improvements["low_from_medium"].append(display_label)
                elif current_level == "medium" and historical_level == "high":
                    improvements["medium_from_high"].append(display_label)
                elif current_level == "high" and historical_level == "low":
                    deteriorations["high_from_low"].append(display_label)
                elif current_level == "high" and historical_level == "medium":
                    deteriorations["high_from_medium"].append(display_label)
                elif current_level == "medium" and historical_level == "low":
                    deteriorations["medium_from_low"].append(display_label)
            elif current_level:
                current_only[current_level].append(display_label)
            elif historical_level:
                historical_only[historical_level].append(display_label)

        # Helper to join list of items
        def join_items(items):
            if len(items) == 1:
                return items[0]
            elif len(items) == 2:
                return f"{items[0]} and {items[1]}"
            else:
                return ", ".join(items[:-1]) + " and " + items[-1]

        risk_sentences = []

        # Check if all current risks have the same comparison pattern (all improved, all same, etc.)
        all_improvements = improvements["low_from_high"] + improvements["low_from_medium"] + improvements["medium_from_high"]
        all_deteriorations = deteriorations["high_from_low"] + deteriorations["high_from_medium"] + deteriorations["medium_from_low"]
        all_same = same_level["high"] + same_level["medium"] + same_level["low"]

        # Group improvements by current level for cleaner output
        if improvements["low_from_high"]:
            items = join_items(improvements["low_from_high"])
            risk_sentences.append(f"Risks of {items} are currently low which is an improvement from historically where they were high")
        if improvements["low_from_medium"]:
            items = join_items(improvements["low_from_medium"])
            risk_sentences.append(f"risks of {items} are currently low, improved from medium historically")
        if improvements["medium_from_high"]:
            items = join_items(improvements["medium_from_high"])
            risk_sentences.append(f"risks of {items} are currently medium, improved from high historically")

        # Deteriorations
        if deteriorations["high_from_low"]:
            items = join_items(deteriorations["high_from_low"])
            prefix = "However, there has been a deterioration in " if risk_sentences else "There has been a deterioration in "
            risk_sentences.append(f"{prefix}risk of {items} which was low historically and is currently high")
        if deteriorations["high_from_medium"]:
            items = join_items(deteriorations["high_from_medium"])
            prefix = "There has also been a deterioration in " if risk_sentences else "There has been a deterioration in "
            risk_sentences.append(f"{prefix}risk of {items} which was medium historically and is currently high")
        if deteriorations["medium_from_low"]:
            items = join_items(deteriorations["medium_from_low"])
            prefix = "There has been a deterioration in " if not risk_sentences else "Additionally, "
            risk_sentences.append(f"{prefix}risk of {items} which was low historically and is currently medium")

        # Same level
        for level in ["high", "medium", "low"]:
            if same_level[level]:
                items = join_items(same_level[level])
                if len(same_level[level]) == 1:
                    risk_sentences.append(f"The risk of {items} is currently {level} which is the same as historically")
                else:
                    risk_sentences.append(f"The risks of {items} are currently {level} which is the same as historically")

        # Current only (no historical comparison)
        for level in ["high", "medium", "low"]:
            if current_only[level]:
                items = join_items(current_only[level])
                if len(current_only[level]) == 1:
                    risk_sentences.append(f"Current risk of {items} is {level}")
                else:
                    risk_sentences.append(f"Current risks of {items} are {level}")

        # Historical only
        for level in ["high", "medium", "low"]:
            if historical_only[level]:
                items = join_items(historical_only[level])
                if len(historical_only[level]) == 1:
                    risk_sentences.append(f"Historical risk of {items} was {level}")
                else:
                    risk_sentences.append(f"Historical risks of {items} were {level}")

        if risk_sentences:
            parts.append(". ".join(risk_sentences) + ".")

        # Understanding section - prose style, grouped by level (good > fair > poor)
        if hasattr(self, '_understanding_values') and self._understanding_values:
            # Collect entries
            und_entries = []
            for key, values in self._understanding_values.items():
                label = None
                for k, l in self.RISK_TYPES:
                    if k == key:
                        label = get_display_label(key, l)
                        break
                if label:
                    und_entries.append({
                        "label": label,
                        "level": values["level"],
                        "level_text": self.und_level_options[values["level"]].lower(),
                        "engagement": values["engagement"],
                        "engagement_text": self.und_eng_options[values["engagement"]].lower()
                    })

            if und_entries:
                # Group by understanding level
                by_level = {2: [], 1: [], 0: []}  # good=2, fair=1, poor=0
                for entry in und_entries:
                    by_level[entry["level"]].append(entry["label"])

                # Build understanding sentence - group same levels, use 'but' once then 'and'
                und_phrases = []
                used_but = False
                for level in [2, 1, 0]:  # good, fair, poor
                    labels = by_level[level]
                    if not labels:
                        continue
                    level_text = self.und_level_options[level].lower()

                    # Join labels for same level
                    if len(labels) == 1:
                        risk_text = f"{p['pos'].lower()} {labels[0]} risk"
                    elif len(labels) == 2:
                        risk_text = f"{p['pos'].lower()} {labels[0]} and {labels[1]} risk"
                    else:
                        risk_text = f"{p['pos'].lower()} {', '.join(labels[:-1])} and {labels[-1]} risk"

                    if not und_phrases:
                        # First phrase
                        und_phrases.append(f"a {level_text} understanding of {risk_text}")
                    elif not used_but:
                        # First drop - use 'but'
                        und_phrases.append(f"but only a {level_text} understanding of {risk_text}")
                        used_but = True
                    else:
                        # Subsequent - use 'and'
                        und_phrases.append(f"and a {level_text} understanding of {risk_text}")

                if und_phrases:
                    parts.append(f"{p['subj'].capitalize()} {p['has']} {', '.join(und_phrases)}.")

                # Build engagement sentence - group by level
                # (4=complete, 3=advanced, 2=ongoing, 1=started, 0=none)
                eng_by_level = {4: [], 3: [], 2: [], 1: [], 0: []}
                for entry in und_entries:
                    eng_by_level[entry["engagement"]].append(entry["label"])

                eng_sentences = []
                is_first = True

                for level in [4, 3, 2, 1, 0]:
                    labels = eng_by_level[level]
                    if not labels:
                        continue

                    # Join labels for same level
                    if len(labels) == 1:
                        risk_text = labels[0]
                    elif len(labels) == 2:
                        risk_text = f"{labels[0]} and {labels[1]}"
                    else:
                        risk_text = f"{', '.join(labels[:-1])} and {labels[-1]}"

                    if level == 4:  # Complete
                        if is_first:
                            eng_sentences.append(f"{p['subj'].capitalize()} {p['has']} complete engagement in treatment for {risk_text} risk.")
                        else:
                            eng_sentences.append(f"{p['subj'].capitalize()} also {p['has']} complete engagement for {risk_text}.")
                    elif level == 3:  # Advanced
                        if is_first:
                            eng_sentences.append(f"{p['subj'].capitalize()} {p['has']} advanced engagement in treatment for {risk_text} risk.")
                        else:
                            eng_sentences.append(f"There is also advanced engagement for {risk_text}.")
                    elif level == 2:  # Ongoing
                        if is_first:
                            eng_sentences.append(f"{p['subj'].capitalize()} {p['has']} ongoing engagement in treatment for {risk_text} risk.")
                        else:
                            eng_sentences.append(f"There is ongoing engagement for {risk_text}.")
                    elif level == 1:  # Started
                        if is_first:
                            eng_sentences.append(f"{p['subj'].capitalize()} {p['has']} just started treatment for {risk_text} risk.")
                        else:
                            eng_sentences.append(f"{p['subj'].capitalize()} {p['has']} just started treatment for {risk_text}.")
                    elif level == 0:  # None
                        if not is_first:
                            eng_sentences.append(f"Unfortunately, {p['subj'].lower()} {p['is']} not engaging in any work for {p['pos'].lower()} {risk_text}.")
                        else:
                            eng_sentences.append(f"{p['subj'].capitalize()} {p['is']} not engaging in any work for {p['pos'].lower()} {risk_text}.")

                    is_first = False

                if eng_sentences:
                    parts.append(" ".join(eng_sentences))

        # Stabilising AND Destabilising factors - show BOTH from stored values
        # Special phrases for specific factors
        STAB_SPECIAL_PHRASES = {
            "MHA provision in place": f"{p['subj'].capitalize()} would require the mental health act provision to be in place for community stability.",
            "CMHT engagement": f"Engagement and involvement of the mental health team would be a significant stabiliser.",
            "supported accommodation": f"Supported accommodation would be a significant stabiliser.",
        }
        DESTAB_SPECIAL_PHRASES = {
            "absence of MHA provision": f"Absence of mental health act provision has been a destabiliser in the community.",
            "lack of CMHT engagement": f"Lack of engagement with the mental health team has been a significant destabiliser.",
            "social stress/housing instability": f"Social stress and housing instability have been destabilising factors.",
        }

        if hasattr(self, '_stabilising_factors') and self._stabilising_factors:
            special_parts = []
            regular_factors = []
            for factor in sorted(self._stabilising_factors):
                if factor in STAB_SPECIAL_PHRASES:
                    special_parts.append(STAB_SPECIAL_PHRASES[factor])
                else:
                    regular_factors.append(factor)
            if regular_factors:
                parts.append(f"Stabilising factors include {', '.join(regular_factors)}.")
            parts.extend(special_parts)

        if hasattr(self, '_destabilising_factors') and self._destabilising_factors:
            special_parts = []
            regular_factors = []
            for factor in sorted(self._destabilising_factors):
                if factor in DESTAB_SPECIAL_PHRASES:
                    special_parts.append(DESTAB_SPECIAL_PHRASES[factor])
                else:
                    regular_factors.append(factor)
            if regular_factors:
                parts.append(f"Destabilising factors include {', '.join(regular_factors)}.")
            parts.extend(special_parts)

        # Imported data (kept separate from main paragraph)
        imported_text = ""
        if hasattr(self, 'risk_import_checkboxes'):
            selected_imports = []
            for entry in self.risk_import_checkboxes:
                if entry.get("checkbox") and entry["checkbox"].isChecked():
                    text = entry.get("text", "").strip()
                    if text:
                        selected_imports.append(text)

            if selected_imports:
                imported_text = "\n\nImported notes:\n" + "\n".join(f"• {t}" for t in selected_imports[:5])

        # Join main parts as one paragraph, then add imported data separately
        main_text = " ".join(parts) if parts else ""
        text = main_text + imported_text
        self.risk_factors_preview.setText(text)
        # Auto-sync to card - preserve user additions
        if "risk_factors" in self.cards and text:
            self._update_text_preserving_additions(self.cards["risk_factors"].editor, text, "risk_factors")

    def _send_risk_factors_to_card(self):
        """Send risk factors preview to card (replaces existing content)."""
        if not hasattr(self, 'risk_factors_preview'):
            return

        text = self.risk_factors_preview.text().strip()
        if not text:
            return

        key = "risk_factors"
        if key in self.cards:
            self.cards[key].editor.setPlainText(text)

    def _select_all_risk_imports(self):
        """Select all risk import checkboxes."""
        if hasattr(self, 'risk_import_checkboxes'):
            for entry in self.risk_import_checkboxes:
                if entry.get("checkbox"):
                    entry["checkbox"].setChecked(True)

    def _deselect_all_risk_imports(self):
        """Deselect all risk import checkboxes."""
        if hasattr(self, 'risk_import_checkboxes'):
            for entry in self.risk_import_checkboxes:
                if entry.get("checkbox"):
                    entry["checkbox"].setChecked(False)

    def _clear_risk_imports(self):
        """Clear all risk imports."""
        self.risk_import_checkboxes = []

        if not hasattr(self, 'risk_import_layout') or not self.risk_import_layout:
            return

        while self.risk_import_layout.count():
            item = self.risk_import_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        placeholder = QLabel("No entries found. Use Import Data to load clinical notes.")
        placeholder.setStyleSheet("color: #9ca3af; font-style: italic; font-size: 14px; background: transparent; border: none;")
        self.risk_import_layout.addWidget(placeholder)

        self._update_risk_factors_preview()

        # Hide filter bar and category buttons on clear
        if hasattr(self, 'risk_filter_bar'):
            self.risk_filter_bar.setVisible(False)
        if hasattr(self, 'risk_category_buttons_frame'):
            self.risk_category_buttons_frame.setVisible(False)

    def _apply_risk_filter(self, category: str, color: str = "#6b7280"):
        """Apply category filter to risk imports - shows only entries matching the category."""
        if not hasattr(self, 'risk_import_checkboxes'):
            return

        self._risk_current_filter = category

        # Show/hide entries based on filter
        visible_count = 0
        for entry in self.risk_import_checkboxes:
            matches = category in entry.get("categories", [])
            entry["frame"].setVisible(matches)
            if matches:
                visible_count += 1

        # Update filter bar
        if hasattr(self, 'risk_filter_bar') and hasattr(self, 'risk_filter_label'):
            self.risk_filter_label.setText(f"Filtered by: {category} ({visible_count})")
            self.risk_filter_label.setStyleSheet(f"font-size: 14px; font-weight: 600; color: {color}; background: transparent;")
            self.risk_filter_bar.setVisible(True)

        print(f"[MOJ-LEAVE] 4e Risk: Filtered to '{category}' - {visible_count} entries visible")

    def _clear_risk_filter(self):
        """Remove category filter - show all risk entries."""
        if not hasattr(self, 'risk_import_checkboxes'):
            return

        self._risk_current_filter = None

        # Show all entries
        for entry in self.risk_import_checkboxes:
            entry["frame"].setVisible(True)

        # Hide filter bar
        if hasattr(self, 'risk_filter_bar'):
            self.risk_filter_bar.setVisible(False)

        print("[MOJ-LEAVE] 4e Risk: Filter cleared - all entries visible")

    def _populate_risk_imports(self, entries: list):
        """Populate 4e risk import section with categorized risk entries (like ASR Section 10)."""
        from datetime import datetime, timedelta
        import re

        print(f"[MOJ-LEAVE] 4e Risk: _populate_risk_imports called with {len(entries) if entries else 0} entries")

        if not hasattr(self, 'risk_import_layout') or not self.risk_import_layout:
            print("[MOJ-LEAVE] 4e Risk: risk_import_layout not available")
            self._extracted_risk_items = entries  # Store for later
            return

        # Clear existing entries
        while self.risk_import_layout.count():
            item = self.risk_import_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self.risk_import_checkboxes = []

        if not entries:
            placeholder = QLabel("No risk-related entries found in imported data.")
            placeholder.setStyleSheet("color: #9ca3af; font-style: italic; font-size: 14px; background: transparent; border: none;")
            self.risk_import_layout.addWidget(placeholder)
            return

        # Risk category keywords (matching ASR Section 10)
        # Use word boundaries and specific phrases to avoid false positives
        RISK_CATEGORIES = {
            "Violence": [r"\bviolent\b", r"\bviolence\b", r"\baggressive\b", r"\baggression\b",
                        r"\bassaulted\b", r"\bassault\b", r"\battacked\b", r"\bpunched\b", r"\bweapon\b"],
            "Self-harm": [r"self-harm", r"self harm", r"self-harming", r"cutting behaviour",
                         r"self-injur", r"\boverdose\b", r"\bligature\b"],
            "Suicide": [r"\bsuicid", r"end my life", r"end his life", r"end her life",
                       r"kill myself", r"kill himself", r"want to die"],
            "Self-neglect": [r"self-neglect", r"self neglect", r"poor hygiene", r"poor self-care",
                            r"not eating properly", r"refusing food", r"significant weight loss"],
            "Sexual": [r"sexual assault", r"sexual offence", r"sex offence", r"sex offender",
                      r"\braped\b", r"\braping\b", r"indecent assault", r"indecent exposure",
                      r"inappropriate sexual", r"sexually assaulted"],
            "Exploitation": [r"being exploited", r"was exploited", r"vulnerable to exploitation",
                            r"taken advantage of", r"\bcuckooing\b", r"county lines"],
            "Substance": [r"substance misuse", r"substance abuse", r"drug misuse", r"drug abuse",
                         r"\bcannabis\b", r"\bcocaine\b", r"\bheroin\b", r"\bspice\b",
                         r"intoxicated", r"alcohol misuse"],
            "Stalking": [r"\bstalked\b", r"\bstalking\b", r"\bharassed\b", r"\bharassment\b",
                        r"followed.*victim", r"obsessive behaviour", r"unwanted contact"],
            "Deterioration": [r"mental state.*deteriorat", r"deteriorating mental", r"\brelapse\b",
                             r"worsening mental", r"\bdecompens", r"psychotic symptoms", r"experiencing psychosis"],
            "Non-compliance": [r"non-complia", r"not compliant", r"refused medication",
                              r"refusing medication", r"disengag", r"not engaging", r"poor engagement"],
            "Absconding": [r"\babscond", r"\bawol\b", r"absent without leave", r"went missing", r"absconding risk"],
        }

        CATEGORY_COLORS = {
            "Violence": "#dc2626", "Self-harm": "#ea580c", "Suicide": "#7c3aed",
            "Self-neglect": "#0891b2", "Sexual": "#be185d", "Exploitation": "#d946ef",
            "Substance": "#059669", "Stalking": "#6366f1", "Deterioration": "#d97706",
            "Non-compliance": "#4f46e5", "Absconding": "#0d9488",
        }

        # Parse entries and filter to 12 months
        parsed_entries = []
        latest_date = None

        for entry in entries:
            text = entry.get("text", "") or entry.get("content", "") or entry.get("body", "")
            date_val = entry.get("date") or entry.get("datetime")
            if not text:
                continue

            entry_date = None
            if isinstance(date_val, datetime):
                entry_date = date_val
            elif isinstance(date_val, str) and date_val:
                for fmt in ["%Y-%m-%d", "%d/%m/%Y", "%d-%m-%Y", "%Y-%m-%d %H:%M:%S"]:
                    try:
                        entry_date = datetime.strptime(date_val.split()[0] if ' ' in date_val else date_val, fmt)
                        break
                    except:
                        pass

            parsed_entries.append({"text": text, "date": date_val, "date_obj": entry_date})
            if entry_date and (latest_date is None or entry_date > latest_date):
                latest_date = entry_date

        # Filter to 12-month window
        cutoff_date = (latest_date or datetime.now()) - timedelta(days=365)
        filtered_entries = [e for e in parsed_entries if e.get("date_obj") is None or e["date_obj"] >= cutoff_date]

        if not filtered_entries:
            placeholder = QLabel("No risk entries from the last 12 months.")
            placeholder.setStyleSheet("color: #9ca3af; font-style: italic; font-size: 14px;")
            self.risk_import_layout.addWidget(placeholder)
            return

        # Helper functions for highlighting
        def hex_to_light_bg(hex_color):
            """Convert hex color to a lighter background-friendly version."""
            hex_color = hex_color.lstrip('#')
            r, g, b = int(hex_color[0:2], 16), int(hex_color[2:4], 16), int(hex_color[4:6], 16)
            r = int(r * 0.3 + 255 * 0.7)
            g = int(g * 0.3 + 255 * 0.7)
            b = int(b * 0.3 + 255 * 0.7)
            return f"#{r:02x}{g:02x}{b:02x}"

        def highlight_keywords(text, matched_categories):
            """Highlight keywords in text with category colors."""
            import html
            escaped = html.escape(text)

            # Build keyword -> color mapping
            keyword_colors = {}
            for cat in matched_categories:
                color = CATEGORY_COLORS.get(cat, "#6b7280")
                light_color = hex_to_light_bg(color)
                for kw in RISK_CATEGORIES.get(cat, []):
                    keyword_colors[kw] = light_color

            # Sort by length (longest first) to avoid partial replacements
            sorted_keywords = sorted(keyword_colors.keys(), key=len, reverse=True)

            # Highlight each keyword
            for kw in sorted_keywords:
                light_color = keyword_colors[kw]
                pattern = re.compile(re.escape(kw), re.IGNORECASE)
                escaped = pattern.sub(
                    lambda m: f'<span style="background-color: {light_color}; font-weight: 600;">{m.group()}</span>',
                    escaped
                )

            escaped = escaped.replace('\n', '<br>')
            return escaped

        # Track current filter
        self._risk_current_filter = None

        def filter_by_category(cat):
            """Toggle filter by category - uses the new filter methods."""
            color = CATEGORY_COLORS.get(cat, "#6b7280")
            if hasattr(self, '_risk_current_filter') and self._risk_current_filter == cat:
                self._clear_risk_filter()
            else:
                self._apply_risk_filter(cat, color)

        # Negation patterns that indicate risk is NOT present
        NEGATION_PATTERNS = [
            r'no\s+(?:incidents?\s+of\s+)?',
            r'no\s+evidence\s+of\s+',
            r'nil\s+',
            r'not\s+(?:any\s+)?',
            r'without\s+(?:any\s+)?',
            r'absence\s+of\s+',
            r'denies\s+(?:any\s+)?',
            r'has\s+not\s+(?:shown\s+|exhibited\s+|displayed\s+|presented\s+with\s+)?(?:any\s+)?',
            r'there\s+(?:have\s+been\s+|has\s+been\s+|were\s+|was\s+)?no\s+',
            r'never\s+(?:any\s+)?',
        ]

        def is_negated_context(text_lower, keyword):
            """Check if keyword appears in a negation context (e.g., 'no self-harm')."""
            # Find all occurrences of the keyword
            import re
            for match in re.finditer(re.escape(keyword), text_lower):
                start_pos = match.start()
                # Get 50 chars before the keyword to check for negation
                context_start = max(0, start_pos - 50)
                context_before = text_lower[context_start:start_pos]

                # Check if any negation pattern appears just before the keyword
                for neg_pattern in NEGATION_PATTERNS:
                    if re.search(neg_pattern + r'.*$', context_before):
                        return True
            return False

        # Categorize and display entries
        for entry in filtered_entries:
            text = entry["text"]
            text_lower = text.lower()

            # Find matching categories and keywords (excluding negated mentions)
            matched_cats = []
            matched_keywords = []
            for cat, keywords in RISK_CATEGORIES.items():
                for kw in keywords:
                    if kw in text_lower:
                        # Check if this keyword is in a negation context
                        if is_negated_context(text_lower, kw):
                            print(f"[MOJ-LEAVE] 4e: Skipping '{kw}' for {cat} - negated context")
                            continue
                        if cat not in matched_cats:
                            matched_cats.append(cat)
                        matched_keywords.append(kw)

            if not matched_cats:
                matched_cats = ["Other"]

            # Create entry widget (4A style - white rounded container)
            frame = QFrame()
            frame.setObjectName("entryFrame")
            frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            frame.setStyleSheet("""
                QFrame#entryFrame {
                    background: rgba(255, 255, 255, 0.95);
                    border: 1px solid rgba(180, 150, 50, 0.4);
                    border-radius: 8px;
                    padding: 4px;
                }
            """)
            frame_layout = QVBoxLayout(frame)
            frame_layout.setContentsMargins(10, 4, 16, 4)
            frame_layout.setSpacing(6)


            # Header row: toggle_btn → date → category tags → stretch → checkbox
            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            # Toggle button (left side)
            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(180, 150, 50, 0.2);
                    border: none;
                    border-radius: 4px;
                    font-size: 15px;
                    font-weight: bold;
                    color: #806000;
                }
                QPushButton:hover { background: rgba(180, 150, 50, 0.35); }
            """)
            header_row.addWidget(toggle_btn)

            # Date label (amber) — before tags
            date_str = str(entry.get("date", ""))[:10] if entry.get("date") else ""
            if date_str:
                date_label = QLabel(f"\U0001f4c5 {date_str}")
                date_label.setStyleSheet("""
                    QLabel {
                        font-size: 15px; font-weight: 600; color: #806000;
                        background: transparent; border: none;
                    }
                """)
                date_label.setCursor(Qt.CursorShape.PointingHandCursor)
                header_row.addWidget(date_label)

            # Category tags (clickable) — after date
            for cat in matched_cats:
                color = CATEGORY_COLORS.get(cat, "#6b7280")
                tag = QPushButton(cat)
                tag.setCursor(Qt.CursorShape.PointingHandCursor)
                tag.setStyleSheet(f"""
                    QPushButton {{
                        font-size: 14px; font-weight: 600; color: white;
                        background: {color}; padding: 3px 8px; border-radius: 3px; border: none;
                    }}
                    QPushButton:hover {{ background: {color}; opacity: 0.8; }}
                """)
                tag.clicked.connect(lambda checked, c=cat: filter_by_category(c))
                header_row.addWidget(tag)

            header_row.addStretch()

            # Checkbox (right side, with margin)
            cb = QCheckBox()
            cb.setFixedSize(20, 20)
            cb.setStyleSheet("""
                QCheckBox { background: transparent; margin-right: 4px; }
                QCheckBox::indicator { width: 18px; height: 18px; }
            """)
            cb.toggled.connect(self._update_risk_factors_preview)
            header_row.addWidget(cb)

            frame_layout.addLayout(header_row)

            # Body text (hidden by default, with keyword highlighting)
            full_highlighted = highlight_keywords(text, matched_cats)
            body_text = QTextEdit()
            body_text.setHtml(full_highlighted)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("""
                QTextEdit {
                    font-size: 15px;
                    color: #333;
                    background: rgba(255, 248, 220, 0.5);
                    border: none;
                    padding: 8px;
                    border-radius: 6px;
                }
            """)
            body_text.document().setTextWidth(body_text.viewport().width() if body_text.viewport().width() > 0 else 350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            frame_layout.addWidget(body_text)

            # Toggle function
            def make_toggle(btn, body, f, popup_self):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    f.updateGeometry()
                return toggle

            toggle_fn = make_toggle(toggle_btn, body_text, frame, self)
            toggle_btn.clicked.connect(toggle_fn)
            if date_str:
                date_label.mousePressEvent = lambda e, fn=toggle_fn: fn()

            self.risk_import_layout.addWidget(frame)
            self.risk_import_checkboxes.append({"checkbox": cb, "text": text, "categories": matched_cats, "frame": frame})

        print(f"[MOJ-LEAVE] 4e Risk: Added {len(self.risk_import_checkboxes)} risk entries")

        # Show container and update subtitle
        if hasattr(self, 'risk_import_container'):
            self.risk_import_container.setVisible(True)
        if hasattr(self, 'risk_import_arrow'):
            self.risk_import_arrow.setText("▾")
        if hasattr(self, 'risk_import_subtitle'):
            self.risk_import_subtitle.setText(f"Risk-related entries ({len(self.risk_import_checkboxes)} found) - tick to include")

        # Populate category buttons header with counts (like ASR Section 10)
        if hasattr(self, 'risk_category_buttons_layout'):
            # Clear existing buttons
            while self.risk_category_buttons_layout.count():
                item = self.risk_category_buttons_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()

            # Count categories
            category_counts = {}
            for entry in self.risk_import_checkboxes:
                for cat in entry.get("categories", []):
                    if cat != "Other":
                        category_counts[cat] = category_counts.get(cat, 0) + 1

            if category_counts:
                # Add "Found:" label
                found_lbl = QLabel("Found:")
                found_lbl.setStyleSheet("font-size: 14px; font-weight: 600; color: #92400e; background: transparent;")
                self.risk_category_buttons_layout.addWidget(found_lbl)

                # Add category buttons sorted alphabetically
                for cat in sorted(category_counts.keys()):
                    color = CATEGORY_COLORS.get(cat, "#6b7280")
                    count = category_counts[cat]
                    btn = QPushButton(f"{cat} ({count})")
                    btn.setCursor(Qt.CursorShape.PointingHandCursor)
                    btn.setStyleSheet(f"""
                        QPushButton {{
                            font-size: 14px; font-weight: 600; color: white;
                            background: {color}; padding: 4px 10px; border-radius: 4px; border: none;
                        }}
                        QPushButton:hover {{ opacity: 0.8; }}
                    """)
                    btn.clicked.connect(lambda checked, c=cat, clr=color: self._apply_risk_filter(c, clr))
                    self.risk_category_buttons_layout.addWidget(btn)

                self.risk_category_buttons_layout.addStretch()
                self.risk_category_buttons_frame.setVisible(True)
            else:
                self.risk_category_buttons_frame.setVisible(False)

        # Store category colors for filter bar
        self._risk_category_colors = CATEGORY_COLORS

        # ============================================================
        # PREFILL CURRENT AND HISTORICAL RISKS FROM IMPORTED DATA
        # ============================================================
        # Map risk keywords to risk widget keys
        # IMPORTANT: Use \b word boundaries to avoid false positives
        # Use specific contextual phrases rather than single words
        RISK_KEYWORD_MAP = {
            "violence_others": {
                "positive": [
                    r"\bviolent\b", r"\bviolence\b", r"\baggressive\b", r"\baggression\b",
                    r"\bassaulted\b", r"\bassault\b", r"\battacked\b", r"\battack\b",
                    r"\bpunched\b", r"\bpunching\b", r"\bkicked\b", r"\bkicking\b",
                    r"\bweapon\b", r"\bknife\b", r"\bstabbed\b", r"\bstabbing\b",
                    r"physically aggressive", r"acts of violence", r"violent behaviour",
                    r"he hit", r"she hit", r"they hit", r"struck.*victim",
                ],
                "negative": [
                    r"no violence", r"no aggression", r"not violent", r"non-violent",
                    r"no incidents of violence", r"nil violence", r"no assault",
                    r"no physical aggression", r"not presented with any violence",
                ],
            },
            "violence_property": {
                "positive": [
                    r"damage to property", r"criminal damage", r"damaged property",
                    r"smashed.*window", r"broke.*window", r"broken.*window",
                    r"\bfire.?setting\b", r"\barson\b", r"\barsonist\b",
                    r"set fire to", r"started.*fire", r"destroyed.*property",
                ],
                "negative": [r"no damage", r"no criminal damage", r"no property damage"],
            },
            "self_harm": {
                "positive": [
                    r"self-harm", r"self harm", r"self-harmed", r"self-harming",
                    r"cut himself", r"cut herself", r"cut themselves", r"cutting behaviour",
                    r"\bligature\b", r"self-injur", r"self injur", r"harmed himself",
                    r"harmed herself", r"deliberately hurt", r"scratched himself",
                ],
                "negative": [
                    r"no self-harm", r"no self harm", r"not self-harming",
                    r"no incidents of self-harm", r"nil self-harm", r"denies self-harm",
                ],
            },
            "suicide": {
                "positive": [
                    r"\bsuicid", r"end my life", r"end his life", r"end her life",
                    r"kill myself", r"kill himself", r"kill herself",
                    r"take my life", r"take his life", r"take her life",
                    r"\boverdose\b", r"overdosed", r"took.*overdose",
                    r"attempted.*hang", r"tried to hang", r"hanging attempt",
                ],
                "negative": [
                    r"no suicid", r"not suicid", r"nil suicid", r"denies suicid",
                    r"no suicidal ideation", r"no thoughts of suicide",
                ],
            },
            "self_neglect": {
                "positive": [
                    r"self-neglect", r"self neglect", r"neglecting himself", r"neglecting herself",
                    r"poor hygiene", r"poor self-care", r"not eating properly",
                    r"refusing food", r"refusing to eat", r"significant weight loss",
                    r"not washing", r"not showering", r"unkempt appearance",
                ],
                "negative": [
                    r"no self-neglect", r"good hygiene", r"eating well",
                    r"good self-care", r"maintaining hygiene", r"well-kempt",
                ],
            },
            "sexual": {
                # Use specific phrases - avoid matching "therapeutic" which contains "rape"
                "positive": [
                    r"\braped\b", r"\braping\b", r"committed rape", r"convicted of rape",
                    r"sexual assault", r"sexually assaulted", r"sexual offence", r"sexual offender",
                    r"indecent assault", r"indecent exposure", r"sexual abuse", r"sexually abused",
                    r"inappropriate sexual", r"sexual misconduct", r"sexual violence",
                    r"touched.*sexually", r"grabbed.*breast", r"groped",
                    r"sex offence", r"sex offender",
                ],
                "negative": [
                    r"no sexual offences", r"no sexual concerns", r"nil sexual",
                    r"no inappropriate sexual", r"no history of sexual offending",
                ],
            },
            "exploitation": {
                "positive": [
                    r"being exploited", r"was exploited", r"exploitation risk",
                    r"vulnerable to exploitation", r"financial exploitation",
                    r"\bcuckooing\b", r"county lines", r"taken advantage of",
                    r"risk of being exploited", r"exploited by others",
                ],
                "negative": [
                    r"no exploitation", r"not vulnerable to exploitation",
                    r"no evidence of exploitation", r"not being exploited",
                ],
            },
            "substance": {
                "positive": [
                    r"substance misuse", r"substance abuse", r"drug misuse", r"drug abuse",
                    r"\bcannabis\b", r"\bcocaine\b", r"\bheroin\b", r"\bamphetamine\b",
                    r"class a drug", r"illicit drug", r"illicit substance",
                    r"intoxicated", r"under.*influence", r"alcohol misuse", r"alcohol abuse",
                    r"drug use", r"using drugs", r"taking drugs", r"positive drug test",
                ],
                "negative": [
                    r"no substance", r"no drug use", r"\babstinent\b", r"drug-free",
                    r"negative drug test", r"clean drug test", r"no illicit",
                ],
            },
            "stalking": {
                # Avoid matching "follow up" or "following appointment"
                "positive": [
                    r"\bstalked\b", r"\bstalking\b", r"\bstalker\b",
                    r"\bharassed\b", r"\bharassing\b", r"\bharassment\b",
                    r"followed.*victim", r"followed.*woman", r"followed.*girl",
                    r"following.*victim", r"obsessive behaviour", r"obsessive contact",
                    r"unwanted contact", r"unwanted attention", r"persistent contact",
                ],
                "negative": [
                    r"no stalking", r"no harassment", r"not stalking",
                    r"no history of stalking", r"no harassing behaviour",
                ],
            },
            "deterioration": {
                # Removed "decline" as too broad - use specific phrases
                "positive": [
                    r"mental state.*deteriorat", r"deteriorating mental", r"deterioration in",
                    r"\brelapse\b", r"\brelapsed\b", r"relapsing", r"signs of relapse",
                    r"\bdecompens", r"becoming unwell", r"worsening mental state",
                    r"psychotic symptoms", r"experiencing psychosis", r"paranoid ideation",
                    r"increased paranoia", r"thought disorder", r"disorganised thinking",
                ],
                "negative": [
                    r"mental.*stable", r"no deteriorat", r"mental state stable",
                    r"\bsettled\b", r"remains stable", r"no signs of relapse",
                    r"no evidence of deterioration",
                ],
            },
            "non_compliance": {
                "positive": [
                    r"non-complia", r"non complia", r"not compliant", r"poor compliance",
                    r"refused medication", r"refusing medication", r"refusing treatment",
                    r"disengag", r"not engaging", r"lack of engagement", r"poor engagement",
                    r"\babscond", r"absconding risk", r"history of absconding",
                    r"failed to attend", r"did not attend", r"non-attendance",
                ],
                "negative": [
                    r"\bcompliant\b", r"good compliance", r"engaging well",
                    r"good engagement", r"attending appointments", r"fully engaged",
                ],
            },
        }

        # Combine all text for analysis
        full_text = "\n".join([e["text"] for e in filtered_entries]).lower()
        print(f"[MOJ-LEAVE] 4e: Analyzing {len(full_text)} chars of text for risk prefill")

        # Split text by section titles to identify current vs historical
        current_section_titles = [
            "current progress", "current mental state", "current presentation",
            "current risk", "recent progress", "progress report", "ward report",
            "since admission", "during this period", "current period"
        ]
        historical_section_titles = [
            "index offence", "forensic history", "previous conviction",
            "offending history", "criminal history", "past history", "background"
        ]

        # Extract current-related text (sections with current titles or recent entries)
        current_text = ""
        historical_text = ""

        # Simple section extraction - look for patterns
        for title in current_section_titles:
            pattern = rf'{title}[:\s]*([^§]+?)(?={"|".join(historical_section_titles)}|\Z)'
            match = re.search(pattern, full_text, re.IGNORECASE | re.DOTALL)
            if match:
                current_text += match.group(1) + " "

        for title in historical_section_titles:
            pattern = rf'{title}[:\s]*([^§]+?)(?=\n\n\d+\.|\Z)'
            match = re.search(pattern, full_text, re.IGNORECASE | re.DOTALL)
            if match:
                historical_text += match.group(1) + " "

        # If no sections found, use full text for current and look for dated historical content
        if not current_text:
            current_text = full_text
        if not historical_text:
            # Look for index offence pattern in full text
            io_match = re.search(r'index\s+offence.*', full_text, re.IGNORECASE | re.DOTALL)
            if io_match:
                historical_text = io_match.group()

        print(f"[MOJ-LEAVE] 4e: Current text: {len(current_text)} chars, Historical text: {len(historical_text)} chars")

        # Track risks with their status
        current_risks = {}  # key -> "low", "medium", "high" or None
        historical_risks = {}  # key -> "low", "medium", "high"

        # Analyze current status
        for risk_key, patterns in RISK_KEYWORD_MAP.items():
            # Check for negative patterns first (indicates LOW current risk)
            has_negative = False
            for neg_pattern in patterns["negative"]:
                if re.search(neg_pattern, current_text):
                    has_negative = True
                    current_risks[risk_key] = "low"
                    print(f"[MOJ-LEAVE] 4e: CURRENT {risk_key} = LOW (matched: '{neg_pattern}')")
                    break

            # Check for positive patterns only if no negative found
            if not has_negative:
                for pos_pattern in patterns["positive"]:
                    # Skip if this pattern appears in a "no X" context
                    neg_context = re.search(rf'no\s+{pos_pattern}|nil\s+{pos_pattern}|not\s+{pos_pattern}', current_text)
                    if neg_context:
                        current_risks[risk_key] = "low"
                        print(f"[MOJ-LEAVE] 4e: CURRENT {risk_key} = LOW (negated context)")
                        break
                    if re.search(pos_pattern, current_text):
                        current_risks[risk_key] = "medium"
                        print(f"[MOJ-LEAVE] 4e: CURRENT {risk_key} = MEDIUM (matched: '{pos_pattern}')")
                        break

        # Analyze historical risks (from index offence / forensic history)
        if historical_text:
            for risk_key, patterns in RISK_KEYWORD_MAP.items():
                # First check for negative patterns in historical text - if negated, skip this risk
                has_negative = False
                for neg_pattern in patterns["negative"]:
                    if re.search(neg_pattern, historical_text):
                        has_negative = True
                        print(f"[MOJ-LEAVE] 4e: HISTORICAL {risk_key} = SKIPPED (negated: '{neg_pattern}')")
                        break

                if has_negative:
                    continue

                for pos_pattern in patterns["positive"]:
                    # Check if this pattern appears in a negation context
                    neg_context = re.search(rf'no\s+(?:incidents?\s+of\s+)?{pos_pattern}|nil\s+{pos_pattern}|not\s+{pos_pattern}|no\s+evidence\s+of\s+{pos_pattern}|there\s+have\s+been\s+no\s+(?:incidents?\s+of\s+)?{pos_pattern}', historical_text)
                    if neg_context:
                        print(f"[MOJ-LEAVE] 4e: HISTORICAL {risk_key} = SKIPPED (negated context for '{pos_pattern}')")
                        break

                    if re.search(pos_pattern, historical_text):
                        # Determine severity based on nature of offence
                        if risk_key == "sexual" and re.search(r'rape|sexual assault', historical_text):
                            historical_risks[risk_key] = "high"
                        elif risk_key == "violence_others" and re.search(r'knife|weapon|punch|stab', historical_text):
                            historical_risks[risk_key] = "high"
                        elif risk_key == "stalking" and re.search(r'follow.*girl|stalk', historical_text):
                            historical_risks[risk_key] = "medium"
                        else:
                            historical_risks[risk_key] = "medium"
                        print(f"[MOJ-LEAVE] 4e: HISTORICAL {risk_key} = {historical_risks[risk_key]} (matched: '{pos_pattern}')")
                        break

        # Apply to current risk widgets (only if found)
        if hasattr(self, '_current_risk_widgets') and self._current_risk_widgets:
            for risk_key, level in current_risks.items():
                if level:  # Only if we found something
                    widgets = self._current_risk_widgets.get(risk_key, {})
                    cb = widgets.get("checkbox")
                    slider = widgets.get("slider")
                    if cb and not cb.isChecked():
                        cb.setChecked(True)
                        if slider and level:
                            level_val = {"low": 1, "medium": 2, "high": 3}.get(level, 2)
                            slider.setValue(level_val)
                        print(f"[MOJ-LEAVE] 4e: Set CURRENT risk {risk_key} = {level}")

        # Apply to historical risk widgets (only if found)
        if hasattr(self, '_historical_risk_widgets') and self._historical_risk_widgets:
            for risk_key, level in historical_risks.items():
                if level:  # Only if we found something
                    widgets = self._historical_risk_widgets.get(risk_key, {})
                    cb = widgets.get("checkbox")
                    slider = widgets.get("slider")
                    if cb and not cb.isChecked():
                        cb.setChecked(True)
                        if slider and level:
                            level_val = {"low": 1, "medium": 2, "high": 3}.get(level, 2)
                            slider.setValue(level_val)
                        print(f"[MOJ-LEAVE] 4e: Set HISTORICAL risk {risk_key} = {level}")

        # Store historical risks for use in 4G Section 3
        self._extracted_historical_risks = historical_risks
        print(f"[MOJ-LEAVE] 4e: Stored {len(historical_risks)} historical risks for 4G: {list(historical_risks.keys())}")

        # Store current risks for use in 4G Section 4 treatment effectiveness
        self._extracted_current_risks = current_risks
        print(f"[MOJ-LEAVE] 4e: Stored {len(current_risks)} current risks for 4G: {list(current_risks.keys())}")

        # Update preview after prefilling
        if hasattr(self, '_update_risk_factors_preview'):
            self._update_risk_factors_preview()

    def _create_medication_popup(self) -> QWidget:
        """Create medication popup with collapsible sections."""
        from CANONICAL_MEDS import MEDICATIONS

        FREQUENCY_OPTIONS = ["OD", "BD", "TDS", "QDS", "Nocte", "PRN", "Weekly", "Fortnightly", "Monthly"]

        popup = QWidget()
        popup.setStyleSheet("background: white;")
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)

        # Store medication entries
        self._med_entries = []

        # Hidden label to store text for auto-sync to card
        self.medication_preview = QLabel()
        self.medication_preview.hide()

        # === CONTENT SECTION ===
        content_layout = main_layout

        # Scrollable area for all content
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        scroll.setStyleSheet("QScrollArea { background: white; border: none; }")

        scroll_content = QWidget()
        scroll_content.setStyleSheet("background: white;")
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setContentsMargins(4, 4, 4, 4)
        scroll_layout.setSpacing(8)
        scroll.setWidget(scroll_content)

        # ============================================================
        # COLLAPSIBLE SECTION 1: CURRENT MEDICATION
        # ============================================================
        med_section_header = QWidget()
        med_section_header.setStyleSheet("background: #f3f4f6; border-radius: 6px;")
        med_header_layout = QHBoxLayout(med_section_header)
        med_header_layout.setContentsMargins(10, 8, 10, 8)

        self.med_section_expand_btn = QPushButton("−")
        self.med_section_expand_btn.setFixedSize(24, 24)
        self.med_section_expand_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.med_section_expand_btn.setStyleSheet("""
            QPushButton {
                font-size: 17px; font-weight: 700; color: #991b1b;
                background: white; border: 1px solid #d1d5db; border-radius: 4px;
            }
            QPushButton:hover { background: #fee2e2; border-color: #991b1b; }
        """)
        med_header_layout.addWidget(self.med_section_expand_btn)

        med_header_label = QLabel("Current Medication")
        med_header_label.setStyleSheet("font-size: 15px; font-weight: 600; color: #374151; background: transparent;")
        med_header_layout.addWidget(med_header_label)
        med_header_layout.addStretch()

        scroll_layout.addWidget(med_section_header)

        # Medication content container (collapsible)
        self.med_section_content = QWidget()
        self.med_section_content.setStyleSheet("background: transparent;")
        med_content_layout = QVBoxLayout(self.med_section_content)
        med_content_layout.setContentsMargins(8, 8, 8, 8)
        med_content_layout.setSpacing(6)

        # Container for medication entries
        self.med_entries_container = QWidget()
        self.med_entries_container.setStyleSheet("background: transparent;")
        self.med_entries_layout = QVBoxLayout(self.med_entries_container)
        self.med_entries_layout.setContentsMargins(0, 0, 0, 0)
        self.med_entries_layout.setSpacing(6)
        med_content_layout.addWidget(self.med_entries_container)

        def add_medication_entry():
            entry_widget = QFrame()
            entry_widget.setStyleSheet("QFrame { background: #fafafa; border: 1px solid #e5e7eb; border-radius: 6px; }")
            entry_layout = QVBoxLayout(entry_widget)
            entry_layout.setContentsMargins(10, 8, 10, 8)
            entry_layout.setSpacing(6)

            # Name row
            name_row = QHBoxLayout()
            name_label = QLabel("Med:")
            name_label.setStyleSheet("font-size: 14px; min-width: 60px; background: transparent;")
            name_combo = QComboBox()
            name_combo.setEditable(True)
            name_combo.addItem("")
            name_combo.addItems(sorted(MEDICATIONS.keys()))
            name_combo.setMinimumWidth(210)
            name_combo.setStyleSheet("QComboBox { background: white; border: 1px solid #d1d5db; border-radius: 4px; padding: 6px 12px; font-size: 14px; }")
            name_row.addWidget(name_label)
            name_row.addWidget(name_combo)
            name_row.addStretch()

            # Remove button
            remove_btn = QPushButton("×")
            remove_btn.setFixedSize(22, 22)
            remove_btn.setStyleSheet("""
                QPushButton { background: #ef4444; color: white; border: none; border-radius: 11px; font-weight: bold; font-size: 16px; }
                QPushButton:hover { background: #dc2626; }
            """)
            name_row.addWidget(remove_btn)
            entry_layout.addLayout(name_row)

            # Dose row
            dose_row = QHBoxLayout()
            dose_label = QLabel("Dose:")
            dose_label.setStyleSheet("font-size: 14px; min-width: 60px; background: transparent;")
            dose_combo = QComboBox()
            dose_combo.setEditable(True)
            dose_combo.setMinimumWidth(130)
            dose_combo.setStyleSheet("QComboBox { background: white; border: 1px solid #d1d5db; border-radius: 4px; padding: 6px 12px; font-size: 14px; }")
            dose_row.addWidget(dose_label)
            dose_row.addWidget(dose_combo)
            dose_row.addStretch()
            entry_layout.addLayout(dose_row)

            # Frequency row
            freq_row = QHBoxLayout()
            freq_label = QLabel("Freq:")
            freq_label.setStyleSheet("font-size: 14px; min-width: 60px; background: transparent;")
            freq_combo = QComboBox()
            freq_combo.addItems(FREQUENCY_OPTIONS)
            freq_combo.setStyleSheet("QComboBox { background: white; border: 1px solid #d1d5db; border-radius: 4px; padding: 6px 12px; font-size: 14px; }")
            freq_row.addWidget(freq_label)
            freq_row.addWidget(freq_combo)
            freq_row.addStretch()
            entry_layout.addLayout(freq_row)

            # BNF label
            bnf_label = QLabel("")
            bnf_label.setStyleSheet("font-size: 13px; color: #666; font-style: italic; background: transparent;")
            entry_layout.addWidget(bnf_label)

            entry_data = {"widget": entry_widget, "name": name_combo, "dose": dose_combo, "freq": freq_combo, "bnf": bnf_label}
            self._med_entries.append(entry_data)

            def on_med_change(med_name):
                if med_name and med_name in MEDICATIONS:
                    info = MEDICATIONS[med_name]
                    allowed = info.get("allowed_strengths", [])
                    dose_combo.clear()
                    if allowed:
                        dose_combo.addItems([f"{s}mg" for s in allowed])
                    bnf_max = info.get("bnf_max", "")
                    bnf_label.setText(f"Max BNF: {bnf_max}" if bnf_max else "")
                else:
                    dose_combo.clear()
                    bnf_label.setText("")
                # Show/hide details container based on whether any medication is entered
                self._check_med_details_visibility()
                self._update_medication_preview()

            def remove_entry():
                if entry_data in self._med_entries:
                    self._med_entries.remove(entry_data)
                entry_widget.deleteLater()
                # Show/hide details container based on whether any medication is entered
                self._check_med_details_visibility()
                self._update_medication_preview()

            name_combo.currentTextChanged.connect(on_med_change)
            dose_combo.currentTextChanged.connect(self._update_medication_preview)
            freq_combo.currentIndexChanged.connect(self._update_medication_preview)
            remove_btn.clicked.connect(remove_entry)

            self.med_entries_layout.addWidget(entry_widget)

        # Add initial entry
        add_medication_entry()

        # Add medication button
        add_med_btn = QPushButton("+ Add Medication")
        add_med_btn.setStyleSheet("""
            QPushButton { background: #e5e7eb; color: #374151; border: none; padding: 10px 18px; border-radius: 4px; font-size: 14px; font-weight: 500; }
            QPushButton:hover { background: #d1d5db; }
        """)
        add_med_btn.clicked.connect(add_medication_entry)
        med_content_layout.addWidget(add_med_btn)

        scroll_layout.addWidget(self.med_section_content)

        # Toggle function for medication section
        def toggle_med_section():
            visible = not self.med_section_content.isVisible()
            self.med_section_content.setVisible(visible)
            self.med_section_expand_btn.setText("−" if visible else "+")

        self.med_section_expand_btn.clicked.connect(toggle_med_section)
        med_section_header.mousePressEvent = lambda e: toggle_med_section()

        # ============================================================
        # CONTAINER FOR EVERYTHING BELOW MEDICATION (hidden until med entered)
        # ============================================================
        self.med_details_container = QWidget()
        self.med_details_container.setStyleSheet("background: transparent;")
        self.med_details_container.setVisible(False)  # Hidden until medication entered
        med_details_layout = QVBoxLayout(self.med_details_container)
        med_details_layout.setContentsMargins(0, 0, 0, 0)
        med_details_layout.setSpacing(8)

        # ============================================================
        # CAPACITY SECTION - Dropdown + MHA/SOAD actions
        # ============================================================
        capacity_header = QLabel("Capacity to Consent to Medication")
        capacity_header.setStyleSheet("font-size: 15px; font-weight: 600; color: #374151; padding-top: 12px; background: transparent;")
        med_details_layout.addWidget(capacity_header)

        # Capacity dropdown row
        cap_row = QHBoxLayout()
        cap_label = QLabel("Capacity:")
        cap_label.setStyleSheet("font-size: 14px; min-width: 100px; background: transparent;")
        cap_row.addWidget(cap_label)

        self.med_capacity_combo = QComboBox()
        self.med_capacity_combo.addItems(["Select...", "Has capacity", "Lacks capacity"])
        self.med_capacity_combo.setStyleSheet("QComboBox { background: white; border: 1px solid #d1d5db; border-radius: 4px; padding: 6px 12px; font-size: 14px; min-width: 160px; }")
        cap_row.addWidget(self.med_capacity_combo)
        cap_row.addStretch()
        med_details_layout.addLayout(cap_row)

        # Actions container (shown when "Lacks capacity" selected)
        self.med_capacity_actions = QWidget()
        self.med_capacity_actions.setStyleSheet("background: transparent;")
        self.med_capacity_actions.setVisible(False)
        actions_layout = QVBoxLayout(self.med_capacity_actions)
        actions_layout.setContentsMargins(20, 8, 0, 8)
        actions_layout.setSpacing(8)

        # MHA paperwork row
        mha_row = QHBoxLayout()
        mha_row.setSpacing(8)
        mha_lbl = QLabel("MHA paperwork in place:")
        mha_lbl.setStyleSheet("font-size: 14px; color: #374151; background: transparent;")
        mha_row.addWidget(mha_lbl)

        self.med_mha_group = QButtonGroup(self)
        self.med_mha_yes = QRadioButton("Yes")
        self.med_mha_no = QRadioButton("No")
        self.med_mha_yes.setStyleSheet("background: transparent;")
        self.med_mha_no.setStyleSheet("background: transparent;")
        self.med_mha_group.addButton(self.med_mha_yes)
        self.med_mha_group.addButton(self.med_mha_no)
        mha_row.addWidget(self.med_mha_yes)
        mha_row.addWidget(self.med_mha_no)
        mha_row.addStretch()
        actions_layout.addLayout(mha_row)

        # SOAD container (shown when MHA = No)
        self.med_soad_container = QWidget()
        self.med_soad_container.setStyleSheet("background: transparent;")
        self.med_soad_container.setVisible(False)
        soad_row = QHBoxLayout(self.med_soad_container)
        soad_row.setContentsMargins(0, 0, 0, 0)
        soad_row.setSpacing(8)

        soad_lbl = QLabel("SOAD requested:")
        soad_lbl.setStyleSheet("font-size: 14px; color: #374151; background: transparent;")
        soad_row.addWidget(soad_lbl)

        self.med_soad_group = QButtonGroup(self)
        self.med_soad_yes = QRadioButton("Yes")
        self.med_soad_no = QRadioButton("No")
        self.med_soad_yes.setStyleSheet("background: transparent;")
        self.med_soad_no.setStyleSheet("background: transparent;")
        self.med_soad_group.addButton(self.med_soad_yes)
        self.med_soad_group.addButton(self.med_soad_no)
        soad_row.addWidget(self.med_soad_yes)
        soad_row.addWidget(self.med_soad_no)
        soad_row.addStretch()
        actions_layout.addWidget(self.med_soad_container)

        med_details_layout.addWidget(self.med_capacity_actions)

        # Connect capacity dropdown
        def on_capacity_changed(idx):
            self.med_capacity_actions.setVisible(idx == 2)  # "Lacks capacity"
            self._update_medication_preview()

        self.med_capacity_combo.currentIndexChanged.connect(on_capacity_changed)

        # Connect MHA radios
        self.med_mha_yes.toggled.connect(lambda checked: self.med_soad_container.setVisible(not checked) if checked else None)
        self.med_mha_no.toggled.connect(lambda checked: self.med_soad_container.setVisible(checked))
        self.med_mha_yes.toggled.connect(self._update_medication_preview)
        self.med_mha_no.toggled.connect(self._update_medication_preview)
        self.med_soad_yes.toggled.connect(self._update_medication_preview)
        self.med_soad_no.toggled.connect(self._update_medication_preview)

        # ============================================================
        # COMPLIANCE/IMPACT/RESPONSE SLIDERS
        # ============================================================
        COMPLIANCE_OPTIONS = ["poor", "minimal", "partial", "good", "very good", "full"]
        IMPACT_OPTIONS = ["nil", "slight", "some", "moderate", "good", "excellent"]

        slider_style = """
            QSlider::groove:horizontal { background: #e5e7eb; height: 6px; border-radius: 3px; }
            QSlider::handle:horizontal { background: #991b1b; width: 14px; margin: -4px 0; border-radius: 7px; }
            QSlider::sub-page:horizontal { background: #991b1b; border-radius: 3px; }
        """

        # Compliance slider
        comp_row = QHBoxLayout()
        comp_label = QLabel("Compliance:")
        comp_label.setStyleSheet("font-size: 14px; min-width: 100px; background: transparent;")
        comp_row.addWidget(comp_label)

        self.med_compliance_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.med_compliance_slider.setMinimum(0)
        self.med_compliance_slider.setMaximum(len(COMPLIANCE_OPTIONS) - 1)
        self.med_compliance_slider.setValue(3)
        self.med_compliance_slider.setStyleSheet(slider_style)
        self.med_compliance_slider.setMinimumWidth(180)
        comp_row.addWidget(self.med_compliance_slider)

        self.med_compliance_label = QLabel(COMPLIANCE_OPTIONS[3])
        self.med_compliance_label.setStyleSheet("font-size: 14px; font-weight: 600; color: #991b1b; min-width: 90px; background: transparent;")
        comp_row.addWidget(self.med_compliance_label)
        comp_row.addStretch()
        med_details_layout.addLayout(comp_row)

        # Impact slider
        impact_row = QHBoxLayout()
        impact_label = QLabel("Impact:")
        impact_label.setStyleSheet("font-size: 14px; min-width: 100px; background: transparent;")
        impact_row.addWidget(impact_label)

        self.med_impact_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.med_impact_slider.setMinimum(0)
        self.med_impact_slider.setMaximum(len(IMPACT_OPTIONS) - 1)
        self.med_impact_slider.setValue(3)
        self.med_impact_slider.setStyleSheet(slider_style)
        self.med_impact_slider.setMinimumWidth(180)
        impact_row.addWidget(self.med_impact_slider)

        self.med_impact_label = QLabel(IMPACT_OPTIONS[3])
        self.med_impact_label.setStyleSheet("font-size: 14px; font-weight: 600; color: #991b1b; min-width: 90px; background: transparent;")
        impact_row.addWidget(self.med_impact_label)
        impact_row.addStretch()
        med_details_layout.addLayout(impact_row)

        # Response slider
        response_row = QHBoxLayout()
        response_label = QLabel("Response:")
        response_label.setStyleSheet("font-size: 14px; min-width: 100px; background: transparent;")
        response_row.addWidget(response_label)

        self.med_response_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.med_response_slider.setMinimum(0)
        self.med_response_slider.setMaximum(len(IMPACT_OPTIONS) - 1)
        self.med_response_slider.setValue(3)
        self.med_response_slider.setStyleSheet(slider_style)
        self.med_response_slider.setMinimumWidth(180)
        response_row.addWidget(self.med_response_slider)

        self.med_response_label = QLabel(IMPACT_OPTIONS[3])
        self.med_response_label.setStyleSheet("font-size: 14px; font-weight: 600; color: #991b1b; min-width: 90px; background: transparent;")
        response_row.addWidget(self.med_response_label)
        response_row.addStretch()
        med_details_layout.addLayout(response_row)

        # Insight slider
        insight_row = QHBoxLayout()
        insight_label = QLabel("Insight:")
        insight_label.setStyleSheet("font-size: 14px; min-width: 100px; background: transparent;")
        insight_row.addWidget(insight_label)

        self.med_insight_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.med_insight_slider.setMinimum(0)
        self.med_insight_slider.setMaximum(len(IMPACT_OPTIONS) - 1)
        self.med_insight_slider.setValue(3)
        self.med_insight_slider.setStyleSheet(slider_style)
        self.med_insight_slider.setMinimumWidth(180)
        insight_row.addWidget(self.med_insight_slider)

        self.med_insight_label = QLabel(IMPACT_OPTIONS[3])
        self.med_insight_label.setStyleSheet("font-size: 14px; font-weight: 600; color: #991b1b; min-width: 90px; background: transparent;")
        insight_row.addWidget(self.med_insight_label)
        insight_row.addStretch()
        med_details_layout.addLayout(insight_row)

        # Store options for preview generation
        self._med_compliance_options = COMPLIANCE_OPTIONS
        self._med_impact_options = IMPACT_OPTIONS

        # Connect slider signals
        def update_compliance_label(val):
            self.med_compliance_label.setText(COMPLIANCE_OPTIONS[val])
            self._update_medication_preview()

        def update_impact_label(val):
            self.med_impact_label.setText(IMPACT_OPTIONS[val])
            self._update_medication_preview()

        def update_response_label(val):
            self.med_response_label.setText(IMPACT_OPTIONS[val])
            self._update_medication_preview()

        def update_insight_label(val):
            self.med_insight_label.setText(IMPACT_OPTIONS[val])
            self._update_medication_preview()

        self.med_compliance_slider.valueChanged.connect(update_compliance_label)
        self.med_impact_slider.valueChanged.connect(update_impact_label)
        self.med_response_slider.valueChanged.connect(update_response_label)
        self.med_insight_slider.valueChanged.connect(update_insight_label)

        # ============================================================
        # COLLAPSIBLE SECTION: IMPORTED DATA (matching 4a style)
        # ============================================================
        import_section_header = QWidget()
        import_section_header.setStyleSheet("background: rgba(255, 248, 220, 0.95); border: 1px solid rgba(180, 150, 50, 0.4); border-radius: 6px; margin-top: 8px;")
        import_header_layout = QHBoxLayout(import_section_header)
        import_header_layout.setContentsMargins(10, 8, 10, 8)

        self.med_import_expand_btn = QPushButton("+")
        self.med_import_expand_btn.setFixedSize(24, 24)
        self.med_import_expand_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.med_import_expand_btn.setStyleSheet("""
            QPushButton {
                font-size: 17px; font-weight: 700; color: #806000;
                background: rgba(255, 248, 220, 0.95); border: 1px solid rgba(180, 150, 50, 0.4); border-radius: 4px;
            }
            QPushButton:hover { background: #fef3c7; border-color: #806000; }
        """)
        import_header_layout.addWidget(self.med_import_expand_btn)

        import_header_label = QLabel("Imported Data")
        import_header_label.setStyleSheet("font-size: 14px; font-weight: 600; color: #806000; background: transparent;")
        import_header_layout.addWidget(import_header_label)
        import_header_layout.addStretch()

        med_details_layout.addWidget(import_section_header)

        # Import content container (collapsible, starts collapsed)
        self.med_import_section_content = QWidget()
        self.med_import_section_content.setStyleSheet("""
            QWidget {
                background: rgba(255, 248, 220, 0.95);
                border: 1px solid rgba(180, 150, 50, 0.4);
                border-top: none;
                border-radius: 0 0 12px 12px;
            }
            QCheckBox {
                background: transparent;
                border: none;
                padding: 4px;
                font-size: 14px;
                color: #4a4a4a;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
        """)
        self.med_import_section_content.setVisible(False)
        import_content_layout = QVBoxLayout(self.med_import_section_content)
        import_content_layout.setContentsMargins(12, 10, 12, 10)
        import_content_layout.setSpacing(6)

        # Scrollable import entries (resizable)
        self.med_import_scroll = QScrollArea()
        self.med_import_scroll.setWidgetResizable(True)
        self.med_import_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        self.med_import_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.med_import_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.med_import_scroll.setMinimumHeight(60)
        self.med_import_scroll.setFixedHeight(120)
        self.med_import_scroll.setStyleSheet("""
            QScrollArea { background: transparent; border: none; }
            QScrollArea > QWidget > QWidget { background: transparent; }
        """)

        self.med_import_container = QWidget()
        self.med_import_container.setStyleSheet("background: transparent;")
        self.med_import_layout = QVBoxLayout(self.med_import_container)
        self.med_import_layout.setContentsMargins(2, 2, 2, 2)
        self.med_import_layout.setSpacing(4)
        self.med_import_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        self.med_import_checkboxes = []
        no_imports_label = QLabel("No imported medication data available")
        no_imports_label.setStyleSheet("font-size: 13px; color: #806000; font-style: italic; background: transparent; border: none;")
        self.med_import_layout.addWidget(no_imports_label)
        self.med_no_imports_label = no_imports_label

        self.med_import_scroll.setWidget(self.med_import_container)
        import_content_layout.addWidget(self.med_import_scroll)

        # Drag bar for resizing imported data
        med_import_drag = QWidget()
        med_import_drag.setFixedHeight(8)
        med_import_drag.setCursor(Qt.CursorShape.SizeVerCursor)
        med_import_drag.setStyleSheet("QWidget { background: rgba(180, 150, 50, 0.4); border-radius: 4px; margin: 2px 40px; } QWidget:hover { background: #806000; }")
        med_import_drag._dragging = False
        med_import_drag._start_y = 0
        med_import_drag._start_height = 0

        def med_import_press(event):
            med_import_drag._dragging = True
            med_import_drag._start_y = event.globalPosition().y()
            med_import_drag._start_height = self.med_import_scroll.height()

        def med_import_move(event):
            if med_import_drag._dragging:
                delta = event.globalPosition().y() - med_import_drag._start_y
                new_height = max(60, min(400, int(med_import_drag._start_height + delta)))
                self.med_import_scroll.setFixedHeight(new_height)

        def med_import_release(event):
            med_import_drag._dragging = False

        med_import_drag.mousePressEvent = med_import_press
        med_import_drag.mouseMoveEvent = med_import_move
        med_import_drag.mouseReleaseEvent = med_import_release
        import_content_layout.addWidget(med_import_drag)

        med_details_layout.addWidget(self.med_import_section_content)

        # Toggle function for import section
        def toggle_import_section():
            visible = not self.med_import_section_content.isVisible()
            self.med_import_section_content.setVisible(visible)
            self.med_import_expand_btn.setText("−" if visible else "+")

        self.med_import_expand_btn.clicked.connect(toggle_import_section)
        import_section_header.mousePressEvent = lambda e: toggle_import_section()

        # Add the med_details_container to scroll_layout (hidden until med entered)
        scroll_layout.addWidget(self.med_details_container)
        scroll_layout.addStretch()
        content_layout.addWidget(scroll, 1)

        # Initial preview update
        self._update_medication_preview()

        # Register popup generator for send to card
        def generate_medication_text():
            return self.medication_preview.text().strip()
        self.popup_generators["medication"] = generate_medication_text

        # Prefill medications from stored extracted data (if available)
        if hasattr(self, '_extracted_document_text') or hasattr(self, '_extracted_raw_notes_for_meds'):
            raw_notes = getattr(self, '_extracted_raw_notes_for_meds', [])
            doc_text = getattr(self, '_extracted_document_text', "")
            if raw_notes or doc_text:
                print(f"[MOJ-LEAVE] 4f: Prefilling medications now that popup is created")
                self._prefill_medications_from_notes(raw_notes, doc_text)

        # Populate medication imports from stored data (if available)
        if hasattr(self, '_extracted_med_import_entries') and self._extracted_med_import_entries:
            from PySide6.QtCore import QTimer
            print(f"[MOJ-LEAVE] 4f popup created - populating imports with {len(self._extracted_med_import_entries)} stored entries")
            QTimer.singleShot(100, lambda: self._populate_medication_import_entries(self._extracted_med_import_entries))

        # Apply default capacity if stored (from data import)
        if hasattr(self, '_default_capacity') and self._default_capacity:
            if hasattr(self, 'med_capacity_combo'):
                idx = self.med_capacity_combo.findText(self._default_capacity)
                if idx >= 0:
                    self.med_capacity_combo.setCurrentIndex(idx)
                    print(f"[MOJ-LEAVE] 4f: Applied stored default capacity '{self._default_capacity}'")

        # Update medication preview with current gender (delayed to ensure UI is ready)
        from PySide6.QtCore import QTimer
        QTimer.singleShot(200, self._update_medication_preview)

        return popup

    def _check_med_details_visibility(self):
        """Show/hide the medication details container based on whether any medication is entered."""
        if not hasattr(self, '_med_entries') or not hasattr(self, 'med_details_container'):
            return

        # Check if any medication name is entered
        has_medication = any(
            entry["name"].currentText().strip()
            for entry in self._med_entries
        )
        self.med_details_container.setVisible(has_medication)

    def _update_medication_preview(self):
        """Update the medication preview text."""
        if not hasattr(self, '_med_entries') or not hasattr(self, 'medication_preview'):
            return

        p = self._get_pronouns()
        parts = []
        med_lines = []

        for entry in self._med_entries:
            name = entry["name"].currentText().strip()
            dose = entry["dose"].currentText().strip()
            freq = entry["freq"].currentText().strip()

            if name:
                # Title case for medication name (not ALL CAPS)
                name = name.title()
                if dose and freq:
                    med_lines.append(f"{name} {dose} {freq}")
                elif dose:
                    med_lines.append(f"{name} {dose}")
                else:
                    med_lines.append(name)

        # Add imported data
        if hasattr(self, 'med_import_checkboxes'):
            for entry in self.med_import_checkboxes:
                if entry.get("checkbox") and entry["checkbox"].isChecked():
                    text = entry.get("text", "").strip()
                    if text:
                        med_lines.append(text)

        if med_lines:
            # Verb conjugation - gender sensitive
            is_verb = "is" if p['subj'].lower() != "they" else "are"
            has_verb = "has" if p['subj'].lower() != "they" else "have"

            parts.append(f"{p['subj']} {is_verb} currently prescribed: " + ", ".join(med_lines) + ".")

            # Add capacity dropdown info with compliance following on
            capacity_compliance_text = ""
            if hasattr(self, 'med_capacity_combo'):
                cap_idx = self.med_capacity_combo.currentIndex()
                if cap_idx == 1:  # Has capacity
                    capacity_compliance_text = f"{p['subj']} {has_verb} capacity to consent to medication"
                elif cap_idx == 2:  # Lacks capacity
                    parts.append(f"{p['subj']} lack{'s' if p['subj'].lower() != 'they' else ''} capacity to consent to medication.")

                    # MHA paperwork info
                    if hasattr(self, 'med_mha_yes') and self.med_mha_yes.isChecked():
                        parts.append("MHA paperwork is in place.")
                    elif hasattr(self, 'med_mha_no') and self.med_mha_no.isChecked():
                        parts.append("MHA paperwork is not in place.")
                        # SOAD info
                        if hasattr(self, 'med_soad_yes') and self.med_soad_yes.isChecked():
                            parts.append("A SOAD has been requested.")
                        elif hasattr(self, 'med_soad_no') and self.med_soad_no.isChecked():
                            parts.append("A SOAD has not been requested.")

            # Add compliance/impact/response sliders info
            if hasattr(self, 'med_compliance_slider') and hasattr(self, '_med_compliance_options'):
                comp_idx = self.med_compliance_slider.value()
                impact_idx = self.med_impact_slider.value()
                response_idx = self.med_response_slider.value()

                # Compliance phrasing (follows on from capacity if present)
                compliance_phrases = {
                    0: f"{is_verb} poorly compliant",
                    1: f"{is_verb} minimally compliant",
                    2: f"{is_verb} partially compliant",
                    3: f"{has_verb} good compliance",
                    4: f"{has_verb} very good compliance",
                    5: f"{has_verb} full compliance"
                }
                compliance_text = compliance_phrases.get(comp_idx, f"{has_verb} compliance")

                # Combine capacity and compliance
                if capacity_compliance_text:
                    parts.append(f"{capacity_compliance_text} and {compliance_text}.")
                else:
                    parts.append(f"{p['subj']} {compliance_text}.")

                # Impact phrasing (with article "a")
                impact_phrases = {
                    0: f"The medication is having no impact on {p['pos'].lower()} mental state currently",
                    1: f"The medication is only having a slight impact on {p['pos'].lower()} mental state",
                    2: f"The medication has some impact on {p['pos'].lower()} mental state",
                    3: f"The medication has a moderate impact on {p['pos'].lower()} mental state",
                    4: f"The medication has a good impact on {p['pos'].lower()} mental state",
                    5: f"The medication has an excellent impact on {p['pos'].lower()} mental state"
                }
                impact_text = impact_phrases.get(impact_idx, f"The medication has an impact on {p['pos'].lower()} mental state")

                # Response phrasing (with article "a", follows on in same sentence)
                response_phrases = {
                    0: "and the response has been limited.",
                    1: "and the response has been slight.",
                    2: f"and {p['subj'].lower()} {has_verb} some response to treatment.",
                    3: f"and {p['subj'].lower()} {has_verb} a moderate response to treatment.",
                    4: f"and {p['subj'].lower()} {has_verb} a good response to treatment.",
                    5: f"and {p['subj'].lower()} {has_verb} an excellent response to treatment."
                }
                response_text = response_phrases.get(response_idx, ".")

                parts.append(f"{impact_text} {response_text}")

                # Insight phrasing (with "Overall," prefix)
                if hasattr(self, 'med_insight_slider'):
                    insight_idx = self.med_insight_slider.value()
                    insight_phrases = {
                        0: "Overall, insight for medication is not present.",
                        1: "Overall, insight for medication is minimal.",
                        2: f"Overall, {p['subj'].lower()} {has_verb} some insight into the need for medication.",
                        3: f"Overall, {p['subj'].lower()} {has_verb} moderate insight into the need for medication.",
                        4: f"Overall, {p['subj'].lower()} {has_verb} good insight into the need for medication.",
                        5: f"Overall, {p['subj'].lower()} {has_verb} excellent insight into the need for medication."
                    }
                    parts.append(insight_phrases.get(insight_idx, ""))

        if parts:
            text = " ".join(parts)
            self.medication_preview.setText(text)
            # Auto-sync to card - preserve user additions
            if "medication" in self.cards:
                self._update_text_preserving_additions(self.cards["medication"].editor, text, "medication")
        else:
            self.medication_preview.setText("")

    def _populate_medication_imports(self, raw_notes: list, categorized_meds: list = None, document_text: str = None):
        """
        Populate 4f Medication imports from categorized data or by searching raw notes.
        If categorized_meds provided, use those. Otherwise search notes for medications.
        Also searches for capacity, compliance, insight, and response keywords.
        Searches document_text for Section 15 (medication understanding/willingness question).
        """
        from datetime import datetime, timedelta
        import re

        entries = []

        # Get document text if not provided
        if document_text is None:
            document_text = getattr(self, '_extracted_document_text', "") or ""

        # Keywords for medication-related categories - ALL MUST BE MEDICATION-SPECIFIC
        # IMPORTANT: Non-compliance patterns MUST be checked BEFORE compliance patterns
        # to avoid "non-compliant" matching "compliant" as a substring
        # ALL terms MUST contain "medication", "med", "treatment" or specific medication context

        # NON-COMPLIANCE patterns - check these FIRST - ALL medication-specific
        NON_COMPLIANCE_PATTERNS = [
            # Non-compliant WITH medication context
            "non-compliant with medication", "non compliant with medication", "noncompliant with medication",
            "non-compliant with his medication", "non-compliant with her medication",
            "non compliant with his medication", "non compliant with her medication",
            "not compliant with medication", "not compliant with his medication", "not compliant with her medication",
            # Non-adherent WITH medication context
            "non-adherent to medication", "non adherent to medication", "nonadherent to medication",
            "non-adherent with medication", "non adherent with medication",
            "not adherent to medication", "not adherent with medication",
            # Poor compliance/adherence WITH medication context
            "poor medication compliance", "poor compliance with medication",
            "poor medication adherence", "poor adherence to medication",
            "variable medication compliance", "sporadic medication compliance",
            "inconsistent medication compliance", "erratic medication compliance",
            "intermittent medication compliance",
            # Refusing/declining medication
            "refusing medication", "refuses medication", "refused medication",
            "refusing his medication", "refusing her medication",
            "refuses his medication", "refuses her medication",
            "refused his medication", "refused her medication",
            "medication refusal", "refusal of medication",
            "declined medication", "declines medication", "declining medication",
            "declined his medication", "declined her medication",
            # Not taking medication
            "not taking medication", "not taking his medication", "not taking her medication",
            "stopped taking medication", "stopped taking his medication", "stopped taking her medication",
            "stopped his medication", "stopped her medication",
            "discontinued medication", "discontinued his medication", "discontinued her medication",
            # Non-concordant WITH medication context
            "non-concordant with medication", "non concordant with medication",
            "nonconcordant with medication", "not concordant with medication",
            # Covert medication administration
            "covert medication", "covertly administered medication", "covert administration of medication",
            # Lacks capacity FOR MEDICATION
            "lacks capacity to consent to medication", "lacks capacity for medication",
            "incapacitous for medication", "does not have capacity to consent to medication",
            "without capacity to consent to medication",
        ]

        # COMPLIANCE patterns - only check if no non-compliance found - ALL medication-specific
        COMPLIANCE_PATTERNS = [
            # Compliant WITH medication context
            "compliant with medication", "compliant with his medication", "compliant with her medication",
            "medication compliant", "is medication compliant",
            # Good/full compliance WITH medication context
            "good medication compliance", "good compliance with medication",
            "full medication compliance", "full compliance with medication",
            "excellent medication compliance", "excellent compliance with medication",
            "consistent medication compliance", "consistent compliance with medication",
            "fully compliant with medication", "fully compliant with his medication", "fully compliant with her medication",
            "remains compliant with medication", "remains compliant with his medication",
            "consistently compliant with medication",
            # Adherent WITH medication context
            "adherent to medication", "adherent with medication",
            "adherent to his medication", "adherent to her medication",
            "good medication adherence", "good adherence to medication",
            "full medication adherence", "full adherence to medication",
            "fully adherent to medication", "fully adherent with medication",
            "remains adherent to medication", "remains adherent with medication",
            "consistently adherent to medication",
            # Taking medication
            "taking his medication", "taking her medication", "taking medication as prescribed",
            "takes his medication", "takes her medication", "takes medication as prescribed",
            "taking medication regularly", "takes medication regularly",
            # Accepts medication
            "accepts medication", "accepts his medication", "accepts her medication",
            "accepting of medication", "accepting of his medication", "accepting of her medication",
            "accepting medication", "accepted medication",
            # Concordant WITH medication context
            "concordant with medication", "concordant with his medication", "concordant with her medication",
            "medication concordant",
            # Willing for medication
            "willing to take medication", "willing to continue medication",
            "willing to take his medication", "willing to take her medication",
            "willing to continue his medication", "willing to continue her medication",
            # Agrees for medication
            "agrees to take medication", "agrees to continue medication",
            "agrees to take his medication", "agrees to take her medication",
            # Capacity FOR MEDICATION
            "has capacity to consent to medication", "capacitous for medication",
            "has capacity for medication consent",
        ]

        MED_CONTEXT_KEYWORDS = {
            "Capacity": [
                # Form references - specific to medication consent
                "form t2", "form t3", "t2 consent", "t3 consent",
                "section 58 consent", "section 62 consent",
                "section 58 medication", "section 62 medication",
                # Capacity specifically for medication
                "capacity to consent to medication", "lacks capacity to consent to medication",
                "has capacity to consent to medication", "consent to medication",
                "incapacitous for medication", "capacitous for medication",
                "capacity for medication", "medication capacity",
                # SOAD - specific to medication
                "soad", "second opinion appointed doctor", "soad visit", "soad review",
                "second opinion for medication",
            ],
            "Non-Compliant": NON_COMPLIANCE_PATTERNS,  # Will be checked FIRST
            "Compliant": COMPLIANCE_PATTERNS,  # Only if no non-compliance found
            "Response": [
                # Response specifically to medication
                "response to medication", "responded to medication", "responding to medication",
                "response to his medication", "response to her medication",
                "medication response", "good medication response", "poor medication response",
                "medication has been effective", "medication is effective",
                "benefit from medication", "benefited from medication", "benefiting from medication",
                "stabilised on medication", "stabilized on medication",
                "stable on medication", "stable on his medication", "stable on her medication",
                "symptom control with medication", "symptoms controlled with medication",
                "well controlled on medication", "well controlled on his medication",
                "mental state improved with medication", "improvement on medication",
                "mental state improved on medication", "improved on medication",
            ],
            "Insight": [
                # Insight specifically into medication
                "insight into medication", "insight into his medication", "insight into her medication",
                "insight into the need for medication", "insight into need for medication",
                "medication insight", "good medication insight", "poor medication insight",
                "lacks medication insight", "lacks insight into medication",
                "lacks insight into his medication", "lacks insight into her medication",
                "no insight into medication", "no insight into his medication",
                # Understanding specifically of medication
                "understanding of medication", "understanding of his medication", "understanding of her medication",
                "understands need for medication", "understands the need for medication",
                "does not understand need for medication",
                # Accepts/denies need for medication
                "accepts need for medication", "accepts the need for medication",
                "recognises need for medication", "recognizes need for medication",
                "denies need for medication", "denies the need for medication",
            ],
        }

        # Date patterns for extracting dates near compliance mentions
        DATE_PATTERNS_FOR_COMPLIANCE = [
            r'\b(\d{1,2})[/\-](\d{1,2})[/\-](\d{2,4})\b',  # dd/mm/yyyy or dd-mm-yyyy
            r'\b(\d{4})[/\-](\d{1,2})[/\-](\d{1,2})\b',    # yyyy/mm/dd or yyyy-mm-dd
            r'\b(\d{1,2})\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+(\d{2,4})\b',  # 15 January 2024
            r'\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+(\d{4})\b',  # January 2024
        ]

        # Special question pattern for capacity/willingness assessment
        CAPACITY_QUESTION = "what is the patient's understanding of, compliance with, and likely future willingness"

        # Track detected willingness level for capacity dropdown
        detected_willingness = None
        detected_has_but = False

        # First try categorized medication entries
        if categorized_meds:
            for item in categorized_meds:
                text = item.get("text", "") or item.get("body", "")
                if text:
                    entries.append({
                        "text": text,
                        "date": str(item.get("date", "")),
                        "source": "Categorized"
                    })
            print(f"[MOJ-LEAVE] 4f Medication: Using {len(entries)} categorized entries")

        seen_texts = set(e.get("text", "")[:100] for e in entries)

        # ============================================================
        # SEARCH DOCUMENT TEXT FOR SECTION 15 (MEDICATION WILLINGNESS)
        # ============================================================
        if document_text:
            doc_lower = document_text.lower()
            print(f"[MOJ-LEAVE] 4f: Searching document text ({len(document_text)} chars) for medication insight")

            # Look for the capacity question in document
            if CAPACITY_QUESTION.lower() in doc_lower:
                q_pos = doc_lower.find(CAPACITY_QUESTION.lower())
                # Get a larger section to capture the full answer
                answer_section = doc_lower[q_pos:q_pos + 1000]

                print(f"[MOJ-LEAVE] 4f: Found Section 15 question at position {q_pos}")

                # Check for NEGATIVE patterns FIRST (to avoid "not willing" matching "willing")
                UNWILLING_PATTERNS = [
                    # Direct refusal
                    "not willing", "unwilling", "refuses to take", "refusing medication",
                    "refused medication", "refuses medication", "will not take", "won't take",
                    "would not take", "wouldn't take", "does not want", "doesn't want",
                    "does not wish", "doesn't wish", "not wanting", "not wishing",
                    # Unhappy/unkeen
                    "not happy to take", "unhappy to take", "not happy about",
                    "unkeen", "not keen", "un-keen", "not keen on",
                    # Reluctance
                    "reluctant to", "reluctance to", "shows reluctance", "expressed reluctance",
                    "demonstrates reluctance", "exhibits reluctance", "displaying reluctance",
                    # Resistance
                    "resistant to", "resists taking", "resisting medication", "resistance to",
                    "opposes taking", "opposed to taking", "against taking", "objects to",
                    "objecting to", "objection to",
                    # Disagreement
                    "not agreeable", "disagrees with", "not in agreement", "disputes the need",
                    "questions the need", "challenges the need", "does not agree",
                    # Non-acceptance
                    "not accepting", "unaccepting", "does not accept", "doesn't accept",
                    "rejects medication", "rejected medication", "rejecting medication",
                    "denies need for", "denies the need",
                    # Declined
                    "declines medication", "declined medication", "declining medication",
                    "has declined", "will decline",
                    # Stopped/ceased
                    "stopped taking", "has stopped", "ceased taking", "has ceased",
                    "discontinued", "has discontinued", "no longer takes", "no longer taking",
                    "no longer willing", "no longer wishes", "no longer wants",
                    # Disbelief
                    "does not believe", "doesn't believe", "not convinced", "unconvinced",
                    "not persuaded", "skeptical", "sceptical", "doubtful about",
                    "dismissive of", "dismisses the need", "sees no need", "sees no benefit",
                    "does not see the need", "doesn't see the need", "fails to see",
                    # Disengagement
                    "not engaged with", "disengaged from", "not committed to", "uncommitted",
                    "not motivated", "lacks motivation", "unmotivated", "poorly motivated",
                    # Disinclination
                    "disinclined to", "not inclined to", "averse to", "aversion to",
                    # Preference against
                    "prefers not to", "would rather not", "would prefer not",
                    "wants to stop", "wishes to stop", "hopes to stop", "plans to stop",
                    "intends to stop", "would like to stop", "wants to discontinue",
                    # Poor compliance indicators
                    "non-compliant", "non compliant", "noncompliant", "not compliant",
                    "non-adherent", "non adherent", "nonadherent", "not adherent",
                    "poor adherence", "poor compliance", "inconsistent with medication",
                    "sporadic compliance", "variable compliance", "erratic compliance",
                    # Unlikely to continue
                    "unlikely to continue", "unlikely to take", "unlikely to comply",
                    "will probably stop", "will likely stop", "expected to stop",
                    "not expected to continue", "not anticipated to continue",
                    # Consent issues
                    "not consenting", "withholds consent", "withdrawn consent",
                    "withdrawing consent", "does not consent", "hasn't consented",
                    # Begrudging/protest
                    "under protest", "only under duress", "begrudging", "grudgingly",
                    "half-hearted", "halfhearted",
                    # Community specific
                    "would not take in community", "would stop in community",
                    "only takes in hospital", "only when supervised",
                ]

                is_unwilling = any(pattern in answer_section for pattern in UNWILLING_PATTERNS)
                if is_unwilling:
                    detected_willingness = "unwilling"
                    # Find which pattern matched for logging
                    matched = next((p for p in UNWILLING_PATTERNS if p in answer_section), "unknown")
                    print(f"[MOJ-LEAVE] 4f: Detected unwillingness ('{matched}') - POOR insight")

                # Check for POSITIVE willingness (only if not already marked as unwilling)
                WILLING_PATTERNS = [
                    # Direct willingness
                    "willing to continue", "willing to take", "willing to accept",
                    "is willing", "he is willing", "she is willing", "they are willing",
                    "remains willing", "continues to be willing",
                    # Happy/keen
                    "happy to take", "happy to continue", "happy with medication",
                    "keen to take", "keen to continue", "keen on medication",
                    # Accepting
                    "accepts medication", "accepts the need", "accepts his medication",
                    "accepts her medication", "accepting of medication", "accepting of his",
                    "accepting of her", "has accepted", "now accepts",
                    # Agreeable
                    "agreeable to", "agrees to take", "agrees to continue",
                    "in agreement", "has agreed", "agreed to take", "agreed to continue",
                    # Compliant
                    "compliant with medication", "compliant with his medication",
                    "compliant with her medication", "good compliance", "full compliance",
                    "fully compliant", "remains compliant", "consistently compliant",
                    # Adherent
                    "adherent to", "adherent with", "good adherence", "excellent adherence",
                    "fully adherent", "remains adherent",
                    # Consenting
                    "consents to", "consenting to", "has consented", "gives consent",
                    "provides consent", "informed consent obtained",
                    # Cooperative
                    "cooperative with", "cooperates with", "cooperating with",
                    "engaged with medication", "engaged with treatment",
                    # Motivated
                    "motivated to take", "motivated to continue", "well motivated",
                    "good motivation", "shows motivation",
                    # Understanding
                    "understands the need", "understands why", "recognises the need",
                    "recognizes the need", "acknowledges the need", "sees the benefit",
                    "appreciates the benefit",
                    # Positive intent
                    "intends to continue", "plans to continue", "will continue",
                    "wants to continue", "wishes to continue",
                    # Commitment
                    "committed to", "committed to taking", "committed to his medication",
                    "committed to her medication",
                    # Reliable
                    "reliably takes", "reliable with", "consistently takes",
                    "takes as prescribed", "taking as prescribed",
                ]

                is_willing = any(pattern in answer_section for pattern in WILLING_PATTERNS)
                if is_willing:
                    detected_willingness = "willing"
                    matched = next((p for p in WILLING_PATTERNS if p in answer_section), "unknown")
                    print(f"[MOJ-LEAVE] 4f: Detected willingness ('{matched}') - checking for reservations...")

                    # Check for "but" or "however" which indicates reservation
                    but_match = re.search(r'willing to (?:take|continue)[^.]*(?:but|however)', answer_section)
                    if but_match:
                        detected_has_but = True
                        print(f"[MOJ-LEAVE] 4f: Detected 'willing but...' pattern - PARTIAL insight")

                    # Check for preference for different medication (indicates partial insight)
                    if "prefer" in answer_section and ("oral" in answer_section or "discontinue" in answer_section or "stop" in answer_section):
                        detected_has_but = True
                        print(f"[MOJ-LEAVE] 4f: Detected preference for different medication - PARTIAL insight")

                    # Check for improvement/acceptance (upgrades to moderate)
                    if "more accepting" in answer_section or "now accepts" in answer_section or "come to accept" in answer_section:
                        if detected_has_but:
                            print(f"[MOJ-LEAVE] 4f: Detected 'more accepting' - upgrading to MODERATE insight")
                            detected_willingness = "moderate"
                        else:
                            print(f"[MOJ-LEAVE] 4f: Detected good acceptance - GOOD insight")

                # Extract the question and answer for display
                # Find the start of the question in original text (preserving case)
                q_start = document_text.lower().find(CAPACITY_QUESTION.lower())
                if q_start >= 0:
                    # Get text from question start, find next section or limit
                    section_text = document_text[q_start:q_start + 1000]
                    # Find end of this section (next numbered question or section marker)
                    next_section = re.search(r'\n\s*\d+[.\)]\s+[A-Z]|\n\s*Section\s+\d+', section_text[100:])
                    if next_section:
                        section_text = section_text[:100 + next_section.start()]

                    display_text = section_text.strip()[:600]
                    if display_text[:100] not in seen_texts:
                        entries.append({
                            "text": display_text,
                            "date": "",
                            "source": "Insight"
                        })
                        seen_texts.add(display_text[:100])
                        print(f"[MOJ-LEAVE] 4f: Added Section 15 content to imports ({len(display_text)} chars)")

        # Helper function to extract dates from text
        def extract_date_from_text(text):
            """Extract date from text near compliance mentions"""
            import re
            from datetime import datetime
            text_lower = text.lower()
            for pattern in DATE_PATTERNS_FOR_COMPLIANCE:
                match = re.search(pattern, text_lower, re.IGNORECASE)
                if match:
                    groups = match.groups()
                    try:
                        if len(groups) == 3:
                            # Check if first group is 4-digit year (yyyy/mm/dd format)
                            if len(groups[0]) == 4:
                                return datetime(int(groups[0]), int(groups[1]), int(groups[2]))
                            # Check if last group is 4-digit year (dd/mm/yyyy format)
                            elif len(groups[2]) == 4:
                                return datetime(int(groups[2]), int(groups[1]), int(groups[0]))
                            # 2-digit year (assume 20xx if < 50, else 19xx)
                            elif len(groups[2]) == 2:
                                year = 2000 + int(groups[2]) if int(groups[2]) < 50 else 1900 + int(groups[2])
                                return datetime(year, int(groups[1]), int(groups[0]))
                            # Month name format
                            else:
                                month_map = {'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4, 'may': 5, 'jun': 6,
                                            'jul': 7, 'aug': 8, 'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12}
                                if groups[1][:3].lower() in month_map:
                                    month = month_map[groups[1][:3].lower()]
                                    year_str = groups[2]
                                    year = int(year_str) if len(year_str) == 4 else (2000 + int(year_str))
                                    return datetime(year, month, int(groups[0]))
                        elif len(groups) == 2:
                            # Month year format (e.g., "January 2024")
                            month_map = {'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4, 'may': 5, 'jun': 6,
                                        'jul': 7, 'aug': 8, 'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12}
                            if groups[0][:3].lower() in month_map:
                                month = month_map[groups[0][:3].lower()]
                                return datetime(int(groups[1]), month, 1)
                    except (ValueError, TypeError):
                        continue
            return None

        def is_recent_date(dt):
            """Check if date is within last 6 months (considered 'current')"""
            if not dt:
                return None  # Unknown
            from datetime import datetime, timedelta
            six_months_ago = datetime.now() - timedelta(days=180)
            return dt >= six_months_ago

        # Track compliance detection for slider prefill
        detected_compliance_status = None  # 'compliant', 'non-compliant', or None
        detected_compliance_date = None
        detected_compliance_is_current = None

        # Search raw notes for capacity/compliance/insight/response keywords
        if raw_notes:
            for n in raw_notes:
                full_text = (n.get("content") or n.get("text") or n.get("preview") or "").strip()
                if not full_text or full_text[:100] in seen_texts:
                    continue

                text_lower = full_text.lower()

                # Skip if already found in document text
                if CAPACITY_QUESTION.lower() in text_lower and detected_willingness:
                    continue

                # Check for medication context keywords
                # IMPORTANT: Check Non-Compliant BEFORE Compliant to avoid substring matching
                matched_category = None

                # FIRST: Check for Non-Compliant patterns
                for kw in NON_COMPLIANCE_PATTERNS:
                    if kw in text_lower:
                        matched_category = "Non-Compliant"
                        print(f"[MOJ-LEAVE] 4f: Found NON-COMPLIANT pattern '{kw}'")
                        break

                # SECOND: Only check Compliant if no non-compliance found
                if not matched_category:
                    for kw in COMPLIANCE_PATTERNS:
                        if kw in text_lower:
                            matched_category = "Compliant"
                            print(f"[MOJ-LEAVE] 4f: Found COMPLIANT pattern '{kw}'")
                            break

                # THIRD: Check other categories if no compliance match
                if not matched_category:
                    for cat, keywords in MED_CONTEXT_KEYWORDS.items():
                        if cat in ("Non-Compliant", "Compliant"):
                            continue  # Already checked above
                        for kw in keywords:
                            if kw in text_lower:
                                matched_category = cat
                                break
                        if matched_category:
                            break

                if matched_category:
                    # Extract date from the note for current vs historical determination
                    note_date = None
                    note_date_str = str(n.get("date") or n.get("datetime", ""))

                    # Try to parse note date
                    if note_date_str:
                        try:
                            for fmt in ["%Y-%m-%d", "%d/%m/%Y", "%d-%m-%Y", "%Y/%m/%d"]:
                                try:
                                    note_date = datetime.strptime(note_date_str.split()[0], fmt)
                                    break
                                except:
                                    pass
                        except:
                            pass

                    # If no note date, try to extract from text
                    if not note_date:
                        note_date = extract_date_from_text(full_text)

                    # Track compliance status with date for slider prefill
                    if matched_category in ("Compliant", "Non-Compliant"):
                        is_current = is_recent_date(note_date)
                        date_status = "current" if is_current else ("historical" if is_current is False else "unknown")
                        print(f"[MOJ-LEAVE] 4f: {matched_category} entry dated {note_date}, status: {date_status}")

                        # Only update detected compliance if this is more recent or we don't have one
                        if detected_compliance_date is None or (note_date and (detected_compliance_date is None or note_date > detected_compliance_date)):
                            detected_compliance_status = "compliant" if matched_category == "Compliant" else "non-compliant"
                            detected_compliance_date = note_date
                            detected_compliance_is_current = is_current

                    # Extract relevant lines around the keyword
                    lines = full_text.split('\n')
                    relevant_lines = []
                    for i, line in enumerate(lines):
                        line_lower = line.lower()
                        # Check if this line contains any of the keywords
                        has_keyword = (
                            any(kw in line_lower for kw in NON_COMPLIANCE_PATTERNS) or
                            any(kw in line_lower for kw in COMPLIANCE_PATTERNS) or
                            any(kw in line_lower for kws in MED_CONTEXT_KEYWORDS.values() for kw in kws if kw not in NON_COMPLIANCE_PATTERNS and kw not in COMPLIANCE_PATTERNS)
                        )
                        if has_keyword:
                            # Include this line and one before/after for context
                            if i > 0 and lines[i-1].strip():
                                relevant_lines.append(lines[i-1].strip())
                            relevant_lines.append(line.strip())
                            if i < len(lines) - 1 and lines[i+1].strip():
                                relevant_lines.append(lines[i+1].strip())

                    if relevant_lines:
                        display_text = '\n'.join(dict.fromkeys(relevant_lines))[:500]  # Dedupe and limit
                        if display_text[:100] not in seen_texts:
                            # Add date status to source for display
                            source_label = matched_category
                            if matched_category in ("Compliant", "Non-Compliant"):
                                is_current = is_recent_date(note_date)
                                if is_current is True:
                                    source_label = f"{matched_category} (Current)"
                                elif is_current is False:
                                    source_label = f"{matched_category} (Historical)"

                            entries.append({
                                "text": display_text,
                                "date": note_date_str,
                                "source": source_label
                            })
                            seen_texts.add(display_text[:100])
                            print(f"[MOJ-LEAVE] 4f Medication: Found {source_label} context in notes")

        # Store compliance detection for slider prefill
        self._detected_compliance_status = detected_compliance_status
        self._detected_compliance_date = detected_compliance_date
        self._detected_compliance_is_current = detected_compliance_is_current
        if detected_compliance_status:
            print(f"[MOJ-LEAVE] 4f: Final compliance detection: {detected_compliance_status}, current={detected_compliance_is_current}")

        # Store willingness detection result for insight level prefill
        self._detected_med_willingness = detected_willingness
        self._detected_med_has_but = detected_has_but

        # ============================================================
        # MEDICATION RESPONSE DETECTION (for 4g Section 4)
        # ============================================================
        # Response levels: 0=nil, 1=slight, 2=some, 3=moderate, 4=good, 5=excellent
        detected_med_response = 3  # Default to moderate

        # Combine document text and raw notes for response detection
        all_text_for_response = (document_text or "").lower()
        if raw_notes:
            for n in raw_notes:
                note_text = (n.get("content") or n.get("text") or n.get("preview") or "").lower()
                all_text_for_response += " " + note_text

        # Response level keywords (check in order from highest to lowest)
        RESPONSE_EXCELLENT = [
            "excellent response to medication", "exceptional response to",
            "excellent medication response", "outstanding response to medication",
            "remarkable response to", "very well controlled on medication",
            "excellent response to his medication", "excellent response to her medication"
        ]
        RESPONSE_GOOD = [
            "good response to medication", "good medication response",
            "responds well to medication", "responded well to medication",
            "responding well to", "well controlled on medication",
            "good response to his medication", "good response to her medication",
            "stable on medication", "stable on his medication", "stable on her medication",
            "stabilised on medication", "stabilized on medication",
            "mental state improved with medication", "significant improvement on medication"
        ]
        RESPONSE_MODERATE = [
            "moderate response to medication", "moderate medication response",
            "reasonable response to", "satisfactory response to",
            "adequately controlled on medication", "adequate response to",
            "some improvement on medication", "partial response to medication"
        ]
        RESPONSE_SOME = [
            "some response to medication", "limited response to medication",
            "limited medication response", "partial response to", "partially controlled",
            "variable response to medication", "inconsistent response to"
        ]
        RESPONSE_SLIGHT = [
            "slight response to medication", "minimal response to medication",
            "minimal medication response", "marginal response to",
            "little response to medication", "poor response to medication",
            "poor medication response", "not responding well"
        ]
        RESPONSE_NIL = [
            "no response to medication", "nil response to medication",
            "not responded to medication", "not responding to medication",
            "medication not effective", "medication has not been effective",
            "refractory to medication", "treatment resistant", "medication resistant"
        ]

        # Check from highest to lowest response level
        if any(kw in all_text_for_response for kw in RESPONSE_EXCELLENT):
            detected_med_response = 5  # Excellent
            print(f"[MOJ-LEAVE] 4f: Medication response = EXCELLENT (5)")
        elif any(kw in all_text_for_response for kw in RESPONSE_GOOD):
            detected_med_response = 4  # Good
            print(f"[MOJ-LEAVE] 4f: Medication response = GOOD (4)")
        elif any(kw in all_text_for_response for kw in RESPONSE_MODERATE):
            detected_med_response = 3  # Moderate
            print(f"[MOJ-LEAVE] 4f: Medication response = MODERATE (3)")
        elif any(kw in all_text_for_response for kw in RESPONSE_SOME):
            detected_med_response = 2  # Some
            print(f"[MOJ-LEAVE] 4f: Medication response = SOME (2)")
        elif any(kw in all_text_for_response for kw in RESPONSE_SLIGHT):
            detected_med_response = 1  # Slight
            print(f"[MOJ-LEAVE] 4f: Medication response = SLIGHT (1)")
        elif any(kw in all_text_for_response for kw in RESPONSE_NIL):
            detected_med_response = 0  # Nil
            print(f"[MOJ-LEAVE] 4f: Medication response = NIL (0)")
        else:
            # Default: If compliant, assume moderate response; if non-compliant, assume slight
            if detected_compliance_status == "non-compliant":
                detected_med_response = 1  # Slight
                print(f"[MOJ-LEAVE] 4f: Medication response defaulting to SLIGHT (non-compliant)")
            else:
                detected_med_response = 3  # Moderate (default)
                print(f"[MOJ-LEAVE] 4f: Medication response defaulting to MODERATE (no keywords found)")

        self._extracted_med_response = detected_med_response

        # If no categorized entries, search raw notes for medications
        if not entries and raw_notes:
            print(f"[MOJ-LEAVE] 4f Medication: No categorized entries, searching {len(raw_notes)} raw notes")

            try:
                from CANONICAL_MEDS import MEDICATIONS
            except ImportError:
                print("[MOJ-LEAVE] 4f Medication: Could not import CANONICAL_MEDS")
                MEDICATIONS = {}

            # Build list of medication patterns
            med_patterns = []
            for med_key, med_data in MEDICATIONS.items():
                patterns = med_data.get("patterns", [])
                canonical = med_data.get("canonical", med_key)
                for pattern in patterns:
                    med_patterns.append((pattern.lower(), canonical, med_data.get("class", "")))

            # Also add common medication keywords
            COMMON_MED_KEYWORDS = [
                "prescribed", "taking", "medication", "dose", "mg", "mcg",
                "tablet", "capsule", "injection", "depot", "oral", "daily",
                "twice daily", "bd", "od", "tds", "qds", "prn", "nocte",
                "morning", "evening", "weekly", "fortnightly", "monthly"
            ]

            # Parse date helper
            def parse_note_date(date_val):
                if isinstance(date_val, datetime):
                    return date_val
                if not date_val:
                    return None
                date_str = str(date_val).strip()
                for fmt in ["%d/%m/%Y", "%Y-%m-%d", "%d-%m-%Y", "%Y/%m/%d"]:
                    try:
                        return datetime.strptime(date_str.split()[0], fmt.split()[0])
                    except:
                        pass
                return None

            # Find most recent date for 1-year cutoff
            all_dates = []
            for n in raw_notes:
                dt = parse_note_date(n.get("date") or n.get("datetime"))
                if dt:
                    all_dates.append(dt)

            if all_dates:
                most_recent = max(all_dates)
                one_year_cutoff = most_recent - timedelta(days=365)
            else:
                one_year_cutoff = None

            seen_meds = {}  # Track found medications with their context

            for n in raw_notes:
                dt = parse_note_date(n.get("date") or n.get("datetime"))
                if one_year_cutoff and dt and dt < one_year_cutoff:
                    continue

                full_text = (n.get("content") or n.get("text") or n.get("preview") or "").strip()
                if not full_text:
                    continue

                text_lower = full_text.lower()

                # Check if note contains medication-related keywords
                has_med_context = any(
                    (bool(re.search(r'(?<!\w)' + re.escape(kw) + r'(?!\w)', text_lower)) if len(kw) <= 5 else kw in text_lower)
                    for kw in COMMON_MED_KEYWORDS
                )

                # Search for specific medications
                found_meds = []
                for pattern, canonical, med_class in med_patterns:
                    # Use word boundary matching
                    if re.search(r'\b' + re.escape(pattern) + r'\b', text_lower):
                        found_meds.append((canonical, med_class))

                if found_meds or has_med_context:
                    # Extract relevant lines containing medication info
                    lines = full_text.split('\n')
                    relevant_lines = []

                    for line in lines:
                        line_lower = line.lower().strip()
                        if not line_lower:
                            continue

                        # Check if line mentions a medication or med keyword
                        line_has_med = False
                        for pattern, canonical, _ in med_patterns:
                            if re.search(r'\b' + re.escape(pattern) + r'\b', line_lower):
                                line_has_med = True
                                break

                        if line_has_med or any(kw in line_lower for kw in COMMON_MED_KEYWORDS):
                            relevant_lines.append(line.strip())

                    if relevant_lines:
                        display_text = '\n'.join(relevant_lines[:5])  # Max 5 lines
                        if len(relevant_lines) > 5:
                            display_text += "\n..."

                        # Create unique key for deduplication
                        key = display_text[:100]
                        if key not in seen_meds:
                            seen_meds[key] = {
                                "text": display_text,
                                "full_text": full_text,
                                "date": str(n.get("date") or n.get("datetime", "")),
                                "medications": [m[0] for m in found_meds[:3]],  # Max 3 med names
                                "sort_date": dt
                            }

            # Convert to list and sort
            entries = list(seen_meds.values())
            entries.sort(key=lambda x: x.get("sort_date") or datetime.min, reverse=True)

            # Remove sort_date
            for e in entries:
                e.pop("sort_date", None)

            print(f"[MOJ-LEAVE] 4f Medication: Found {len(entries)} entries by searching notes")

        # Store entries for later (popup may not exist yet)
        self._extracted_med_import_entries = entries

        # Populate the UI (will check if ready)
        self._populate_medication_import_entries(entries)
        return len(entries)

    def _populate_medication_import_entries(self, entries: list):
        """Populate the 4f medication import panel with entries and checkboxes (4e style with categories)."""
        import re
        self.med_import_checkboxes = []

        if not hasattr(self, 'med_import_layout') or not self.med_import_layout:
            print("[MOJ-LEAVE] 4f Medication import UI not available")
            return

        # Clear existing content
        while self.med_import_layout.count():
            item = self.med_import_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        if not entries:
            placeholder = QLabel("No medication data found. Use Import File to upload data.")
            placeholder.setStyleSheet("color: #9ca3af; font-style: italic; font-size: 14px;")
            self.med_import_layout.addWidget(placeholder)
            self.med_no_imports_label = placeholder
            return

        # Hide the no imports label if it exists (safely handle deleted Qt objects)
        if hasattr(self, 'med_no_imports_label') and self.med_no_imports_label:
            try:
                self.med_no_imports_label.hide()
            except RuntimeError:
                # Qt object was deleted, clear the reference
                self.med_no_imports_label = None

        # ============================================================
        # MEDICATION CATEGORIES AND KEYWORDS - ALL MUST BE MEDICATION-SPECIFIC
        # DO NOT use broad terms like "insight", "response", "compliance" alone
        # ============================================================
        MED_CATEGORIES = {
            "Capacity": [
                # Form references - specific to medication consent
                "form t2", "form t3", "t2 consent", "t3 consent",
                "section 58 consent", "section 62 consent",
                "section 58 medication", "section 62 medication",
                # Capacity specifically for medication
                "capacity to consent to medication", "lacks capacity to consent to medication",
                "has capacity to consent to medication", "consent to medication",
                "incapacitous for medication", "capacitous for medication",
                # SOAD - specific to medication
                "soad", "second opinion appointed doctor", "soad visit",
            ],
            "Compliance": [
                # Compliant WITH medication context only
                "compliant with medication", "compliant with his medication", "compliant with her medication",
                "non-compliant with medication", "non compliant with medication",
                "medication compliance", "medication compliant",
                "taking his medication", "taking her medication", "taking medication as prescribed",
                "refusing medication", "refuses medication", "refused medication",
                "accepts medication", "accepts his medication", "accepts her medication",
                "adherent to medication", "adherent with medication",
                "non-adherent to medication", "non adherent to medication",
                "concordant with medication", "medication concordant",
                "medication refusal", "declined medication", "declines medication",
            ],
            "Response": [
                # Response specifically to medication
                "response to medication", "responded to medication", "responding to medication",
                "medication response", "good medication response", "poor medication response",
                "medication has been effective", "medication is effective",
                "benefit from medication", "benefited from medication",
                "stabilised on medication", "stabilized on medication",
                "stable on medication", "stable on his medication", "stable on her medication",
                "symptom control with medication", "well controlled on medication",
            ],
            "Impact": [
                # Side effects - these are medication-specific by nature
                "side effect", "side-effect", "adverse effect", "adverse reaction",
                "medication side effect", "side effect from medication",
                "weight gain", "sedation", "drowsy", "akathisia", "tremor",
                "stiffness", "eps", "extrapyramidal", "metabolic", "prolactin",
                "tardive", "dystonia", "constipation", "dry mouth"
            ],
            "Insight": [
                # Insight specifically into medication
                "insight into medication", "insight into his medication", "insight into her medication",
                "insight into the need for medication", "insight into need for medication",
                "medication insight", "good medication insight", "poor medication insight",
                "lacks insight into medication", "lacks insight into his medication",
                "no insight into medication",
                "understanding of medication", "understanding of his medication",
                "understands need for medication", "understands the need for medication",
                "accepts need for medication", "accepts the need for medication",
                "recognises need for medication", "recognizes need for medication",
                "denies need for medication", "denies the need for medication",
            ],
        }

        CATEGORY_COLORS = {
            "Capacity": "#7c3aed",
            "Compliance": "#059669",
            "Response": "#0891b2",
            "Impact": "#dc2626",
            "Insight": "#d97706",
        }

        # Helper functions
        def hex_to_light_bg(hex_color):
            hex_color = hex_color.lstrip('#')
            r, g, b = int(hex_color[0:2], 16), int(hex_color[2:4], 16), int(hex_color[4:6], 16)
            r = int(r * 0.3 + 255 * 0.7)
            g = int(g * 0.3 + 255 * 0.7)
            b = int(b * 0.3 + 255 * 0.7)
            return f"#{r:02x}{g:02x}{b:02x}"

        def _kw_to_pattern(kw):
            """Convert keyword to regex pattern, adding word boundaries for short keywords (<=5 chars)."""
            escaped = re.escape(kw)
            if len(kw) <= 5:
                return r'(?<!\w)' + escaped + r'(?!\w)'
            return escaped

        def _kw_matches(kw, text_lower):
            """Check if keyword matches in text, using word boundaries for short keywords (<=5 chars)."""
            if len(kw) <= 5:
                return bool(re.search(r'(?<!\w)' + re.escape(kw) + r'(?!\w)', text_lower, re.IGNORECASE))
            return kw in text_lower

        def highlight_keywords(text, matched_categories):
            import html
            escaped = html.escape(text)
            keyword_colors = {}
            for cat in matched_categories:
                color = CATEGORY_COLORS.get(cat, "#6b7280")
                light_color = hex_to_light_bg(color)
                for kw in MED_CATEGORIES.get(cat, []):
                    keyword_colors[kw] = light_color
            sorted_keywords = sorted(keyword_colors.keys(), key=len, reverse=True)
            for kw in sorted_keywords:
                light_color = keyword_colors[kw]
                pattern = re.compile(_kw_to_pattern(kw), re.IGNORECASE)
                escaped = pattern.sub(
                    lambda m: f'<span style="background-color: {light_color}; font-weight: 600;">{m.group()}</span>',
                    escaped
                )
            escaped = escaped.replace('\n', '<br>')
            return escaped

        # Track current filter
        self._med_current_filter = None

        def filter_by_category(cat):
            if not hasattr(self, 'med_import_checkboxes'):
                return
            if hasattr(self, '_med_current_filter') and self._med_current_filter == cat:
                self._med_current_filter = None
                for entry in self.med_import_checkboxes:
                    entry["frame"].setVisible(True)
            else:
                self._med_current_filter = cat
                for entry in self.med_import_checkboxes:
                    entry["frame"].setVisible(cat in entry.get("categories", []))

        # Detect capacity for dropdown prefill
        # Search for Section 16 (Mental Capacity Act question) and handle double negatives
        detected_capacity = None

        # Section 16 question patterns
        SECTION_16_PATTERNS = [
            "eligible compliant patient who lacks capacity",
            "deprivation of liberty under the mental capacity act",
            "mental capacity act 2005",  # Note: user said 2015 but it's actually 2005 (amended)
            "mental capacity act",
            "whether or not deprivation of liberty",
            "lacks capacity to agree or object",
        ]

        # Double negative patterns that indicate HAS CAPACITY
        # "not...lacking capacity" = HAS capacity
        DOUBLE_NEGATIVE_HAS_CAPACITY = [
            r"not\s+(?:likely|expected|anticipated|assessed|believed|thought|considered)\s+(?:that\s+)?(?:\w+\s+){0,5}(?:to\s+)?(?:be\s+)?(?:lacking|lack)\s+capacity",
            r"would\s+not\s+(?:be\s+)?(?:assessed|considered|thought|believed)\s+(?:as\s+)?lacking\s+capacity",
            r"not\s+(?:be\s+)?assessed\s+as\s+lacking\s+capacity",
            r"unlikely\s+(?:to\s+)?(?:be\s+)?(?:lacking|lack)\s+capacity",
            r"not\s+(?:lacking|lack)\s+capacity",
            r"does\s+not\s+lack\s+capacity",
            r"doesn't\s+lack\s+capacity",
        ]

        # Patterns that indicate LACKS CAPACITY (single negatives)
        LACKS_CAPACITY_PATTERNS = [
            "lacks capacity", "lack capacity", "lacking capacity",
            "incapacitous", "does not have capacity", "doesn't have capacity",
            "without capacity", "no capacity to consent",
            "assessed as lacking capacity", "found to lack capacity",
        ]

        # Patterns that indicate HAS CAPACITY
        HAS_CAPACITY_PATTERNS = [
            "has capacity", "have capacity", "having capacity",
            "capacitous", "retains capacity", "maintains capacity",
            "assessed as having capacity", "found to have capacity",
            "capacity to consent", "able to consent",
        ]

        # First search the full document text for Section 16
        document_text = getattr(self, '_extracted_document_text', "") or ""
        if document_text:
            doc_lower = document_text.lower()

            # Section 16 question pattern - we need to find the ANSWER, not the question
            # The question itself contains "lacks capacity" so we must skip past it
            SECTION_16_QUESTION = "whether or not deprivation of liberty"
            SECTION_16_QUESTION_ALT = "eligible compliant patient who lacks capacity"

            # Find where the Section 16 question ends and the answer begins
            answer_text = ""
            for q_pattern in [SECTION_16_QUESTION, SECTION_16_QUESTION_ALT]:
                if q_pattern in doc_lower:
                    q_pos = doc_lower.find(q_pattern)
                    # Find the end of the question (look for colon, newline after "restrictive", or next sentence)
                    question_end_markers = [":", "restrictive", "appropriate"]
                    end_pos = q_pos
                    for marker in question_end_markers:
                        marker_pos = doc_lower.find(marker, q_pos)
                        if marker_pos > end_pos and marker_pos < q_pos + 300:
                            end_pos = marker_pos + len(marker)

                    # Get the answer portion (after the question)
                    answer_text = doc_lower[end_pos:end_pos + 500]
                    print(f"[MOJ-LEAVE] 4f: Found Section 16 question, extracting answer: '{answer_text[:100]}...'")
                    break

            if answer_text:
                print(f"[MOJ-LEAVE] 4f: Analyzing Section 16 ANSWER for capacity")

                # Look for double negatives FIRST in the ANSWER - these indicate HAS capacity
                for pattern in DOUBLE_NEGATIVE_HAS_CAPACITY:
                    match = re.search(pattern, answer_text)
                    if match:
                        detected_capacity = "Has capacity"
                        print(f"[MOJ-LEAVE] 4f: Detected DOUBLE NEGATIVE '{match.group()}' = HAS CAPACITY")
                        break

                # If no double negative found, check for single patterns in ANSWER
                if not detected_capacity:
                    # Check for lacks capacity patterns in the ANSWER only
                    for pattern in LACKS_CAPACITY_PATTERNS:
                        if pattern in answer_text:
                            detected_capacity = "Lacks capacity"
                            print(f"[MOJ-LEAVE] 4f: Detected '{pattern}' in answer = LACKS CAPACITY")
                            break

                    # Check for has capacity patterns (only if not already detected)
                    if not detected_capacity:
                        for pattern in HAS_CAPACITY_PATTERNS:
                            if pattern in answer_text:
                                detected_capacity = "Has capacity"
                                print(f"[MOJ-LEAVE] 4f: Detected '{pattern}' in answer = HAS CAPACITY")
                                break

        # Also check entries for T2/T3 forms (these override Section 16 responses)
        for entry in entries:
            text_lower = (entry.get("text", "") or "").lower()

            # T3 = Lacks capacity (this is definitive)
            if any(re.search(r'(?<!\w)' + re.escape(kw) + r'(?!\w)', text_lower) for kw in ["t3", "form t3", "section 58"]):
                detected_capacity = "Lacks capacity"
                print(f"[MOJ-LEAVE] 4f: Found T3/Section 58 form = LACKS CAPACITY")
                break

            # T2 = Has capacity (this is definitive)
            if any(re.search(r'(?<!\w)' + re.escape(kw) + r'(?!\w)', text_lower) for kw in ["t2", "form t2"]):
                detected_capacity = "Has capacity"
                print(f"[MOJ-LEAVE] 4f: Found T2 form = HAS CAPACITY")

            # Also check for double negatives in entries
            if not detected_capacity:
                for pattern in DOUBLE_NEGATIVE_HAS_CAPACITY:
                    match = re.search(pattern, text_lower)
                    if match:
                        detected_capacity = "Has capacity"
                        print(f"[MOJ-LEAVE] 4f: Entry double negative '{match.group()}' = HAS CAPACITY")
                        break

        # Apply detected capacity to dropdown - ONLY if T2/T3 form was found
        # Otherwise keep the default "Has capacity"
        print(f"[MOJ-LEAVE] 4f DEBUG: detected_capacity = '{detected_capacity}'")

        # If no capacity detected at all, default to "Has capacity"
        if not detected_capacity:
            detected_capacity = "Has capacity"
            print(f"[MOJ-LEAVE] 4f DEBUG: No capacity detected, defaulting to 'Has capacity'")

        if detected_capacity and hasattr(self, 'med_capacity_combo'):
            # Check if this was from a definitive source (T2/T3 form)
            # If no T2/T3 found, default to "Has capacity"
            current_idx = self.med_capacity_combo.currentIndex()
            current_text = self.med_capacity_combo.currentText()
            print(f"[MOJ-LEAVE] 4f DEBUG: Current dropdown = '{current_text}' (idx={current_idx})")

            # Only override if we found something definitive, otherwise keep default
            if detected_capacity == "Lacks capacity":
                # Check if we actually found T3/Section 58 (definitive lacks capacity)
                t3_found = any(
                    any(kw in (entry.get("text", "") or "").lower() for kw in ["t3", "form t3", "section 58"])
                    for entry in entries
                )
                if t3_found:
                    idx = self.med_capacity_combo.findText(detected_capacity)
                    if idx >= 0:
                        self.med_capacity_combo.setCurrentIndex(idx)
                        print(f"[MOJ-LEAVE] 4f: T3/Section 58 found - Set capacity to '{detected_capacity}'")
                else:
                    # No T3 found, default to Has capacity
                    idx = self.med_capacity_combo.findText("Has capacity")
                    if idx >= 0:
                        self.med_capacity_combo.setCurrentIndex(idx)
                        print(f"[MOJ-LEAVE] 4f: No T3 found, defaulting to 'Has capacity'")
            else:
                # Has capacity was detected
                idx = self.med_capacity_combo.findText(detected_capacity)
                if idx >= 0:
                    self.med_capacity_combo.setCurrentIndex(idx)
                    print(f"[MOJ-LEAVE] 4f: Set capacity dropdown to '{detected_capacity}'")

        # Select All / Deselect All / Expand All / Collapse All buttons
        btn_row = QHBoxLayout()
        btn_row.setSpacing(6)

        select_all_btn = QPushButton("Select All")
        select_all_btn.setStyleSheet("QPushButton { background: #3b82f6; color: white; border: none; border-radius: 4px; padding: 6px 12px; font-size: 14px; font-weight: 600; } QPushButton:hover { background: #2563eb; }")
        select_all_btn.clicked.connect(self._select_all_med_imports)
        btn_row.addWidget(select_all_btn)

        deselect_all_btn = QPushButton("Deselect All")
        deselect_all_btn.setStyleSheet("QPushButton { background: #6b7280; color: white; border: none; border-radius: 4px; padding: 6px 12px; font-size: 14px; font-weight: 600; } QPushButton:hover { background: #4b5563; }")
        deselect_all_btn.clicked.connect(self._deselect_all_med_imports)
        btn_row.addWidget(deselect_all_btn)

        expand_all_btn = QPushButton("+ Expand")
        expand_all_btn.setStyleSheet("QPushButton { background: #059669; color: white; border: none; border-radius: 4px; padding: 6px 12px; font-size: 14px; font-weight: 600; } QPushButton:hover { background: #047857; }")
        btn_row.addWidget(expand_all_btn)

        collapse_all_btn = QPushButton("− Collapse")
        collapse_all_btn.setStyleSheet("QPushButton { background: #d97706; color: white; border: none; border-radius: 4px; padding: 6px 12px; font-size: 14px; font-weight: 600; } QPushButton:hover { background: #b45309; }")
        btn_row.addWidget(collapse_all_btn)

        btn_row.addStretch()

        btn_widget = QWidget()
        btn_widget.setLayout(btn_row)
        self.med_import_layout.addWidget(btn_widget)

        # Storage for expand/collapse all
        body_widgets = []

        # Add each entry with categories (4A style - white rounded containers)
        for entry in entries:
            text = entry.get("text", "")
            full_text = entry.get("full_text", text)
            date = entry.get("date", "")
            medications = entry.get("medications", [])

            if not text:
                continue

            text_lower = text.lower()

            # Detect categories
            matched_cats = []
            matched_keywords = []
            for cat, keywords in MED_CATEGORIES.items():
                for kw in keywords:
                    if _kw_matches(kw, text_lower):
                        if cat not in matched_cats:
                            matched_cats.append(cat)
                        matched_keywords.append(kw)

            # Create entry widget (4A style - white rounded container)
            frame = QFrame()
            frame.setObjectName("entryFrame")
            frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            frame.setStyleSheet("""
                QFrame#entryFrame {
                    background: rgba(255, 255, 255, 0.95);
                    border: 1px solid rgba(180, 150, 50, 0.4);
                    border-radius: 8px;
                    padding: 4px;
                }
            """)
            frame_layout = QVBoxLayout(frame)
            frame_layout.setContentsMargins(10, 4, 16, 4)
            frame_layout.setSpacing(6)


            # Header row: toggle_btn → category tags → med tags → date → stretch → checkbox
            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            # Toggle button (left side)
            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(180, 150, 50, 0.2);
                    border: none;
                    border-radius: 4px;
                    font-size: 15px;
                    font-weight: bold;
                    color: #806000;
                }
                QPushButton:hover { background: rgba(180, 150, 50, 0.35); }
            """)
            header_row.addWidget(toggle_btn)

            # Date label (amber) — before tags
            date_str = str(date)[:10] if date else ""
            if date_str:
                date_label = QLabel(f"\U0001f4c5 {date_str}")
                date_label.setStyleSheet("""
                    QLabel {
                        font-size: 15px; font-weight: 600; color: #806000;
                        background: transparent; border: none;
                    }
                """)
                date_label.setCursor(Qt.CursorShape.PointingHandCursor)
                header_row.addWidget(date_label)

            # Category tags (clickable) — after date
            for cat in matched_cats:
                color = CATEGORY_COLORS.get(cat, "#6b7280")
                tag = QPushButton(cat)
                tag.setCursor(Qt.CursorShape.PointingHandCursor)
                tag.setStyleSheet(f"""
                    QPushButton {{
                        font-size: 14px; font-weight: 600; color: white;
                        background: {color}; padding: 3px 8px; border-radius: 3px; border: none;
                    }}
                    QPushButton:hover {{ background: {color}; opacity: 0.8; }}
                """)
                tag.clicked.connect(lambda checked, c=cat: filter_by_category(c))
                header_row.addWidget(tag)

            # Medication tags
            for med in medications[:2]:
                med_tag = QLabel(med)
                med_tag.setStyleSheet("QLabel { background: #8b5cf6; color: white; font-size: 14px; font-weight: 600; padding: 3px 8px; border-radius: 3px; }")
                header_row.addWidget(med_tag)

            header_row.addStretch()

            # Checkbox (right side, with margin)
            cb = QCheckBox()
            cb.setFixedSize(20, 20)
            cb.setStyleSheet("""
                QCheckBox { background: transparent; margin-right: 4px; }
                QCheckBox::indicator { width: 18px; height: 18px; }
            """)
            cb.toggled.connect(self._update_medication_preview)
            header_row.addWidget(cb)

            frame_layout.addLayout(header_row)

            # Body text (hidden by default, with keyword highlighting)
            full_highlighted = highlight_keywords(text, matched_cats)
            body_text = QTextEdit()
            body_text.setHtml(full_highlighted)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("""
                QTextEdit {
                    font-size: 15px;
                    color: #333;
                    background: rgba(255, 248, 220, 0.5);
                    border: none;
                    padding: 8px;
                    border-radius: 6px;
                }
            """)
            body_text.document().setTextWidth(body_text.viewport().width() if body_text.viewport().width() > 0 else 350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            frame_layout.addWidget(body_text)

            # Toggle function
            def make_toggle(btn, body, f):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    f.updateGeometry()
                return toggle

            toggle_fn = make_toggle(toggle_btn, body_text, frame)
            toggle_btn.clicked.connect(toggle_fn)
            if date_str:
                date_label.mousePressEvent = lambda e, fn=toggle_fn: fn()

            body_widgets.append((toggle_btn, body_text, frame))

            self.med_import_layout.addWidget(frame)

            self.med_import_checkboxes.append({
                "checkbox": cb,
                "frame": frame,
                "text": text,
                "full_text": full_text,
                "date": date,
                "medications": medications,
                "categories": matched_cats,
            })

        # Connect expand/collapse all buttons
        def expand_all():
            for btn, body, f in body_widgets:
                body.setVisible(True)
                btn.setText("\u25be")
                f.updateGeometry()

        def collapse_all():
            for btn, body, f in body_widgets:
                body.setVisible(False)
                btn.setText("\u25b8")
                f.updateGeometry()

        expand_all_btn.clicked.connect(expand_all)
        collapse_all_btn.clicked.connect(collapse_all)

        print(f"[MOJ-LEAVE] 4f: Added {len(entries)} medication entries with categories")

        # Auto-expand section if entries found
        if entries and hasattr(self, 'med_import_section_content'):
            self.med_import_section_content.setVisible(True)
            if hasattr(self, 'med_import_expand_btn'):
                self.med_import_expand_btn.setText("−")

    def _select_all_med_imports(self):
        """Select all medication import checkboxes."""
        if hasattr(self, 'med_import_checkboxes'):
            for entry in self.med_import_checkboxes:
                entry.get("checkbox").setChecked(True)

    def _deselect_all_med_imports(self):
        """Deselect all medication import checkboxes."""
        if hasattr(self, 'med_import_checkboxes'):
            for entry in self.med_import_checkboxes:
                entry.get("checkbox").setChecked(False)

    def _prefill_medications_from_notes(self, raw_notes: list, document_text: str = None):
        """Extract medications from notes or document text and prefill the medication entries."""
        import re
        from datetime import datetime, timedelta
        from CANONICAL_MEDS import MEDICATIONS

        if not hasattr(self, '_med_entries') or not hasattr(self, 'med_entries_layout'):
            print("[MOJ-LEAVE] 4f: Medication entries UI not available")
            return

        # Parse date helper
        def parse_date(date_val):
            if not date_val:
                return None
            if isinstance(date_val, datetime):
                return date_val
            for fmt in ["%Y-%m-%d", "%d/%m/%Y", "%Y-%m-%dT%H:%M:%S", "%d-%m-%Y"]:
                try:
                    return datetime.strptime(str(date_val)[:10], fmt[:min(len(fmt), 10)])
                except:
                    pass
            return None

        # Determine source of text to search
        # PRIORITY: Use document_text (medication-only) FIRST if available
        # This avoids picking up historical medications from the full document
        texts_to_search = []

        if document_text and document_text.strip():
            # Use the medication-only text (preferred - avoids historical meds)
            print(f"[MOJ-LEAVE] 4f: Using medication-only document text ({len(document_text)} chars)")
            # Skip raw_notes entirely - go straight to document_text processing
            pass
        elif raw_notes:
            # Fallback to raw_notes only if no document_text
            note_dates = [parse_date(n.get("date") or n.get("datetime")) for n in raw_notes]
            note_dates = [d for d in note_dates if d]

            if note_dates:
                latest_date = max(note_dates)
                cutoff_date = latest_date - timedelta(days=365)
                print(f"[MOJ-LEAVE] 4f: Searching notes from {cutoff_date.date()} to {latest_date.date()}")
                recent_notes = [n for n in raw_notes if (parse_date(n.get("date") or n.get("datetime")) or datetime.min) >= cutoff_date]
                texts_to_search = [(n.get("content", "") or n.get("text", "") or "", parse_date(n.get("date") or n.get("datetime"))) for n in recent_notes]
                print(f"[MOJ-LEAVE] 4f: Extracting medications from {len(recent_notes)} notes (last year)")
            else:
                texts_to_search = [(n.get("content", "") or n.get("text", "") or n.get("body", "") or "", None) for n in raw_notes]
                print(f"[MOJ-LEAVE] 4f: Extracting medications from {len(raw_notes)} notes (no date filtering)")

        if not texts_to_search and document_text:
            # Try to extract just the CURRENT medication section from document
            # Look for "Regular:" which indicates the current medication list
            med_section_text = None
            doc_lower = document_text.lower()

            # First, try to find section starting with "Regular:" (most reliable indicator of current meds)
            regular_match = re.search(r'regular\s*:', doc_lower)
            if regular_match:
                # Find end of medication section - look for next numbered section
                remaining = doc_lower[regular_match.start():]
                # Match next numbered section (e.g., "13." at start of line)
                end_match = re.search(r'\n\s*\d+\.\s*[a-z]', remaining)
                if end_match:
                    end_pos = end_match.start()
                else:
                    # Fallback - take 300 chars
                    end_pos = min(300, len(remaining))

                med_section_text = document_text[regular_match.start():regular_match.start() + end_pos]
                print(f"[MOJ-LEAVE] 4f: Found 'Regular:' medication section ({len(med_section_text)} chars)")
                print(f"[MOJ-LEAVE] 4f: Section text: {repr(med_section_text[:150])}...")

            # Fallback: try Section 12 header
            if not med_section_text:
                section_match = re.search(r'(?:12\.?\s*)?what appropriate and available medical treatment', doc_lower)
                if section_match:
                    end_match = re.search(r'(?:13\.?\s*what are the strengths|\n\s*\d+\.\s)', doc_lower[section_match.end():])
                    if end_match:
                        med_section_text = document_text[section_match.start():section_match.end() + end_match.start()]
                    else:
                        med_section_text = document_text[section_match.start():section_match.start() + 400]
                    print(f"[MOJ-LEAVE] 4f: Found Section 12 header ({len(med_section_text)} chars)")

            if med_section_text:
                texts_to_search = [(med_section_text, None)]
            else:
                # Don't search full document - too risky to pick up historical meds
                print(f"[MOJ-LEAVE] 4f: WARNING - No current medication section found, skipping extraction")
                return

        if not texts_to_search:
            print("[MOJ-LEAVE] 4f: No text available for medication extraction")
            return

        # Build token index - separate single and multi-word patterns
        token_map = {}
        multi_word_patterns = []  # List of (pattern_words, key, canonical)
        meta_map = {}
        for key, meta in MEDICATIONS.items():
            meta_map[key] = meta
            for syn in meta.get("patterns", []):
                s = syn.lower().strip()
                if s:
                    words = s.split()
                    if len(words) == 1:
                        token_map[s] = (key, meta["canonical"])
                    else:
                        multi_word_patterns.append((words, key, meta["canonical"]))

        def tokenise(text):
            text = text.lower()
            text = re.sub(r'(?<=\d)\.(?=\d)', 'DOT', text)
            text = re.sub(r'[^a-z0-9DOT]+', ' ', text)
            text = text.replace("DOT", ".")
            return text.split()

        def find_dose(tokens, idx):
            unit_set = {"mg", "mcg", "µg", "g", "units", "iu"}
            for i in range(idx + 1, min(idx + 4, len(tokens))):
                tok = tokens[i]
                m = re.match(r'(\d+(?:\.\d+)?)(mg|mcg|µg|g|units|iu)$', tok)
                if m:
                    return float(m.group(1)), m.group(2)
                if tok.isdigit() or re.match(r'\d+\.\d+', tok):
                    if i + 1 < len(tokens) and tokens[i + 1] in unit_set:
                        return float(tok), tokens[i + 1]
            return None, None

        def find_freq(tokens, idx, is_prn_section=False):
            freq_set = {"od", "bd", "tds", "qds", "qid", "nocte", "mane", "stat", "prn", "daily", "weekly", "monthly", "fortnightly"}
            for i in range(idx, min(idx + 5, len(tokens))):
                if tokens[i] in freq_set:
                    return tokens[i]
            # If we're in a PRN section (after "as required:"), return prn
            if is_prn_section:
                return "prn"
            return None

        def find_prn_boundary(tokens):
            """Find the token index where 'as required' appears."""
            for i in range(len(tokens) - 1):
                if tokens[i] == "as" and tokens[i+1] == "required":
                    return i
            return -1

        # Psychiatric classes prioritized
        PSYCH_CLASSES = {
            "Antipsychotic": 1, "Antidepressant": 2, "Mood Stabiliser": 3,
            "Anxiolytic": 4, "Benzodiazepine": 5, "Sedative": 6, "Sleep": 7,
            "Stimulant": 8, "Addictions": 9, "Opioid Substitution": 9,
        }

        # Extract medications
        meds_found = []
        for content, note_date in texts_to_search:
            if not content:
                continue
            tokens = tokenise(content)
            matched_indices = set()  # Track indices already matched by multi-word patterns

            # Find where "as required" section starts (for PRN detection)
            prn_boundary = find_prn_boundary(tokens)
            print(f"[MOJ-LEAVE] 4f: PRN boundary at token index {prn_boundary}")

            # First pass: Check multi-word patterns (more specific matches first)
            for pattern_words, key, canonical in multi_word_patterns:
                pattern_len = len(pattern_words)
                for i in range(len(tokens) - pattern_len + 1):
                    if i in matched_indices:
                        continue
                    if tokens[i:i+pattern_len] == pattern_words:
                        meta = meta_map[key]
                        med_class = meta.get("class", "Other")
                        is_prn_section = prn_boundary >= 0 and i > prn_boundary
                        strength, unit = find_dose(tokens, i + pattern_len - 1)
                        freq = find_freq(tokens, i + pattern_len - 1, is_prn_section)
                        meds_found.append({
                            "med_key": key, "canonical": canonical, "class": med_class,
                            "strength": strength, "unit": unit or "mg", "frequency": freq, "date": note_date,
                        })
                        print(f"[MOJ-LEAVE] 4f: Found {canonical} {strength}{unit or 'mg'} {freq} (PRN section: {is_prn_section})")
                        # Mark all indices in this match as used
                        for j in range(i, i + pattern_len):
                            matched_indices.add(j)

            # Second pass: Check single-word patterns (skip already matched indices)
            for i, tok in enumerate(tokens):
                if i in matched_indices:
                    continue
                if tok in token_map:
                    key, canonical = token_map[tok]
                    meta = meta_map[key]
                    med_class = meta.get("class", "Other")
                    is_prn_section = prn_boundary >= 0 and i > prn_boundary
                    strength, unit = find_dose(tokens, i)
                    freq = find_freq(tokens, i, is_prn_section)
                    meds_found.append({
                        "med_key": key, "canonical": canonical, "class": med_class,
                        "strength": strength, "unit": unit or "mg", "frequency": freq, "date": note_date,
                    })
                    print(f"[MOJ-LEAVE] 4f: Found {canonical} {strength}{unit or 'mg'} {freq} (PRN section: {is_prn_section})")

        print(f"[MOJ-LEAVE] 4f: Found {len(meds_found)} medication mentions")

        if not meds_found:
            return

        # Group by class and pick most recent per class
        class_groups = {}
        for med in meds_found:
            med_class = med.get("class", "Other")
            if med_class not in class_groups:
                class_groups[med_class] = []
            class_groups[med_class].append(med)

        most_recent_by_class = []
        for med_class, mentions in class_groups.items():
            sorted_mentions = sorted(mentions, key=lambda x: x.get("date") or datetime.min, reverse=True)
            for m in sorted_mentions:
                if m.get("strength"):
                    most_recent_by_class.append(m)
                    break
            else:
                if sorted_mentions:
                    most_recent_by_class.append(sorted_mentions[0])

        # Prioritize psych classes
        most_recent_by_class.sort(key=lambda m: PSYCH_CLASSES.get(m.get("class", "Other"), 100))
        final_meds = most_recent_by_class[:8]  # Max 8 medications

        print(f"[MOJ-LEAVE] 4f: Selected {len(final_meds)} medications (1 per class, psych prioritized)")

        # Frequency mapping
        FREQ_MAP = {
            "od": "OD", "daily": "OD", "bd": "BD", "tds": "TDS", "qds": "QDS",
            "nocte": "Nocte", "mane": "Mane", "prn": "PRN",
            "weekly": "Weekly", "fortnightly": "Fortnightly", "monthly": "Monthly",
        }

        # Add medication entries to the UI
        for med in final_meds:
            # Add new entry if needed
            if len(self._med_entries) < len(final_meds):
                self._add_medication_entry()

        # Populate entries
        for i, med in enumerate(final_meds):
            if i >= len(self._med_entries):
                break
            entry = self._med_entries[i]

            # Set medication name
            med_key = med.get("med_key", "")
            name_combo = entry["name"]
            idx = name_combo.findText(med_key)
            if idx >= 0:
                name_combo.setCurrentIndex(idx)
            else:
                name_combo.setCurrentText(med.get("canonical", med_key))

            # Set dose
            if med.get("strength"):
                dose_str = f"{int(med['strength']) if med['strength'] == int(med['strength']) else med['strength']}{med.get('unit', 'mg')}"
                dose_combo = entry["dose"]
                dose_idx = dose_combo.findText(dose_str)
                if dose_idx >= 0:
                    dose_combo.setCurrentIndex(dose_idx)
                else:
                    dose_combo.setCurrentText(dose_str)

            # Set frequency
            if med.get("frequency"):
                freq_text = FREQ_MAP.get(med["frequency"].lower(), med["frequency"].upper())
                freq_combo = entry["freq"]
                freq_idx = freq_combo.findText(freq_text)
                if freq_idx >= 0:
                    freq_combo.setCurrentIndex(freq_idx)

        self._check_med_details_visibility()
        self._update_medication_preview()
        print(f"[MOJ-LEAVE] 4f: Prefilled {len(final_meds)} medication entries")

    def _add_medication_entry(self):
        """Add a new medication entry row."""
        if not hasattr(self, 'med_entries_layout') or not hasattr(self, '_med_entries'):
            return

        from PySide6.QtWidgets import QComboBox, QPushButton, QFrame, QHBoxLayout
        from CANONICAL_MEDS import MEDICATIONS

        entry_widget = QFrame()
        entry_widget.setStyleSheet("QFrame { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 6px; }")
        entry_layout = QHBoxLayout(entry_widget)
        entry_layout.setContentsMargins(8, 4, 8, 4)
        entry_layout.setSpacing(6)

        name_combo = QComboBox()
        name_combo.setEditable(True)
        name_combo.addItem("")
        name_combo.addItems(sorted(MEDICATIONS.keys()))
        name_combo.setMinimumWidth(150)
        name_combo.setStyleSheet("font-size: 14px;")
        entry_layout.addWidget(name_combo)

        dose_combo = QComboBox()
        dose_combo.setEditable(True)
        dose_combo.setMinimumWidth(100)
        dose_combo.setStyleSheet("font-size: 14px;")
        entry_layout.addWidget(dose_combo)

        freq_combo = QComboBox()
        freq_combo.addItems(["", "OD", "BD", "TDS", "QDS", "Nocte", "PRN", "Weekly", "Fortnightly", "Monthly"])
        freq_combo.setMinimumWidth(100)
        freq_combo.setStyleSheet("font-size: 14px;")
        entry_layout.addWidget(freq_combo)

        remove_btn = QPushButton("×")
        remove_btn.setFixedSize(20, 20)
        remove_btn.setStyleSheet("QPushButton { background: #ef4444; color: white; border: none; border-radius: 10px; font-weight: bold; } QPushButton:hover { background: #dc2626; }")
        entry_layout.addWidget(remove_btn)

        entry_data = {"widget": entry_widget, "name": name_combo, "dose": dose_combo, "freq": freq_combo}
        self._med_entries.append(entry_data)

        def on_med_change(med_name):
            if med_name and med_name in MEDICATIONS:
                info = MEDICATIONS[med_name]
                allowed = info.get("allowed_strengths", [])
                dose_combo.clear()
                dose_combo.addItem("")
                for s in allowed:
                    dose_combo.addItem(f"{s}mg")
            self._check_med_details_visibility()
            self._update_medication_preview()

        name_combo.currentTextChanged.connect(on_med_change)
        dose_combo.currentTextChanged.connect(self._update_medication_preview)
        freq_combo.currentTextChanged.connect(self._update_medication_preview)

        def remove_entry():
            if entry_data in self._med_entries:
                self._med_entries.remove(entry_data)
            entry_widget.deleteLater()
            self._check_med_details_visibility()
            self._update_medication_preview()

        remove_btn.clicked.connect(remove_entry)
        self.med_entries_layout.addWidget(entry_widget)

    def _create_psychology_popup(self) -> QWidget:
        """Create Risks and Psychology popup with sections from ASR card 5 (1,3,4,5) and card 6 (2)."""
        key = "psychology"
        popup = QWidget()
        popup.setObjectName(f"popup_{key}")
        popup.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)

        # Hidden label to store text for auto-sync to card
        self.psychology_preview = QLabel()
        self.psychology_preview.hide()

        # === CONTENT PANEL ===
        content_scroll = QScrollArea()
        content_scroll.setWidgetResizable(True)
        content_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        content_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        content_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        content_scroll.setStyleSheet("QScrollArea { background: transparent; border: none; }")

        content_widget = QWidget()
        content_widget.setStyleSheet("background: transparent;")
        content_widget.setSizePolicy(QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Preferred)
        content_layout = QVBoxLayout(content_widget)
        content_layout.setContentsMargins(8, 8, 8, 8)
        content_layout.setSpacing(10)

        slider_style = """
            QSlider::groove:horizontal { height: 6px; background: #e5e7eb; border-radius: 3px; }
            QSlider::handle:horizontal { width: 16px; margin: -5px 0; background: #7c3aed; border-radius: 8px; }
            QSlider::sub-page:horizontal { background: #7c3aed; border-radius: 3px; }
        """

        # ============================================================
        # SECTION 1: INDEX OFFENCE WORK (from ASR card 5 section 1)
        # ============================================================
        section1_container = QWidget()
        section1_container.setStyleSheet("background: #f3f4f6; border-radius: 6px;")
        section1_layout = QVBoxLayout(section1_container)
        section1_layout.setContentsMargins(10, 8, 10, 8)
        section1_layout.setSpacing(6)

        section1_header = QHBoxLayout()
        self.psych_s1_btn = QPushButton("+")
        self.psych_s1_btn.setFixedSize(20, 20)
        self.psych_s1_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.psych_s1_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #374151; background: white; border: 1px solid #d1d5db; border-radius: 4px; } QPushButton:hover { background: #e5e7eb; }")
        section1_header.addWidget(self.psych_s1_btn)
        section1_title = QLabel("1. Work to address index offence(s) and risks")
        section1_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #374151;")
        section1_header.addWidget(section1_title)
        section1_header.addStretch()
        section1_layout.addLayout(section1_header)

        self.psych_s1_content = QWidget()
        s1_content_layout = QVBoxLayout(self.psych_s1_content)
        s1_content_layout.setContentsMargins(28, 4, 0, 4)
        s1_content_layout.setSpacing(4)

        self.psych_index_options = ["None", "Considering", "Starting", "Engaging", "Well Engaged", "Almost Complete", "Complete"]
        s1_row = QHBoxLayout()
        self.psych_index_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.psych_index_slider.setRange(0, len(self.psych_index_options) - 1)
        self.psych_index_slider.setValue(0)
        self.psych_index_slider.setStyleSheet(slider_style)
        self.psych_index_slider.setMinimumWidth(180)
        s1_row.addWidget(self.psych_index_slider)
        self.psych_index_label = QLabel(self.psych_index_options[0])
        self.psych_index_label.setStyleSheet("font-size: 13px; font-weight: 600; color: #7c3aed;")
        self.psych_index_slider.valueChanged.connect(lambda v: self.psych_index_label.setText(self.psych_index_options[v]))
        self.psych_index_slider.valueChanged.connect(self._update_psychology_preview)
        s1_row.addWidget(self.psych_index_label)
        s1_row.addStretch()
        s1_content_layout.addLayout(s1_row)

        self.psych_index_details = QLineEdit()
        self.psych_index_details.setPlaceholderText("Additional details about index offence work...")
        self.psych_index_details.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;")
        self.psych_index_details.textChanged.connect(self._update_psychology_preview)
        s1_content_layout.addWidget(self.psych_index_details)

        section1_layout.addWidget(self.psych_s1_content)
        self.psych_s1_content.setVisible(False)
        content_layout.addWidget(section1_container)

        def toggle_s1():
            visible = not self.psych_s1_content.isVisible()
            self.psych_s1_content.setVisible(visible)
            self.psych_s1_btn.setText("-" if visible else "+")
        self.psych_s1_btn.clicked.connect(toggle_s1)

        # ============================================================
        # SECTION 2: OFFENDING BEHAVIOUR (from ASR card 6 section 2)
        # ============================================================
        section2_container = QWidget()
        section2_container.setStyleSheet("background: #fef2f2; border-radius: 6px;")
        section2_layout = QVBoxLayout(section2_container)
        section2_layout.setContentsMargins(10, 8, 10, 8)
        section2_layout.setSpacing(6)

        section2_header = QHBoxLayout()
        self.psych_s2_btn = QPushButton("+")
        self.psych_s2_btn.setFixedSize(20, 20)
        self.psych_s2_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.psych_s2_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #991b1b; background: white; border: 1px solid #fecaca; border-radius: 4px; } QPushButton:hover { background: #fee2e2; }")
        section2_header.addWidget(self.psych_s2_btn)
        section2_title = QLabel("2. Offending Behaviour - Insight & Responsibility")
        section2_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #991b1b;")
        section2_header.addWidget(section2_title)
        section2_header.addStretch()
        section2_layout.addLayout(section2_header)

        self.psych_s2_content = QWidget()
        s2_content_layout = QVBoxLayout(self.psych_s2_content)
        s2_content_layout.setContentsMargins(28, 4, 0, 4)
        s2_content_layout.setSpacing(6)

        red_slider_style = """
            QSlider::groove:horizontal { height: 6px; background: #e5e7eb; border-radius: 3px; }
            QSlider::handle:horizontal { width: 16px; margin: -5px 0; background: #991b1b; border-radius: 8px; }
            QSlider::sub-page:horizontal { background: #991b1b; border-radius: 3px; }
        """

        # Insight into offending
        insight_row = QHBoxLayout()
        insight_lbl = QLabel("Insight into offending:")
        insight_lbl.setStyleSheet("font-size: 13px;")
        insight_row.addWidget(insight_lbl)
        self.psych_offend_insight_options = ["Nil", "Limited", "Partial", "Good", "Full"]
        self.psych_offend_insight_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.psych_offend_insight_slider.setRange(0, len(self.psych_offend_insight_options) - 1)
        self.psych_offend_insight_slider.setValue(2)
        self.psych_offend_insight_slider.setStyleSheet(red_slider_style)
        self.psych_offend_insight_slider.setMinimumWidth(150)
        insight_row.addWidget(self.psych_offend_insight_slider)
        self.psych_offend_insight_label = QLabel(self.psych_offend_insight_options[2])
        self.psych_offend_insight_label.setStyleSheet("font-size: 13px; font-weight: 600; color: #991b1b;")
        self.psych_offend_insight_slider.valueChanged.connect(lambda v: self.psych_offend_insight_label.setText(self.psych_offend_insight_options[v]))
        self.psych_offend_insight_slider.valueChanged.connect(self._update_psychology_preview)
        insight_row.addWidget(self.psych_offend_insight_label)
        insight_row.addStretch()
        s2_content_layout.addLayout(insight_row)

        # Accepts responsibility
        resp_row = QHBoxLayout()
        resp_lbl = QLabel("Accepts responsibility:")
        resp_lbl.setStyleSheet("font-size: 13px;")
        resp_row.addWidget(resp_lbl)
        self.psych_responsibility_options = ["Denies", "Minimises", "Partial", "Mostly", "Full"]
        self.psych_responsibility_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.psych_responsibility_slider.setRange(0, len(self.psych_responsibility_options) - 1)
        self.psych_responsibility_slider.setValue(2)
        self.psych_responsibility_slider.setStyleSheet(red_slider_style)
        self.psych_responsibility_slider.setMinimumWidth(150)
        resp_row.addWidget(self.psych_responsibility_slider)
        self.psych_responsibility_label = QLabel(self.psych_responsibility_options[2])
        self.psych_responsibility_label.setStyleSheet("font-size: 13px; font-weight: 600; color: #991b1b;")
        self.psych_responsibility_slider.valueChanged.connect(lambda v: self.psych_responsibility_label.setText(self.psych_responsibility_options[v]))
        self.psych_responsibility_slider.valueChanged.connect(self._update_psychology_preview)
        resp_row.addWidget(self.psych_responsibility_label)
        resp_row.addStretch()
        s2_content_layout.addLayout(resp_row)

        # Victim empathy
        empathy_row = QHBoxLayout()
        empathy_lbl = QLabel("Victim empathy:")
        empathy_lbl.setStyleSheet("font-size: 13px;")
        empathy_row.addWidget(empathy_lbl)
        self.psych_empathy_options = ["Nil", "Limited", "Developing", "Good", "Full"]
        self.psych_empathy_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.psych_empathy_slider.setRange(0, len(self.psych_empathy_options) - 1)
        self.psych_empathy_slider.setValue(2)
        self.psych_empathy_slider.setStyleSheet(red_slider_style)
        self.psych_empathy_slider.setMinimumWidth(150)
        empathy_row.addWidget(self.psych_empathy_slider)
        self.psych_empathy_label = QLabel(self.psych_empathy_options[2])
        self.psych_empathy_label.setStyleSheet("font-size: 13px; font-weight: 600; color: #991b1b;")
        self.psych_empathy_slider.valueChanged.connect(lambda v: self.psych_empathy_label.setText(self.psych_empathy_options[v]))
        self.psych_empathy_slider.valueChanged.connect(self._update_psychology_preview)
        empathy_row.addWidget(self.psych_empathy_label)
        empathy_row.addStretch()
        s2_content_layout.addLayout(empathy_row)

        self.psych_offend_details = QLineEdit()
        self.psych_offend_details.setPlaceholderText("Additional context about insight into offending...")
        self.psych_offend_details.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;")
        self.psych_offend_details.textChanged.connect(self._update_psychology_preview)
        s2_content_layout.addWidget(self.psych_offend_details)

        section2_layout.addWidget(self.psych_s2_content)
        self.psych_s2_content.setVisible(False)
        content_layout.addWidget(section2_container)

        def toggle_s2():
            visible = not self.psych_s2_content.isVisible()
            self.psych_s2_content.setVisible(visible)
            self.psych_s2_btn.setText("-" if visible else "+")
        self.psych_s2_btn.clicked.connect(toggle_s2)

        # ============================================================
        # SECTION 3: ATTITUDES TO RISK FACTORS (from ASR card 5 section 3)
        # ============================================================
        section3_container = QWidget()
        section3_container.setStyleSheet("background: #f3f4f6; border-radius: 6px;")
        section3_layout = QVBoxLayout(section3_container)
        section3_layout.setContentsMargins(10, 8, 10, 8)
        section3_layout.setSpacing(6)

        section3_header = QHBoxLayout()
        self.psych_s3_btn = QPushButton("+")
        self.psych_s3_btn.setFixedSize(20, 20)
        self.psych_s3_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.psych_s3_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #374151; background: white; border: 1px solid #d1d5db; border-radius: 4px; } QPushButton:hover { background: #e5e7eb; }")
        section3_header.addWidget(self.psych_s3_btn)
        section3_title = QLabel("3. Attitudes to risk factors")
        section3_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #374151;")
        section3_header.addWidget(section3_title)
        section3_header.addStretch()
        section3_layout.addLayout(section3_header)

        self.psych_s3_content = QWidget()
        self.psych_s3_content.setVisible(False)
        s3_content_layout = QVBoxLayout(self.psych_s3_content)
        s3_content_layout.setContentsMargins(28, 4, 0, 4)
        s3_content_layout.setSpacing(4)

        # Risk factors with checkboxes and sliders - MUST match 4E RISK_KEYWORD_MAP keys
        risk_factors = [
            ("violence_others", "Violence to others"),
            ("violence_property", "Violence to property"),
            ("self_harm", "Self harm"),
            ("suicide", "Suicide/self-harm with intent"),
            ("self_neglect", "Self neglect"),
            ("sexual", "Sexual offending"),
            ("exploitation", "Exploitation/vulnerability"),
            ("substance", "Substance misuse"),
            ("stalking", "Stalking/harassment"),
            ("deterioration", "Mental state deterioration"),
            ("non_compliance", "Non-compliance/disengagement"),
        ]
        attitude_options = ["Avoids", "Limited understanding", "Some understanding", "Good understanding", "Fully understands"]

        self.psych_risk_factors = {}
        for rf_key, rf_label in risk_factors:
            rf_container = QWidget()
            rf_layout = QVBoxLayout(rf_container)
            rf_layout.setContentsMargins(0, 0, 0, 2)
            rf_layout.setSpacing(1)

            cb = QCheckBox(rf_label)
            cb.setStyleSheet("font-size: 13px; font-weight: 600; color: #374151;")
            rf_layout.addWidget(cb)

            slider_container = QWidget()
            slider_layout = QHBoxLayout(slider_container)
            slider_layout.setContentsMargins(20, 0, 0, 0)
            slider_layout.setSpacing(6)

            slider = NoWheelSlider(Qt.Orientation.Horizontal)
            slider.setRange(0, len(attitude_options) - 1)
            slider.setValue(2)
            slider.setFixedWidth(180)
            slider.setStyleSheet(slider_style)
            slider_layout.addWidget(slider)

            slider_label = QLabel(attitude_options[2])
            slider_label.setStyleSheet("font-size: 13px; font-weight: 600; color: #7c3aed;")
            slider.valueChanged.connect(lambda v, lbl=slider_label: lbl.setText(attitude_options[v]))
            slider.valueChanged.connect(self._update_psychology_preview)
            slider_layout.addWidget(slider_label)
            slider_layout.addStretch()

            slider_container.hide()
            rf_layout.addWidget(slider_container)

            cb.toggled.connect(slider_container.setVisible)
            cb.toggled.connect(self._update_psychology_preview)
            cb.toggled.connect(self._update_psych_treatment_radios)

            s3_content_layout.addWidget(rf_container)

            self.psych_risk_factors[rf_key] = {
                "checkbox": cb,
                "slider": slider,
                "slider_label": slider_label,
                "slider_container": slider_container,
                "label": rf_label
            }

        section3_layout.addWidget(self.psych_s3_content)
        content_layout.addWidget(section3_container)

        def toggle_s3():
            visible = not self.psych_s3_content.isVisible()
            self.psych_s3_content.setVisible(visible)
            self.psych_s3_btn.setText("-" if visible else "+")
        self.psych_s3_btn.clicked.connect(toggle_s3)

        # ============================================================
        # SECTION 4: TREATMENT FOR RISK FACTORS (from ASR card 5 section 4)
        # ============================================================
        section4_container = QWidget()
        section4_container.setStyleSheet("background: #f0fdf4; border-radius: 6px;")
        section4_layout = QVBoxLayout(section4_container)
        section4_layout.setContentsMargins(10, 8, 10, 8)
        section4_layout.setSpacing(6)

        section4_header = QHBoxLayout()
        self.psych_s4_btn = QPushButton("+")
        self.psych_s4_btn.setFixedSize(20, 20)
        self.psych_s4_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.psych_s4_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #166534; background: white; border: 1px solid #bbf7d0; border-radius: 4px; } QPushButton:hover { background: #dcfce7; }")
        section4_header.addWidget(self.psych_s4_btn)
        section4_title = QLabel("4. Treatment for risk factors")
        section4_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #166534;")
        section4_header.addWidget(section4_title)
        section4_header.addStretch()
        section4_layout.addLayout(section4_header)

        self.psych_s4_content = QWidget()
        self.psych_s4_content.setVisible(False)
        s4_content_layout = QVBoxLayout(self.psych_s4_content)
        s4_content_layout.setContentsMargins(28, 4, 0, 4)
        s4_content_layout.setSpacing(6)

        # Risk factor radio buttons container - 2-column grid layout
        self.psych_treatment_radios_container = QWidget()
        self.psych_treatment_radios_layout = QGridLayout(self.psych_treatment_radios_container)
        self.psych_treatment_radios_layout.setContentsMargins(0, 0, 0, 0)
        self.psych_treatment_radios_layout.setSpacing(4)
        self.psych_treatment_radios_layout.setColumnStretch(0, 1)
        self.psych_treatment_radios_layout.setColumnStretch(1, 1)
        self.psych_treatment_radio_group = QButtonGroup(popup)
        self.psych_treatment_radios = {}
        s4_content_layout.addWidget(self.psych_treatment_radios_container)

        # Placeholder
        self.psych_treatment_placeholder = QLabel("Select risk factors in Section 3 to configure treatments")
        self.psych_treatment_placeholder.setStyleSheet("color: #6b7280; font-style: italic; font-size: 13px; padding: 8px;")
        s4_content_layout.addWidget(self.psych_treatment_placeholder)

        # Treatment options container
        self.psych_treatment_options_container = QWidget()
        self.psych_treatment_options_container.setStyleSheet("""
            QWidget { background: white; border: 1px solid #e5e7eb; border-radius: 6px; }
            QLabel { background: transparent; border: none; }
            QCheckBox { background: transparent; border: none; }
        """)
        treatment_options_layout = QVBoxLayout(self.psych_treatment_options_container)
        treatment_options_layout.setContentsMargins(10, 10, 10, 10)
        treatment_options_layout.setSpacing(6)

        treatment_types = [
            ("medication", "Medication"),
            ("psych_1to1", "Psychology 1-1"),
            ("psych_groups", "Psychology groups"),
            ("nursing", "Nursing support"),
            ("ot_support", "OT support"),
            ("social_work", "Social Work"),
        ]
        effectiveness_options = ["Nil", "Minimal", "Some", "Reasonable", "Good", "Very Good", "Excellent"]

        green_slider_style = """
            QSlider::groove:horizontal { height: 6px; background: #e5e7eb; border-radius: 3px; }
            QSlider::handle:horizontal { width: 16px; margin: -5px 0; background: #059669; border-radius: 8px; }
            QSlider::sub-page:horizontal { background: #059669; border-radius: 3px; }
        """

        self.psych_treatment_widgets = {}
        for tx_key, tx_label in treatment_types:
            tx_frame = QWidget()
            tx_layout = QVBoxLayout(tx_frame)
            tx_layout.setContentsMargins(4, 4, 4, 4)
            tx_layout.setSpacing(4)

            tx_cb = QCheckBox(tx_label)
            tx_cb.setStyleSheet("font-size: 13px; font-weight: 600; color: #374151; border: none;")
            tx_layout.addWidget(tx_cb)

            tx_sliders = QWidget()
            tx_sliders_layout = QHBoxLayout(tx_sliders)
            tx_sliders_layout.setContentsMargins(16, 2, 0, 2)
            tx_sliders_layout.setSpacing(6)

            eff_lbl = QLabel("Effectiveness:")
            eff_lbl.setStyleSheet("font-size: 13px; color: #4b5563; border: none;")
            tx_sliders_layout.addWidget(eff_lbl)
            tx_eff_slider = NoWheelSlider(Qt.Orientation.Horizontal)
            tx_eff_slider.setRange(0, len(effectiveness_options) - 1)
            tx_eff_slider.setValue(0)
            tx_eff_slider.setFixedWidth(150)
            tx_eff_slider.setStyleSheet(green_slider_style)
            tx_sliders_layout.addWidget(tx_eff_slider)
            tx_eff_label = QLabel(effectiveness_options[0])
            tx_eff_label.setStyleSheet("font-size: 13px; font-weight: 600; color: #059669; border: none;")
            tx_eff_slider.valueChanged.connect(lambda v, lbl=tx_eff_label: lbl.setText(effectiveness_options[v]))
            tx_eff_slider.valueChanged.connect(self._update_psychology_preview)
            tx_sliders_layout.addWidget(tx_eff_label)
            tx_sliders_layout.addStretch()

            tx_sliders.hide()
            tx_cb.toggled.connect(tx_sliders.setVisible)
            tx_cb.toggled.connect(self._update_psychology_preview)
            tx_layout.addWidget(tx_sliders)

            treatment_options_layout.addWidget(tx_frame)

            self.psych_treatment_widgets[tx_key] = {
                "checkbox": tx_cb,
                "eff_slider": tx_eff_slider,
                "eff_label": tx_eff_label,
                "sliders_container": tx_sliders,
                "label": tx_label
            }

        self.psych_treatment_options_container.hide()
        s4_content_layout.addWidget(self.psych_treatment_options_container)

        # Treatment data storage
        self.psych_treatment_data = {}
        self.psych_current_treatment_risk = None

        section4_layout.addWidget(self.psych_s4_content)
        content_layout.addWidget(section4_container)

        def toggle_s4():
            visible = not self.psych_s4_content.isVisible()
            self.psych_s4_content.setVisible(visible)
            self.psych_s4_btn.setText("-" if visible else "+")
        self.psych_s4_btn.clicked.connect(toggle_s4)

        # ============================================================
        # SECTION 5: RELAPSE PREVENTION (from ASR card 5 section 5)
        # ============================================================
        section5_container = QWidget()
        section5_container.setStyleSheet("background: #f3f4f6; border-radius: 6px;")
        section5_layout = QVBoxLayout(section5_container)
        section5_layout.setContentsMargins(10, 8, 10, 8)
        section5_layout.setSpacing(6)

        section5_header = QHBoxLayout()
        self.psych_s5_btn = QPushButton("+")
        self.psych_s5_btn.setFixedSize(20, 20)
        self.psych_s5_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.psych_s5_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #374151; background: white; border: 1px solid #d1d5db; border-radius: 4px; } QPushButton:hover { background: #e5e7eb; }")
        section5_header.addWidget(self.psych_s5_btn)
        section5_title = QLabel("5. Relapse prevention")
        section5_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #374151;")
        section5_header.addWidget(section5_title)
        section5_header.addStretch()
        section5_layout.addLayout(section5_header)

        self.psych_s5_content = QWidget()
        s5_content_layout = QVBoxLayout(self.psych_s5_content)
        s5_content_layout.setContentsMargins(28, 4, 0, 4)
        s5_content_layout.setSpacing(4)

        self.psych_relapse_options = ["Not started", "Just started", "Ongoing", "Significant progression", "Almost completed", "Completed"]
        relapse_row = QHBoxLayout()
        self.psych_relapse_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.psych_relapse_slider.setRange(0, len(self.psych_relapse_options) - 1)
        self.psych_relapse_slider.setValue(0)
        self.psych_relapse_slider.setStyleSheet(slider_style)
        self.psych_relapse_slider.setMinimumWidth(180)
        relapse_row.addWidget(self.psych_relapse_slider)
        self.psych_relapse_label = QLabel(self.psych_relapse_options[0])
        self.psych_relapse_label.setStyleSheet("font-size: 13px; font-weight: 600; color: #7c3aed;")
        self.psych_relapse_slider.valueChanged.connect(lambda v: self.psych_relapse_label.setText(self.psych_relapse_options[v]))
        self.psych_relapse_slider.valueChanged.connect(self._update_psychology_preview)
        relapse_row.addWidget(self.psych_relapse_label)
        relapse_row.addStretch()
        s5_content_layout.addLayout(relapse_row)

        section5_layout.addWidget(self.psych_s5_content)
        self.psych_s5_content.setVisible(False)
        content_layout.addWidget(section5_container)

        def toggle_s5():
            visible = not self.psych_s5_content.isVisible()
            self.psych_s5_content.setVisible(visible)
            self.psych_s5_btn.setText("-" if visible else "+")
        self.psych_s5_btn.clicked.connect(toggle_s5)

        # ============================================================
        # SECTION 6: CURRENT ENGAGEMENT
        # ============================================================
        section6_container = QWidget()
        section6_container.setStyleSheet("background: #eff6ff; border-radius: 6px;")
        section6_layout = QVBoxLayout(section6_container)
        section6_layout.setContentsMargins(10, 8, 10, 8)
        section6_layout.setSpacing(6)

        section6_header = QHBoxLayout()
        self.psych_s6_btn = QPushButton("+")
        self.psych_s6_btn.setFixedSize(20, 20)
        self.psych_s6_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.psych_s6_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #1e40af; background: white; border: 1px solid #bfdbfe; border-radius: 4px; } QPushButton:hover { background: #dbeafe; }")
        section6_header.addWidget(self.psych_s6_btn)
        section6_title = QLabel("6. Current Engagement")
        section6_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #1e40af;")
        section6_header.addWidget(section6_title)
        section6_header.addStretch()
        section6_layout.addLayout(section6_header)

        self.psych_s6_content = QWidget()
        s6_content_layout = QVBoxLayout(self.psych_s6_content)
        s6_content_layout.setContentsMargins(28, 4, 0, 4)
        s6_content_layout.setSpacing(4)

        # Engagement checkboxes in grid
        engagement_items = [
            ("one_to_one", "1-1"),
            ("risk", "Risk"),
            ("insight", "Insight"),
            ("psychoeducation", "Psychoeducation"),
            ("managing_emotions", "Managing emotions"),
            ("drugs_alcohol", "Drugs and alcohol"),
            ("carepathway", "Care pathway"),
            ("discharge_planning", "Discharge planning"),
            ("schema_therapy", "Schema therapy"),
            ("sotp", "SOTP"),
        ]

        eng_grid_widget = QWidget()
        eng_grid = QGridLayout(eng_grid_widget)
        eng_grid.setContentsMargins(0, 2, 0, 2)
        eng_grid.setSpacing(4)

        self.psych_engagement_checkboxes = {}
        for i, (key, label) in enumerate(engagement_items):
            cb = QCheckBox(label)
            cb.setStyleSheet("font-size: 13px; color: #374151;")
            cb.toggled.connect(self._update_psych_outstanding_needs)
            cb.toggled.connect(self._update_psychology_preview)
            eng_grid.addWidget(cb, i // 3, i % 3)  # 3 columns instead of 5
            self.psych_engagement_checkboxes[key] = cb

        s6_content_layout.addWidget(eng_grid_widget)
        section6_layout.addWidget(self.psych_s6_content)
        self.psych_s6_content.setVisible(False)
        content_layout.addWidget(section6_container)

        def toggle_s6():
            visible = not self.psych_s6_content.isVisible()
            self.psych_s6_content.setVisible(visible)
            self.psych_s6_btn.setText("-" if visible else "+")
        self.psych_s6_btn.clicked.connect(toggle_s6)

        # ============================================================
        # SECTION 7: OUTSTANDING NEEDS
        # ============================================================
        section7_container = QWidget()
        section7_container.setStyleSheet("background: #fefce8; border-radius: 6px;")
        section7_layout = QVBoxLayout(section7_container)
        section7_layout.setContentsMargins(10, 8, 10, 8)
        section7_layout.setSpacing(6)

        section7_header = QHBoxLayout()
        self.psych_s7_btn = QPushButton("+")
        self.psych_s7_btn.setFixedSize(20, 20)
        self.psych_s7_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.psych_s7_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #854d0e; background: white; border: 1px solid #fef08a; border-radius: 4px; } QPushButton:hover { background: #fef9c3; }")
        section7_header.addWidget(self.psych_s7_btn)
        section7_title = QLabel("7. Outstanding Needs")
        section7_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #854d0e;")
        section7_header.addWidget(section7_title)
        section7_header.addStretch()
        section7_layout.addLayout(section7_header)

        self.psych_s7_content = QWidget()
        s7_content_layout = QVBoxLayout(self.psych_s7_content)
        s7_content_layout.setContentsMargins(28, 4, 0, 4)
        s7_content_layout.setSpacing(4)

        # Outstanding needs checkboxes (same items, will be greyed out based on section 6)
        needs_grid_widget = QWidget()
        needs_grid = QGridLayout(needs_grid_widget)
        needs_grid.setContentsMargins(0, 2, 0, 2)
        needs_grid.setSpacing(4)

        self.psych_outstanding_checkboxes = {}
        for i, (key, label) in enumerate(engagement_items):
            cb = QCheckBox(label)
            cb.setStyleSheet("font-size: 13px; color: #374151;")
            cb.toggled.connect(self._update_psychology_preview)
            needs_grid.addWidget(cb, i // 5, i % 5)
            self.psych_outstanding_checkboxes[key] = cb

        s7_content_layout.addWidget(needs_grid_widget)
        section7_layout.addWidget(self.psych_s7_content)
        self.psych_s7_content.setVisible(False)
        content_layout.addWidget(section7_container)

        def toggle_s7():
            visible = not self.psych_s7_content.isVisible()
            self.psych_s7_content.setVisible(visible)
            self.psych_s7_btn.setText("-" if visible else "+")
        self.psych_s7_btn.clicked.connect(toggle_s7)

        content_layout.addStretch()
        content_scroll.setWidget(content_widget)
        main_layout.addWidget(content_scroll)

        # Register popup generator
        def generate_psychology_text():
            return self.psychology_preview.text().strip()
        self.popup_generators["psychology"] = generate_psychology_text

        # Initial preview update
        self._update_psychology_preview()

        # Apply stored index offence work value if available (from data import)
        if hasattr(self, '_extracted_index_offence_work') and self._extracted_index_offence_work is not None:
            from PySide6.QtCore import QTimer
            def apply_stored_index_offence():
                io_value = self._extracted_index_offence_work
                if hasattr(self, 'psych_index_slider') and self.psych_index_slider:
                    self.psych_index_slider.setValue(io_value)
                    io_options = getattr(self, 'psych_index_options', ["None", "Considering", "Starting", "Engaging", "Well Engaged", "Almost Complete", "Complete"])
                    io_label = io_options[io_value] if 0 <= io_value < len(io_options) else str(io_value)
                    if hasattr(self, 'psych_index_label') and self.psych_index_label:
                        self.psych_index_label.setText(io_label)
                    print(f"[MOJ-LEAVE] 4g popup: Applied stored index offence work: {io_value} ({io_label})")
                    self._update_psychology_preview()
            QTimer.singleShot(100, apply_stored_index_offence)

        # Apply stored Section 2 values (insight, responsibility, empathy)
        from PySide6.QtCore import QTimer
        def apply_stored_section2():
            updated = False

            # Insight into offending
            if hasattr(self, '_extracted_offend_insight') and self._extracted_offend_insight is not None:
                insight_val = self._extracted_offend_insight
                if hasattr(self, 'psych_offend_insight_slider') and self.psych_offend_insight_slider:
                    self.psych_offend_insight_slider.setValue(insight_val)
                    insight_opts = getattr(self, 'psych_offend_insight_options', ["Nil", "Limited", "Partial", "Good", "Full"])
                    insight_label = insight_opts[insight_val] if 0 <= insight_val < len(insight_opts) else str(insight_val)
                    if hasattr(self, 'psych_offend_insight_label') and self.psych_offend_insight_label:
                        self.psych_offend_insight_label.setText(insight_label)
                    print(f"[MOJ-LEAVE] 4g popup: Applied stored insight into offending: {insight_val} ({insight_label})")
                    updated = True

            # Accepts responsibility
            if hasattr(self, '_extracted_responsibility') and self._extracted_responsibility is not None:
                resp_val = self._extracted_responsibility
                if hasattr(self, 'psych_responsibility_slider') and self.psych_responsibility_slider:
                    self.psych_responsibility_slider.setValue(resp_val)
                    resp_opts = getattr(self, 'psych_responsibility_options', ["Denies", "Minimises", "Partial", "Mostly", "Full"])
                    resp_label = resp_opts[resp_val] if 0 <= resp_val < len(resp_opts) else str(resp_val)
                    if hasattr(self, 'psych_responsibility_label') and self.psych_responsibility_label:
                        self.psych_responsibility_label.setText(resp_label)
                    print(f"[MOJ-LEAVE] 4g popup: Applied stored responsibility: {resp_val} ({resp_label})")
                    updated = True

            # Victim empathy
            if hasattr(self, '_extracted_victim_empathy') and self._extracted_victim_empathy is not None:
                empathy_val = self._extracted_victim_empathy
                if hasattr(self, 'psych_empathy_slider') and self.psych_empathy_slider:
                    self.psych_empathy_slider.setValue(empathy_val)
                    empathy_opts = getattr(self, 'psych_empathy_options', ["Nil", "Limited", "Developing", "Good", "Full"])
                    empathy_label = empathy_opts[empathy_val] if 0 <= empathy_val < len(empathy_opts) else str(empathy_val)
                    if hasattr(self, 'psych_empathy_label') and self.psych_empathy_label:
                        self.psych_empathy_label.setText(empathy_label)
                    print(f"[MOJ-LEAVE] 4g popup: Applied stored victim empathy: {empathy_val} ({empathy_label})")
                    updated = True

            if updated:
                self._update_psychology_preview()

        QTimer.singleShot(150, apply_stored_section2)

        # Apply stored Sections 3-7 values (risk attitudes, relapse, engagement, outstanding)
        def apply_stored_sections_3_7():
            updated = False
            attitude_options = ["Avoids", "Limited understanding", "Some understanding", "Good understanding", "Fully understands"]

            # IMPORTANT: Populate Section 4 treatment data FIRST before checking Section 3 boxes
            # (checking boxes triggers _update_psych_treatment_radios which needs the data)
            if hasattr(self, '_extracted_treatments') and self._extracted_treatments:
                effectiveness_options = ["Nil", "Minimal", "Some", "Reasonable", "Good", "Very Good", "Excellent"]
                for rf_key, tx_data in self._extracted_treatments.items():
                    if rf_key not in self.psych_treatment_data:
                        self.psych_treatment_data[rf_key] = {"treatments": {}}
                    tx_details = []
                    for tx_key, tx_vals in tx_data.items():
                        eff_val = tx_vals.get("effectiveness", 0)
                        self.psych_treatment_data[rf_key]["treatments"][tx_key] = {
                            "checked": tx_vals.get("checked", False),
                            "effectiveness": eff_val
                        }
                        eff_label = effectiveness_options[eff_val] if 0 <= eff_val < len(effectiveness_options) else str(eff_val)
                        tx_details.append(f"{tx_key}={eff_label}")
                    print(f"[MOJ-LEAVE] 4g popup: Pre-loaded {rf_key} treatments: {', '.join(tx_details)}")
                    updated = True

            # Section 3: Risk Attitudes (AFTER Section 4 data is populated)
            if hasattr(self, '_extracted_risk_attitudes') and self._extracted_risk_attitudes:
                for rf_key, rf_data in self._extracted_risk_attitudes.items():
                    if rf_key in self.psych_risk_factors:
                        rf_widgets = self.psych_risk_factors[rf_key]
                        if rf_data.get("checked"):
                            rf_widgets["checkbox"].setChecked(True)
                        attitude_val = rf_data.get("attitude", 2)
                        rf_widgets["slider"].setValue(attitude_val)
                        rf_widgets["slider_label"].setText(attitude_options[attitude_val] if 0 <= attitude_val < len(attitude_options) else str(attitude_val))
                        print(f"[MOJ-LEAVE] 4g popup: Applied {rf_key} attitude: {attitude_val}")
                        updated = True

            # Force refresh of treatment radios after all data is loaded
            if hasattr(self, '_update_psych_treatment_radios'):
                self._update_psych_treatment_radios()

            # Section 5: Relapse Prevention
            if hasattr(self, '_extracted_relapse') and self._extracted_relapse is not None:
                relapse_val = self._extracted_relapse
                if hasattr(self, 'psych_relapse_slider') and self.psych_relapse_slider:
                    self.psych_relapse_slider.setValue(relapse_val)
                    relapse_opts = getattr(self, 'psych_relapse_options', ["Not started", "Just started", "Ongoing", "Significant progression", "Almost completed", "Completed"])
                    relapse_label = relapse_opts[relapse_val] if 0 <= relapse_val < len(relapse_opts) else str(relapse_val)
                    if hasattr(self, 'psych_relapse_label') and self.psych_relapse_label:
                        self.psych_relapse_label.setText(relapse_label)
                    print(f"[MOJ-LEAVE] 4g popup: Applied relapse prevention: {relapse_val} ({relapse_label})")
                    updated = True

            # Section 6: Current Engagement
            if hasattr(self, '_extracted_engagement') and self._extracted_engagement:
                for eng_key, is_engaged in self._extracted_engagement.items():
                    if eng_key in self.psych_engagement_checkboxes and is_engaged:
                        self.psych_engagement_checkboxes[eng_key].setChecked(True)
                        print(f"[MOJ-LEAVE] 4g popup: Applied engagement: {eng_key}")
                        updated = True

            # Section 7: Outstanding Needs
            if hasattr(self, '_extracted_outstanding') and self._extracted_outstanding:
                for need_key, is_needed in self._extracted_outstanding.items():
                    if need_key in self.psych_outstanding_checkboxes and is_needed:
                        self.psych_outstanding_checkboxes[need_key].setChecked(True)
                        print(f"[MOJ-LEAVE] 4g popup: Applied outstanding need: {need_key}")
                        updated = True

            if updated:
                self._update_psychology_preview()

        QTimer.singleShot(200, apply_stored_sections_3_7)

        return popup

    def _update_psych_treatment_radios(self):
        """Update treatment risk radio buttons based on selected risk factors in Section 3."""
        # Save current state before clearing
        if hasattr(self, 'psych_current_treatment_risk') and self.psych_current_treatment_risk:
            self._save_psych_treatment_state(self.psych_current_treatment_risk)

        # Clear existing radios
        for radio in self.psych_treatment_radios.values():
            self.psych_treatment_radio_group.removeButton(radio)
            radio.deleteLater()
        self.psych_treatment_radios.clear()

        # Clear layout
        while self.psych_treatment_radios_layout.count():
            item = self.psych_treatment_radios_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Get selected risk factors
        selected_risks = []
        for key, rf_data in self.psych_risk_factors.items():
            if rf_data["checkbox"].isChecked():
                selected_risks.append((key, rf_data["label"]))

        if not selected_risks:
            self.psych_treatment_placeholder.show()
            self.psych_treatment_options_container.hide()
            self.psych_current_treatment_risk = None
            return

        self.psych_treatment_placeholder.hide()

        # Create radio buttons for each selected risk - 2-column grid layout
        for idx, (key, label) in enumerate(selected_risks):
            radio = QRadioButton(label)
            radio.setStyleSheet("QRadioButton { font-size: 14px; font-weight: 600; color: #374151; padding: 6px 12px; } QRadioButton:checked { color: #059669; }")
            radio.toggled.connect(lambda checked, k=key: self._on_psych_treatment_risk_changed(k) if checked else None)
            self.psych_treatment_radio_group.addButton(radio)
            self.psych_treatment_radios[key] = radio
            # Place in 2-column grid: row = idx // 2, col = idx % 2
            row = idx // 2
            col = idx % 2
            self.psych_treatment_radios_layout.addWidget(radio, row, col)

        # Select first radio by default
        if selected_risks:
            first_key = selected_risks[0][0]
            self.psych_treatment_radios[first_key].setChecked(True)

    def _on_psych_treatment_risk_changed(self, risk_key):
        """Handle switching between risk factor treatment tabs."""
        if hasattr(self, 'psych_current_treatment_risk') and self.psych_current_treatment_risk and self.psych_current_treatment_risk != risk_key:
            self._save_psych_treatment_state(self.psych_current_treatment_risk)

        self.psych_current_treatment_risk = risk_key
        self.psych_treatment_options_container.show()
        self._restore_psych_treatment_state(risk_key)

    def _save_psych_treatment_state(self, risk_key):
        """Save current treatment widget state for a risk factor."""
        if risk_key not in self.psych_treatment_data:
            self.psych_treatment_data[risk_key] = {"treatments": {}}

        for tx_key, tx_widgets in self.psych_treatment_widgets.items():
            self.psych_treatment_data[risk_key]["treatments"][tx_key] = {
                "checked": tx_widgets["checkbox"].isChecked(),
                "effectiveness": tx_widgets["eff_slider"].value()
            }

    def _restore_psych_treatment_state(self, risk_key):
        """Restore treatment widget state for a risk factor."""
        effectiveness_options = ["Nil", "Minimal", "Some", "Reasonable", "Good", "Very Good", "Excellent"]

        if risk_key in self.psych_treatment_data:
            data = self.psych_treatment_data[risk_key]
            for tx_key, tx_widgets in self.psych_treatment_widgets.items():
                if tx_key in data["treatments"]:
                    tx_widgets["checkbox"].blockSignals(True)
                    tx_widgets["eff_slider"].blockSignals(True)
                    tx_widgets["checkbox"].setChecked(data["treatments"][tx_key]["checked"])
                    eff_val = data["treatments"][tx_key]["effectiveness"]
                    tx_widgets["eff_slider"].setValue(eff_val)
                    # Manually update label since signals are blocked
                    if "eff_label" in tx_widgets:
                        tx_widgets["eff_label"].setText(effectiveness_options[eff_val] if 0 <= eff_val < len(effectiveness_options) else str(eff_val))
                    tx_widgets["sliders_container"].setVisible(data["treatments"][tx_key]["checked"])
                    tx_widgets["checkbox"].blockSignals(False)
                    tx_widgets["eff_slider"].blockSignals(False)
                else:
                    # Reset this treatment if not in data
                    tx_widgets["checkbox"].blockSignals(True)
                    tx_widgets["eff_slider"].blockSignals(True)
                    tx_widgets["checkbox"].setChecked(False)
                    tx_widgets["eff_slider"].setValue(0)
                    if "eff_label" in tx_widgets:
                        tx_widgets["eff_label"].setText(effectiveness_options[0])
                    tx_widgets["sliders_container"].hide()
                    tx_widgets["checkbox"].blockSignals(False)
                    tx_widgets["eff_slider"].blockSignals(False)
        else:
            # Reset all to defaults
            for tx_widgets in self.psych_treatment_widgets.values():
                tx_widgets["checkbox"].blockSignals(True)
                tx_widgets["eff_slider"].blockSignals(True)
                tx_widgets["checkbox"].setChecked(False)
                tx_widgets["eff_slider"].setValue(0)
                # Manually update label since signals are blocked
                if "eff_label" in tx_widgets:
                    tx_widgets["eff_label"].setText(effectiveness_options[0])
                tx_widgets["sliders_container"].hide()
                tx_widgets["checkbox"].blockSignals(False)
                tx_widgets["eff_slider"].blockSignals(False)

    def _update_psych_outstanding_needs(self):
        """Grey out items in Outstanding Needs (section 7) that are checked in Current Engagement (section 6)."""
        if not hasattr(self, 'psych_engagement_checkboxes') or not hasattr(self, 'psych_outstanding_checkboxes'):
            return

        for key, eng_cb in self.psych_engagement_checkboxes.items():
            if key in self.psych_outstanding_checkboxes:
                needs_cb = self.psych_outstanding_checkboxes[key]
                if eng_cb.isChecked():
                    # Grey out and uncheck the corresponding outstanding needs checkbox
                    needs_cb.setEnabled(False)
                    needs_cb.setChecked(False)
                    needs_cb.setStyleSheet("font-size: 14px; color: #9ca3af;")
                else:
                    # Re-enable the checkbox
                    needs_cb.setEnabled(True)
                    needs_cb.setStyleSheet("font-size: 14px; color: #374151;")

    def _update_psychology_preview(self):
        """Update the psychology preview text with natural flowing language."""
        if not hasattr(self, 'psychology_preview'):
            return

        # Save current treatment state before generating preview
        if hasattr(self, 'psych_current_treatment_risk') and self.psych_current_treatment_risk:
            self._save_psych_treatment_state(self.psych_current_treatment_risk)

        p = self._get_pronouns()
        parts = []

        # Gather data for combined output
        idx_val = self.psych_index_slider.value() if hasattr(self, 'psych_index_slider') else 0
        idx_details = self.psych_index_details.text().strip() if hasattr(self, 'psych_index_details') else ""
        insight_val = self.psych_offend_insight_slider.value() if hasattr(self, 'psych_offend_insight_slider') else 0
        resp_val = self.psych_responsibility_slider.value() if hasattr(self, 'psych_responsibility_slider') else 0
        empathy_val = self.psych_empathy_slider.value() if hasattr(self, 'psych_empathy_slider') else 0
        offend_details = self.psych_offend_details.text().strip() if hasattr(self, 'psych_offend_details') else ""

        # Combined Section 1+2: Index offence work + insight + responsibility + empathy
        # Build a flowing sentence combining these elements
        idx_phrases = {
            0: f"{p['subj']} {p['has']} not started work to address the index offence",
            1: f"{p['subj']} {p['is']} considering work to address the index offence",
            2: f"{p['subj']} {p['is']} starting work to address the index offence",
            3: f"{p['subj']} {p['is']} engaging in work to address the index offence",
            4: f"{p['subj']} {p['is']} well engaged in work to address the index offence",
            5: f"{p['subj']} {p['has']} almost completed work to address the index offence",
            6: f"{p['subj']} {p['has']} completed work to address the index offence"
        }

        insight_text = self.psych_offend_insight_options[insight_val].lower() if hasattr(self, 'psych_offend_insight_options') else "no"
        resp_text = self.psych_responsibility_options[resp_val].lower() if hasattr(self, 'psych_responsibility_options') else "no"

        # Build combined first sentence
        idx_phrase = idx_phrases.get(idx_val, idx_phrases[0])

        # Insight continuation
        if insight_val == 0:
            insight_cont = "with no insight into this"
        elif insight_val <= 2:
            insight_cont = f"with {insight_text} insight into this"
        else:
            insight_cont = f"with {insight_text} insight"

        # Responsibility continuation
        if resp_val == 0:
            resp_cont = "not accepting any responsibility"
        elif resp_val == 1:
            resp_cont = "minimising responsibility"
        elif resp_val == 2:
            resp_cont = "only accepting partial responsibility"
        elif resp_val == 3:
            resp_cont = "mostly accepting responsibility"
        else:
            resp_cont = f"accepting {resp_text} responsibility"

        # Empathy
        if empathy_val == 0:
            empathy_cont = f"{p['subj']} {p['has']} no victim empathy"
        elif empathy_val == 1:
            empathy_cont = f"{p['subj']} {p['has']} limited victim empathy"
        elif empathy_val == 2:
            empathy_cont = f"{p['subj']} {p['is']} developing victim empathy"
        else:
            empathy_text = self.psych_empathy_options[empathy_val].lower() if hasattr(self, 'psych_empathy_options') else "good"
            empathy_cont = f"{p['subj']} {p['has']} {empathy_text} victim empathy"

        # Combine into natural sentence
        parts.append(f"{idx_phrase}, {insight_cont} and {resp_cont}. {empathy_cont}.")

        if idx_details:
            parts.append(idx_details)
        if offend_details:
            parts.append(offend_details)

        # Section 3+4 Combined: Risk factors with understanding AND treatment effectiveness together
        if hasattr(self, 'psych_risk_factors'):
            # Collect risk data: {risk_key: {"label": str, "understanding": int, "treatments": [(tx_label, eff_val)]}}
            risk_data_combined = {}
            for key, rf_data in self.psych_risk_factors.items():
                if rf_data["checkbox"].isChecked():
                    risk_data_combined[key] = {
                        "label": rf_data["label"].lower(),
                        "understanding": rf_data["slider"].value(),
                        "treatments": []
                    }

            # Add treatment data
            if hasattr(self, 'psych_treatment_data') and self.psych_treatment_data:
                for risk_key, tx_risk_data in self.psych_treatment_data.items():
                    if risk_key in risk_data_combined and "treatments" in tx_risk_data:
                        for tx_key, tx_data in tx_risk_data["treatments"].items():
                            if tx_data.get("checked"):
                                tx_label = self.psych_treatment_widgets[tx_key]["label"] if tx_key in self.psych_treatment_widgets else tx_key
                                eff_val = tx_data.get("effectiveness", 0)
                                risk_data_combined[risk_key]["treatments"].append((tx_label, eff_val))

            # Sort risks by understanding level (highest first)
            sorted_risks = sorted(risk_data_combined.items(), key=lambda x: x[1]["understanding"], reverse=True)

            if sorted_risks:
                # Verb conjugations for they vs he/she
                avoid_verb = "avoid" if p['subj'].lower() == "they" else "avoids"
                have_verb = "have" if p['subj'].lower() == "they" else "has"

                # Helper to determine has/have for treatment names
                def tx_verb(tx_text):
                    """Return 'have' for plural treatments, 'has' for singular."""
                    # Plural if contains " and " (multiple treatments) or ends with "groups"
                    if " and " in tx_text or tx_text.lower().endswith("groups"):
                        return "have"
                    return "has"

                # Effectiveness descriptions - use "helpful" style language
                # 0=nil, 1=minimal, 2=some, 3=reasonable, 4=good, 5=very good, 6=excellent
                effectiveness_helpful = ["not been helpful", "had minimal effect", "been somewhat helpful",
                                        "been reasonably helpful", "been helpful", "been very helpful", "been highly effective"]
                effectiveness_labels = ["not been effective", "had minimal effect", "had some effect",
                                       "been reasonably effective", "been effective", "been very effective", "been highly effective"]
                understanding_labels = {0: f"{avoid_verb} discussing", 1: "limited understanding of", 2: "some understanding of",
                                       3: "good understanding of", 4: "full understanding of"}

                risk_phrases = []
                for i, (risk_key, rdata) in enumerate(sorted_risks):
                    risk_label = rdata["label"]
                    und_level = rdata["understanding"]
                    treatments = rdata["treatments"]

                    # Add treatment effectiveness if present
                    if treatments:
                        # Group treatments by effectiveness
                        eff_groups = {}
                        for tx_label, eff_val in treatments:
                            if eff_val not in eff_groups:
                                eff_groups[eff_val] = []
                            eff_groups[eff_val].append(tx_label)

                        tx_parts = []
                        for eff_val in sorted(eff_groups.keys(), reverse=True):
                            tx_list = eff_groups[eff_val]
                            tx_text = " and ".join(tx_list) if len(tx_list) <= 2 else ", ".join(tx_list[:-1]) + " and " + tx_list[-1]
                            eff_phrase = effectiveness_helpful[eff_val]
                            tx_parts.append((tx_text, eff_phrase, eff_val))

                        # Special handling for und_level == 0 (avoids discussing)
                        if und_level == 0:
                            if len(tx_parts) == 1:
                                tx_text, eff_phrase, eff_val = tx_parts[0]
                                phrase = f"{tx_text} {tx_verb(tx_text)} {eff_phrase} for {p['pos'].lower()} {risk_label}, but {p['subj'].lower()} {avoid_verb} discussing this risk"
                            else:
                                # Multiple treatments with different effectiveness
                                phrase_parts = []
                                for tx_text, eff_phrase, eff_val in tx_parts:
                                    phrase_parts.append(f"{tx_text} {tx_verb(tx_text)} {eff_phrase}")
                                phrase = " and ".join(phrase_parts) + f" for {p['pos'].lower()} {risk_label}, but {p['subj'].lower()} {avoid_verb} discussing this risk"
                        else:
                            # Normal understanding levels (1-4)
                            und_phrase = f"{p['subj']} {have_verb} {understanding_labels[und_level]} {p['pos'].lower()} {risk_label}"

                            if len(tx_parts) == 1:
                                tx_text, eff_phrase, eff_val = tx_parts[0]
                                if eff_val <= 1:  # nil or minimal - treatment not effective
                                    if und_level >= 3:  # good understanding but poor treatment
                                        phrase = f"{und_phrase}, but {tx_text} {tx_verb(tx_text)} {eff_phrase} in changing this"
                                    else:  # limited/some understanding and poor treatment
                                        phrase = f"{und_phrase}, and {tx_text} {tx_verb(tx_text)} {eff_phrase}"
                                else:  # treatment somewhat effective
                                    phrase = f"{und_phrase}, and {tx_text} {tx_verb(tx_text)} {eff_phrase}"
                            else:
                                # Multiple effectiveness levels for same risk
                                phrase = und_phrase
                                for j, (tx_text, eff_phrase, eff_val) in enumerate(tx_parts):
                                    connector = ", and " if j == 0 else " while "
                                    phrase += f"{connector}{tx_text} {tx_verb(tx_text)} {eff_phrase}"
                    else:
                        # No treatments - just understanding
                        if und_level == 0:
                            phrase = f"{p['subj']} {avoid_verb} discussing {p['pos'].lower()} {risk_label}"
                        else:
                            phrase = f"{p['subj']} {have_verb} {understanding_labels[und_level]} {p['pos'].lower()} {risk_label}"

                    risk_phrases.append(phrase)

                # Join all risk phrases
                if risk_phrases:
                    intro = "Regarding risk factors: "
                    if len(risk_phrases) == 1:
                        parts.append(f"{intro}{risk_phrases[0]}.")
                    else:
                        # Varied connectors for subsequent risks
                        connectors = [
                            "Additionally",
                            "Furthermore",
                            "In addition",
                            "Moreover",
                            "With respect to other risks",
                            "Concerning other factors",
                            "Separately"
                        ]
                        parts.append(f"{intro}{risk_phrases[0]}.")
                        for idx, phrase in enumerate(risk_phrases[1:]):
                            # Pick connector based on index, cycling through options
                            connector = connectors[idx % len(connectors)]
                            # Make phrase start with lowercase if it begins with pronoun
                            if phrase.startswith(p['subj']):
                                phrase = phrase[0].lower() + phrase[1:]
                                parts.append(f"{connector}, {phrase}.")
                            else:
                                # Phrase starts with treatment name - adjust connector
                                parts.append(f"{connector}, {phrase[0].lower() + phrase[1:]}.")

        # Section 5: Relapse prevention
        if hasattr(self, 'psych_relapse_slider'):
            relapse_val = self.psych_relapse_slider.value()
            have_verb = "have" if p['subj'].lower() == "they" else "has"
            relapse_phrases = {
                0: f"{p['subj']} {have_verb} not started relapse prevention work.",
                1: f"{p['subj']} {have_verb} just started {p['pos'].lower()} relapse prevention work.",
                2: f"{p['subj']} {have_verb} ongoing relapse prevention work.",
                3: f"{p['subj']} {have_verb} made significant progression in {p['pos'].lower()} relapse prevention work.",
                4: f"{p['subj']} {have_verb} almost completed {p['pos'].lower()} relapse prevention work.",
                5: f"{p['subj']} {have_verb} completed {p['pos'].lower()} relapse prevention work."
            }
            parts.append(relapse_phrases.get(relapse_val, ""))

        # Section 6: Current Engagement
        if hasattr(self, 'psych_engagement_checkboxes'):
            engaged_items = []
            for key, cb in self.psych_engagement_checkboxes.items():
                if cb.isChecked():
                    engaged_items.append(cb.text().lower())

            if engaged_items:
                items_text = " and ".join(engaged_items) if len(engaged_items) <= 2 else ", ".join(engaged_items[:-1]) + " and " + engaged_items[-1]
                parts.append(f"{p['subj']} {p['is']} currently engaged in work for {items_text}.")

        # Section 7: Outstanding Needs
        if hasattr(self, 'psych_outstanding_checkboxes'):
            outstanding_items = []
            for key, cb in self.psych_outstanding_checkboxes.items():
                if cb.isChecked() and cb.isEnabled():
                    outstanding_items.append(cb.text().lower())

            if outstanding_items:
                items_text = " and ".join(outstanding_items) if len(outstanding_items) <= 2 else ", ".join(outstanding_items[:-1]) + " and " + outstanding_items[-1]
                parts.append(f"Outstanding psychological needs include {items_text}.")

        if parts:
            text = " ".join(parts)
            self.psychology_preview.setText(text)
            # Auto-sync to card - preserve user additions
            if "psychology" in self.cards:
                self._update_text_preserving_additions(self.cards["psychology"].editor, text, "psychology")
        else:
            self.psychology_preview.setText("")

    def _create_extremism_popup(self) -> QWidget:
        """Create Extremism popup with sliders, tickboxes, and text fields."""
        key = "extremism"
        popup = QWidget()
        popup.setObjectName(f"popup_{key}")
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)

        # Hidden label to store text for auto-sync to card
        self.extremism_preview = QLabel()
        self.extremism_preview.hide()

        # === CONTENT PANEL ===
        content_scroll = QScrollArea()
        content_scroll.setWidgetResizable(True)
        content_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        content_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        content_scroll.setStyleSheet("QScrollArea { background: transparent; border: none; }")

        content_widget = QWidget()
        content_widget.setStyleSheet("background: transparent;")
        content_layout = QVBoxLayout(content_widget)
        content_layout.setContentsMargins(8, 8, 8, 8)
        content_layout.setSpacing(10)

        # ============================================================
        # EXTREMISM IS A CONCERN: Yes / N/A (like 3f)
        # ============================================================
        concern_frame = QWidget()
        concern_frame.setStyleSheet("background: #fef2f2; border-radius: 6px;")
        concern_layout = QVBoxLayout(concern_frame)
        concern_layout.setContentsMargins(12, 10, 12, 10)
        concern_layout.setSpacing(8)

        concern_lbl = QLabel("<b>Extremism is a concern:</b>")
        concern_lbl.setStyleSheet("font-size: 14px; color: #991b1b;")
        concern_layout.addWidget(concern_lbl)

        concern_row = QHBoxLayout()
        self.extremism_concern_group = QButtonGroup(popup)
        self.extremism_concern_yes = QRadioButton("Yes")
        self.extremism_concern_na = QRadioButton("N/A")
        self.extremism_concern_na.setChecked(True)  # Default to N/A
        self.extremism_concern_yes.setStyleSheet("font-size: 13px;")
        self.extremism_concern_na.setStyleSheet("font-size: 13px;")
        self.extremism_concern_group.addButton(self.extremism_concern_yes)
        self.extremism_concern_group.addButton(self.extremism_concern_na)
        concern_row.addWidget(self.extremism_concern_yes)
        concern_row.addWidget(self.extremism_concern_na)
        concern_row.addStretch()
        concern_layout.addLayout(concern_row)

        content_layout.addWidget(concern_frame)

        # ============================================================
        # COLLAPSIBLE EXTREMISM DETAILS CONTAINER (shown when Yes)
        # ============================================================
        self.extremism_details_container = QWidget()
        extremism_details_layout = QVBoxLayout(self.extremism_details_container)
        extremism_details_layout.setContentsMargins(0, 0, 0, 0)
        extremism_details_layout.setSpacing(8)

        extremism_container = QWidget()
        extremism_container.setStyleSheet("background: #fef2f2; border-radius: 6px;")
        extremism_main_layout = QVBoxLayout(extremism_container)
        extremism_main_layout.setContentsMargins(10, 8, 10, 8)
        extremism_main_layout.setSpacing(6)

        # Header with collapse button
        header_layout = QHBoxLayout()
        self.extremism_collapse_btn = QPushButton("-")
        self.extremism_collapse_btn.setFixedSize(20, 20)
        self.extremism_collapse_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.extremism_collapse_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #991b1b; background: white; border: 1px solid #fecaca; border-radius: 4px; } QPushButton:hover { background: #fee2e2; }")
        header_layout.addWidget(self.extremism_collapse_btn)
        header_title = QLabel("Extremism Assessment Details")
        header_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #991b1b;")
        header_layout.addWidget(header_title)
        header_layout.addStretch()
        extremism_main_layout.addLayout(header_layout)

        # Collapsible content
        self.extremism_content = QWidget()
        extremism_content_layout = QVBoxLayout(self.extremism_content)
        extremism_content_layout.setContentsMargins(28, 4, 0, 4)
        extremism_content_layout.setSpacing(8)

        slider_style = """
            QSlider::groove:horizontal { height: 6px; background: #e5e7eb; border-radius: 3px; }
            QSlider::handle:horizontal { width: 16px; margin: -5px 0; background: #991b1b; border-radius: 8px; }
            QSlider::sub-page:horizontal { background: #991b1b; border-radius: 3px; }
        """

        # --- Vulnerability to extremism slider ---
        vuln_lbl = QLabel("Vulnerability to extremism:")
        vuln_lbl.setStyleSheet("font-size: 13px;")
        extremism_content_layout.addWidget(vuln_lbl)

        vuln_slider_row = QHBoxLayout()
        self.extremism_vuln_options = ["Nil", "Low", "Medium", "Significant", "High"]
        self.extremism_vuln_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.extremism_vuln_slider.setRange(0, len(self.extremism_vuln_options) - 1)
        self.extremism_vuln_slider.setValue(1)  # Default to "Low" when Yes is selected
        self.extremism_vuln_slider.setStyleSheet(slider_style)
        vuln_slider_row.addWidget(self.extremism_vuln_slider, 1)

        self.extremism_vuln_label = QLabel(self.extremism_vuln_options[1])
        self.extremism_vuln_label.setStyleSheet("font-size: 13px; font-weight: 600; color: #991b1b; min-width: 70px;")
        self.extremism_vuln_slider.valueChanged.connect(lambda v: self.extremism_vuln_label.setText(self.extremism_vuln_options[v]))
        self.extremism_vuln_slider.valueChanged.connect(self._update_extremism_preview)
        vuln_slider_row.addWidget(self.extremism_vuln_label)
        extremism_content_layout.addLayout(vuln_slider_row)

        # --- Presence of concerning views slider ---
        views_lbl = QLabel("Presence of concerning views:")
        views_lbl.setStyleSheet("font-size: 13px;")
        extremism_content_layout.addWidget(views_lbl)

        views_slider_row = QHBoxLayout()
        self.extremism_views_options = ["Nil", "Rare", "Some", "Often", "High"]
        self.extremism_views_slider = NoWheelSlider(Qt.Orientation.Horizontal)
        self.extremism_views_slider.setRange(0, len(self.extremism_views_options) - 1)
        self.extremism_views_slider.setValue(1)  # Default to "Rare" when Yes is selected
        self.extremism_views_slider.setStyleSheet(slider_style)
        views_slider_row.addWidget(self.extremism_views_slider, 1)

        self.extremism_views_label = QLabel(self.extremism_views_options[1])
        self.extremism_views_label.setStyleSheet("font-size: 13px; font-weight: 600; color: #991b1b; min-width: 70px;")
        self.extremism_views_slider.valueChanged.connect(lambda v: self.extremism_views_label.setText(self.extremism_views_options[v]))
        self.extremism_views_slider.valueChanged.connect(self._update_extremism_preview)
        views_slider_row.addWidget(self.extremism_views_label)
        extremism_content_layout.addLayout(views_slider_row)

        # --- Contact with counter-terrorism tickboxes ---
        ct_lbl = QLabel("Contact with counter-terrorism:")
        ct_lbl.setStyleSheet("font-size: 13px; font-weight: 600; margin-top: 8px;")
        extremism_content_layout.addWidget(ct_lbl)

        ct_row = QHBoxLayout()
        self.extremism_ct_police = QCheckBox("Police")
        self.extremism_ct_police.setStyleSheet("font-size: 13px;")
        self.extremism_ct_police.toggled.connect(self._update_extremism_preview)
        ct_row.addWidget(self.extremism_ct_police)

        self.extremism_ct_probation = QCheckBox("Probation")
        self.extremism_ct_probation.setStyleSheet("font-size: 13px;")
        self.extremism_ct_probation.toggled.connect(self._update_extremism_preview)
        ct_row.addWidget(self.extremism_ct_probation)
        ct_row.addStretch()
        extremism_content_layout.addLayout(ct_row)

        # --- Prevent referral radio buttons ---
        prevent_lbl = QLabel("Prevent referral:")
        prevent_lbl.setStyleSheet("font-size: 13px; font-weight: 600; margin-top: 8px;")
        extremism_content_layout.addWidget(prevent_lbl)

        prevent_row = QHBoxLayout()
        self.extremism_prevent_group = QButtonGroup(popup)
        self.extremism_prevent_yes = QRadioButton("Yes")
        self.extremism_prevent_yes.setStyleSheet("font-size: 13px;")
        self.extremism_prevent_no = QRadioButton("No")
        self.extremism_prevent_no.setStyleSheet("font-size: 13px;")
        self.extremism_prevent_no.setChecked(True)
        self.extremism_prevent_group.addButton(self.extremism_prevent_yes)
        self.extremism_prevent_group.addButton(self.extremism_prevent_no)
        prevent_row.addWidget(self.extremism_prevent_yes)
        prevent_row.addWidget(self.extremism_prevent_no)
        prevent_row.addStretch()
        extremism_content_layout.addLayout(prevent_row)

        # Outcome text box (shown when Yes is selected)
        self.extremism_prevent_outcome_container = QWidget()
        outcome_layout = QVBoxLayout(self.extremism_prevent_outcome_container)
        outcome_layout.setContentsMargins(0, 4, 0, 0)
        outcome_layout.setSpacing(4)
        outcome_lbl = QLabel("Outcome:")
        outcome_lbl.setStyleSheet("font-size: 13px;")
        outcome_layout.addWidget(outcome_lbl)
        self.extremism_prevent_outcome = QLineEdit()
        self.extremism_prevent_outcome.setPlaceholderText("Enter outcome of Prevent referral...")
        self.extremism_prevent_outcome.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;")
        self.extremism_prevent_outcome.textChanged.connect(self._update_extremism_preview)
        outcome_layout.addWidget(self.extremism_prevent_outcome)
        self.extremism_prevent_outcome_container.hide()
        extremism_content_layout.addWidget(self.extremism_prevent_outcome_container)

        # Connect radio buttons to show/hide outcome
        self.extremism_prevent_yes.toggled.connect(lambda checked: self.extremism_prevent_outcome_container.setVisible(checked))
        self.extremism_prevent_yes.toggled.connect(self._update_extremism_preview)
        self.extremism_prevent_no.toggled.connect(self._update_extremism_preview)

        # --- Conditions needed to manage risk ---
        conditions_lbl = QLabel("Conditions needed to manage risk:")
        conditions_lbl.setStyleSheet("font-size: 13px; font-weight: 600; margin-top: 8px;")
        extremism_content_layout.addWidget(conditions_lbl)

        self.extremism_conditions = QTextEdit()
        self.extremism_conditions.setPlaceholderText("Enter conditions needed to manage extremism risk...")
        self.extremism_conditions.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;")
        self.extremism_conditions.setMaximumHeight(60)
        self.extremism_conditions.textChanged.connect(self._update_extremism_preview)
        extremism_content_layout.addWidget(self.extremism_conditions)

        # --- Work done to address risk ---
        work_lbl = QLabel("Work done to address risk:")
        work_lbl.setStyleSheet("font-size: 13px; font-weight: 600; margin-top: 8px;")
        extremism_content_layout.addWidget(work_lbl)

        self.extremism_work_done = QTextEdit()
        self.extremism_work_done.setPlaceholderText("e.g. Extremist Risk Guidance 22+")
        self.extremism_work_done.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;")
        self.extremism_work_done.setMaximumHeight(60)
        self.extremism_work_done.textChanged.connect(self._update_extremism_preview)
        extremism_content_layout.addWidget(self.extremism_work_done)

        extremism_main_layout.addWidget(self.extremism_content)
        extremism_details_layout.addWidget(extremism_container)

        # Toggle function for collapse
        def toggle_extremism():
            visible = not self.extremism_content.isVisible()
            self.extremism_content.setVisible(visible)
            self.extremism_collapse_btn.setText("-" if visible else "+")
        self.extremism_collapse_btn.clicked.connect(toggle_extremism)

        # Initially hide the details container
        self.extremism_details_container.setVisible(False)
        content_layout.addWidget(self.extremism_details_container)

        # Connect Yes/N/A radios to show/hide details
        def on_extremism_concern_changed():
            self.extremism_details_container.setVisible(self.extremism_concern_yes.isChecked())
            self._update_extremism_preview()

        self.extremism_concern_yes.toggled.connect(on_extremism_concern_changed)
        self.extremism_concern_na.toggled.connect(on_extremism_concern_changed)

        # ============================================================
        # COLLAPSIBLE IMPORTED DATA SECTION (matching 4a style)
        # ============================================================
        import_container = QWidget()
        import_container.setStyleSheet("""
            QWidget {
                background: rgba(255, 248, 220, 0.95);
                border: 1px solid rgba(180, 150, 50, 0.4);
                border-radius: 12px;
            }
            QCheckBox {
                background: transparent;
                border: none;
                padding: 4px;
                font-size: 14px;
                color: #4a4a4a;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
        """)
        import_main_layout = QVBoxLayout(import_container)
        import_main_layout.setContentsMargins(12, 10, 12, 10)
        import_main_layout.setSpacing(6)

        # Header with collapse button
        import_header = QHBoxLayout()
        self.extremism_import_collapse_btn = QPushButton("-")
        self.extremism_import_collapse_btn.setFixedSize(20, 20)
        self.extremism_import_collapse_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.extremism_import_collapse_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #806000; background: rgba(255, 248, 220, 0.95); border: 1px solid rgba(180, 150, 50, 0.4); border-radius: 4px; } QPushButton:hover { background: #fef3c7; }")
        import_header.addWidget(self.extremism_import_collapse_btn)

        import_title = QLabel("Imported Data - Extremism References")
        import_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #806000; background: transparent; border: none;")
        import_header.addWidget(import_title)
        import_header.addStretch()

        self.extremism_import_count = QLabel("0 entries")
        self.extremism_import_count.setStyleSheet("font-size: 13px; color: #806000; background: transparent; border: none;")
        import_header.addWidget(self.extremism_import_count)

        import_main_layout.addLayout(import_header)

        # Collapsible content - scrollable area for entries
        self.extremism_import_content = QWidget()
        self.extremism_import_content.setStyleSheet("background: transparent; border: none;")
        import_content_layout = QVBoxLayout(self.extremism_import_content)
        import_content_layout.setContentsMargins(12, 4, 12, 4)
        import_content_layout.setSpacing(4)

        # Scroll area for imported entries
        extremism_import_scroll = QScrollArea()
        extremism_import_scroll.setWidgetResizable(True)
        extremism_import_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        extremism_import_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        extremism_import_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        extremism_import_scroll.setMaximumHeight(200)
        extremism_import_scroll.setStyleSheet("""
            QScrollArea { background: transparent; border: none; }
            QScrollArea > QWidget > QWidget { background: transparent; }
        """)

        self.extremism_import_entries_widget = QWidget()
        self.extremism_import_entries_widget.setStyleSheet("background: transparent;")
        self.extremism_import_entries_layout = QVBoxLayout(self.extremism_import_entries_widget)
        self.extremism_import_entries_layout.setContentsMargins(2, 2, 2, 2)
        self.extremism_import_entries_layout.setSpacing(4)
        self.extremism_import_entries_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # Placeholder
        self.extremism_import_placeholder = QLabel("No extremism-related entries found in imported data.")
        self.extremism_import_placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 13px; background: transparent; border: none;")
        self.extremism_import_entries_layout.addWidget(self.extremism_import_placeholder)

        extremism_import_scroll.setWidget(self.extremism_import_entries_widget)
        import_content_layout.addWidget(extremism_import_scroll)

        import_main_layout.addWidget(self.extremism_import_content)
        content_layout.addWidget(import_container)

        # Toggle function for import collapse
        def toggle_extremism_import():
            visible = not self.extremism_import_content.isVisible()
            self.extremism_import_content.setVisible(visible)
            self.extremism_import_collapse_btn.setText("-" if visible else "+")
        self.extremism_import_collapse_btn.clicked.connect(toggle_extremism_import)

        # Storage for imported entries
        self.extremism_imported_entries = []

        content_layout.addStretch()
        content_scroll.setWidget(content_widget)
        main_layout.addWidget(content_scroll)

        # Register popup generator
        def generate_extremism_text():
            return self.extremism_preview.text().strip()
        self.popup_generators["extremism"] = generate_extremism_text

        # Initial preview update
        self._update_extremism_preview()

        # Apply stored extremism detection (from import)
        if hasattr(self, '_extracted_patient_details') and self._extracted_patient_details:
            from PySide6.QtCore import QTimer
            def apply_extremism_data():
                extremism_concern = self._extracted_patient_details.get('extremism_concern', False)
                extremism_entries = self._extracted_patient_details.get('extremism_entries', [])

                if extremism_concern:
                    self.extremism_concern_yes.setChecked(True)
                    print(f"[MOJ-LEAVE] 4h popup: Applied extremism concern = YES")
                else:
                    self.extremism_concern_na.setChecked(True)
                    print(f"[MOJ-LEAVE] 4h popup: Applied extremism concern = N/A")

                # Populate imported entries
                if extremism_entries:
                    self._populate_extremism_imports(extremism_entries)

                self._update_extremism_preview()
            QTimer.singleShot(100, apply_extremism_data)

        return popup

    def _populate_extremism_imports(self, entries):
        """Populate the extremism imported data section matching 4a style."""
        if not hasattr(self, 'extremism_import_entries_layout'):
            return

        # Clear existing entries
        while self.extremism_import_entries_layout.count():
            item = self.extremism_import_entries_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        if not entries:
            placeholder = QLabel("No extremism-related entries found in imported data.")
            placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 14px; background: transparent; border: none;")
            self.extremism_import_entries_layout.addWidget(placeholder)
            self.extremism_import_count.setText("0 entries")
            return

        self.extremism_imported_entries = []
        self.extremism_import_checkboxes = []

        for entry in entries:
            text = entry.get('text', '')
            date_str = entry.get('date', '') or ''
            keyword = entry.get('keyword', 'unknown')

            entry_frame = QFrame()
            entry_frame.setObjectName("entryFrame")
            entry_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            entry_frame.setStyleSheet("""
                QFrame#entryFrame {
                    background: rgba(255, 255, 255, 0.95);
                    border: 1px solid rgba(180, 150, 50, 0.4);
                    border-radius: 8px;
                    padding: 4px;
                }
            """)
            entry_layout = QVBoxLayout(entry_frame)
            entry_layout.setContentsMargins(10, 4, 16, 4)
            entry_layout.setSpacing(6)


            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            # Toggle button (left side)
            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("""
                QPushButton { background: rgba(180, 150, 50, 0.2); border: none; border-radius: 4px; font-size: 15px; font-weight: bold; color: #806000; }
                QPushButton:hover { background: rgba(180, 150, 50, 0.35); }
            """)
            header_row.addWidget(toggle_btn)

            # Date label (first after toggle)
            if date_str:
                date_label = QLabel(f"\U0001f4c5 {date_str}")
                date_label.setStyleSheet("font-size: 15px; font-weight: 600; color: #806000; background: transparent; border: none;")
                date_label.setCursor(Qt.CursorShape.PointingHandCursor)
                header_row.addWidget(date_label)

            # Keyword tag
            keyword_tag = QLabel(f"Extremism: {keyword}")
            keyword_tag.setStyleSheet("background: #fef3c7; color: #806000; padding: 4px 10px; border-radius: 3px; font-size: 14px; font-weight: 600;")
            header_row.addWidget(keyword_tag)

            header_row.addStretch()

            # Checkbox (right side)
            cb = QCheckBox()
            cb.setProperty("full_text", text)
            cb.setFixedSize(20, 20)
            cb.setStyleSheet("QCheckBox { background: transparent; margin-right: 4px; } QCheckBox::indicator { width: 18px; height: 18px; }")
            header_row.addWidget(cb)

            entry_layout.addLayout(header_row)

            # Body text (hidden by default)
            body_text = QTextEdit()
            body_text.setPlainText(text)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("QTextEdit { font-size: 15px; color: #333; background: rgba(255, 248, 220, 0.5); border: none; padding: 8px; border-radius: 6px; }")
            body_text.document().setTextWidth(350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            entry_layout.addWidget(body_text)

            def make_toggle(btn, body, frame):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    frame.updateGeometry()
                return toggle

            toggle_fn = make_toggle(toggle_btn, body_text, entry_frame)
            toggle_btn.clicked.connect(toggle_fn)
            if date_str:
                date_label.mousePressEvent = lambda e, fn=toggle_fn: fn()

            self.extremism_import_entries_layout.addWidget(entry_frame)
            self.extremism_imported_entries.append(entry)
            self.extremism_import_checkboxes.append({"checkbox": cb, "text": text, "frame": entry_frame})

        self.extremism_import_count.setText(f"{len(entries)} entries")
        print(f"[MOJ-LEAVE] 4h popup: Populated {len(entries)} extremism entries (4a style)")

    def _update_extremism_preview(self):
        """Update the extremism preview text."""
        if not hasattr(self, 'extremism_preview'):
            return

        p = self._get_pronouns()
        parts = []

        # Check if N/A is selected
        if hasattr(self, 'extremism_concern_na') and self.extremism_concern_na.isChecked():
            self.extremism_preview.setText("N/A")
            # Auto-sync N/A to card - preserve user additions
            if "extremism" in self.cards:
                self._update_text_preserving_additions(self.cards["extremism"].editor, "N/A", "extremism")
            return

        # Check if Yes is selected (show details)
        if hasattr(self, 'extremism_concern_yes') and self.extremism_concern_yes.isChecked():
            parts.append("Extremism is identified as a concern.")

        # Vulnerability to extremism
        if hasattr(self, 'extremism_vuln_slider'):
            vuln_val = self.extremism_vuln_slider.value()
            vuln_text = self.extremism_vuln_options[vuln_val].lower()
            if vuln_val == 0:
                parts.append(f"{p['subj']} {p['has']} no identified vulnerability to extremism.")
            else:
                parts.append(f"{p['subj']} {p['has']} {vuln_text} vulnerability to extremism.")

        # Presence of concerning views
        if hasattr(self, 'extremism_views_slider'):
            views_val = self.extremism_views_slider.value()
            views_text = self.extremism_views_options[views_val].lower()
            if views_val == 0:
                parts.append("There is no presence of concerning views.")
            elif views_val == 1:
                parts.append("Concerning views are rarely expressed.")
            elif views_val == 2:
                parts.append("There is some presence of concerning views.")
            elif views_val == 3:
                parts.append("Concerning views are often expressed.")
            else:
                parts.append("There is a high presence of concerning views.")

        # Contact with counter-terrorism
        ct_contacts = []
        if hasattr(self, 'extremism_ct_police') and self.extremism_ct_police.isChecked():
            ct_contacts.append("police")
        if hasattr(self, 'extremism_ct_probation') and self.extremism_ct_probation.isChecked():
            ct_contacts.append("probation")

        if ct_contacts:
            contacts_text = " and ".join(ct_contacts)
            parts.append(f"There has been contact with counter-terrorism {contacts_text}.")

        # Prevent referral
        if hasattr(self, 'extremism_prevent_yes') and self.extremism_prevent_yes.isChecked():
            outcome = self.extremism_prevent_outcome.text().strip() if hasattr(self, 'extremism_prevent_outcome') else ""
            if outcome:
                parts.append(f"A Prevent referral has been made with outcome: {outcome}.")
            else:
                parts.append("A Prevent referral has been made.")
        elif hasattr(self, 'extremism_prevent_no') and self.extremism_prevent_no.isChecked():
            parts.append("No Prevent referral has been made.")

        # Conditions needed to manage risk
        if hasattr(self, 'extremism_conditions'):
            conditions = self.extremism_conditions.toPlainText().strip()
            if conditions:
                parts.append(f"Conditions needed to manage risk: {conditions}")

        # Work done to address risk
        if hasattr(self, 'extremism_work_done'):
            work = self.extremism_work_done.toPlainText().strip()
            if work:
                parts.append(f"Work done to address risk: {work}")

        if parts:
            text = " ".join(parts)
            self.extremism_preview.setText(text)
            # Auto-sync to card - preserve user additions
            if "extremism" in self.cards:
                self._update_text_preserving_additions(self.cards["extremism"].editor, text, "extremism")
        else:
            self.extremism_preview.setText("No extremism information entered.")

    def _create_absconding_popup(self) -> QWidget:
        """Create Absconding popup with AWOL assessment and imported notes."""
        key = "absconding"
        popup = QWidget()
        popup.setObjectName(f"popup_{key}")
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)

        # Hidden label to store text for auto-sync to card
        self.absconding_preview = QLabel()
        self.absconding_preview.hide()

        # === CONTENT PANEL ===
        content_scroll = QScrollArea()
        content_scroll.setWidgetResizable(True)
        content_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        content_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        content_scroll.setStyleSheet("QScrollArea { background: transparent; border: none; }")

        content_widget = QWidget()
        content_widget.setStyleSheet("background: transparent;")
        content_layout = QVBoxLayout(content_widget)
        content_layout.setContentsMargins(8, 8, 8, 8)
        content_layout.setSpacing(10)

        # ============================================================
        # COLLAPSIBLE ABSCONDING CONTAINER
        # ============================================================
        absconding_container = QWidget()
        absconding_container.setStyleSheet("background: #fef3c7; border-radius: 6px;")
        absconding_main_layout = QVBoxLayout(absconding_container)
        absconding_main_layout.setContentsMargins(10, 8, 10, 8)
        absconding_main_layout.setSpacing(6)

        # Header with collapse button
        header_layout = QHBoxLayout()
        self.absconding_collapse_btn = QPushButton("-")
        self.absconding_collapse_btn.setFixedSize(20, 20)
        self.absconding_collapse_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.absconding_collapse_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #92400e; background: white; border: 1px solid #fcd34d; border-radius: 4px; } QPushButton:hover { background: #fef9c3; }")
        header_layout.addWidget(self.absconding_collapse_btn)
        header_title = QLabel("Absconding / AWOL Assessment")
        header_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #92400e;")
        header_layout.addWidget(header_title)
        header_layout.addStretch()
        absconding_main_layout.addLayout(header_layout)

        # Collapsible content
        self.absconding_content = QWidget()
        absconding_content_layout = QVBoxLayout(self.absconding_content)
        absconding_content_layout.setContentsMargins(28, 4, 0, 4)
        absconding_content_layout.setSpacing(8)

        # --- AWOL Yes/No/N/A radio buttons ---
        awol_row = QHBoxLayout()
        awol_lbl = QLabel("Any AWOL concerns?")
        awol_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        awol_row.addWidget(awol_lbl)

        self.absconding_awol_group = QButtonGroup(popup)
        self.absconding_awol_yes = QRadioButton("Yes")
        self.absconding_awol_yes.setStyleSheet("font-size: 13px;")
        self.absconding_awol_no = QRadioButton("No")
        self.absconding_awol_no.setStyleSheet("font-size: 13px;")
        self.absconding_awol_na = QRadioButton("N/A")
        self.absconding_awol_na.setStyleSheet("font-size: 13px;")
        self.absconding_awol_na.setChecked(True)  # Default to N/A
        self.absconding_awol_group.addButton(self.absconding_awol_yes)
        self.absconding_awol_group.addButton(self.absconding_awol_no)
        self.absconding_awol_group.addButton(self.absconding_awol_na)
        awol_row.addWidget(self.absconding_awol_yes)
        awol_row.addWidget(self.absconding_awol_no)
        awol_row.addWidget(self.absconding_awol_na)
        awol_row.addStretch()
        absconding_content_layout.addLayout(awol_row)

        # Connect radio buttons to update preview
        self.absconding_awol_yes.toggled.connect(self._update_absconding_preview)
        self.absconding_awol_no.toggled.connect(self._update_absconding_preview)
        self.absconding_awol_na.toggled.connect(self._update_absconding_preview)

        # Details container (shown when Yes is selected)
        self.absconding_details_container = QWidget()
        details_layout = QVBoxLayout(self.absconding_details_container)
        details_layout.setContentsMargins(0, 4, 0, 0)
        details_layout.setSpacing(4)

        details_lbl = QLabel("Details:")
        details_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        details_layout.addWidget(details_lbl)

        self.absconding_details = QTextEdit()
        self.absconding_details.setPlaceholderText("Describe AWOL concerns...")
        self.absconding_details.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;")
        self.absconding_details.setMaximumHeight(100)
        self.absconding_details.textChanged.connect(self._update_absconding_preview)
        details_layout.addWidget(self.absconding_details)

        self.absconding_details_container.hide()
        absconding_content_layout.addWidget(self.absconding_details_container)

        # Show/hide details based on AWOL selection
        self.absconding_awol_yes.toggled.connect(lambda checked: self.absconding_details_container.setVisible(checked))

        absconding_main_layout.addWidget(self.absconding_content)
        content_layout.addWidget(absconding_container)

        # Toggle function for collapse
        def toggle_absconding():
            visible = not self.absconding_content.isVisible()
            self.absconding_content.setVisible(visible)
            self.absconding_collapse_btn.setText("-" if visible else "+")
        self.absconding_collapse_btn.clicked.connect(toggle_absconding)

        # ============================================================
        # COLLAPSIBLE IMPORTED DATA SECTION (matching 4a style)
        # ============================================================
        import_container = QWidget()
        import_container.setStyleSheet("""
            QWidget {
                background: rgba(255, 248, 220, 0.95);
                border: 1px solid rgba(180, 150, 50, 0.4);
                border-radius: 12px;
            }
            QCheckBox {
                background: transparent;
                border: none;
                padding: 4px;
                font-size: 14px;
                color: #4a4a4a;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
        """)
        import_main_layout = QVBoxLayout(import_container)
        import_main_layout.setContentsMargins(12, 10, 12, 10)
        import_main_layout.setSpacing(6)

        # Import header with collapse button
        import_header = QHBoxLayout()
        self.absconding_import_btn = QPushButton("-")
        self.absconding_import_btn.setFixedSize(20, 20)
        self.absconding_import_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.absconding_import_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #806000; background: rgba(255, 248, 220, 0.95); border: 1px solid rgba(180, 150, 50, 0.4); border-radius: 4px; } QPushButton:hover { background: #fef3c7; }")
        import_header.addWidget(self.absconding_import_btn)
        import_title = QLabel("Imported Data - AWOL References")
        import_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #806000; background: transparent; border: none;")
        import_header.addWidget(import_title)
        import_header.addStretch()

        self.absconding_import_count = QLabel("0 entries")
        self.absconding_import_count.setStyleSheet("font-size: 13px; color: #806000; background: transparent; border: none;")
        import_header.addWidget(self.absconding_import_count)

        import_main_layout.addLayout(import_header)

        # Collapsible import content
        self.absconding_import_content = QWidget()
        self.absconding_import_content.setStyleSheet("background: transparent; border: none;")
        self.absconding_import_content.setVisible(True)
        import_content_layout = QVBoxLayout(self.absconding_import_content)
        import_content_layout.setContentsMargins(12, 4, 12, 4)
        import_content_layout.setSpacing(4)

        # Placeholder for imported notes (will be populated on import)
        self.absconding_import_scroll = QScrollArea()
        self.absconding_import_scroll.setWidgetResizable(True)
        self.absconding_import_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.absconding_import_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.absconding_import_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        self.absconding_import_scroll.setMaximumHeight(150)
        self.absconding_import_scroll.setStyleSheet("""
            QScrollArea { background: transparent; border: none; }
            QScrollArea > QWidget > QWidget { background: transparent; }
        """)

        self.absconding_import_widget = QWidget()
        self.absconding_import_widget.setStyleSheet("background: transparent;")
        self.absconding_import_layout = QVBoxLayout(self.absconding_import_widget)
        self.absconding_import_layout.setContentsMargins(2, 2, 2, 2)
        self.absconding_import_layout.setSpacing(4)
        self.absconding_import_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # Placeholder label
        self.absconding_import_placeholder = QLabel("No AWOL/absconding notes found. Import notes to search for AWOL concerns.")
        self.absconding_import_placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 13px; background: transparent; border: none;")
        self.absconding_import_placeholder.setWordWrap(True)
        self.absconding_import_layout.addWidget(self.absconding_import_placeholder)

        self.absconding_import_scroll.setWidget(self.absconding_import_widget)
        import_content_layout.addWidget(self.absconding_import_scroll)

        import_main_layout.addWidget(self.absconding_import_content)
        content_layout.addWidget(import_container)

        # Toggle function for import collapse
        def toggle_import():
            visible = not self.absconding_import_content.isVisible()
            self.absconding_import_content.setVisible(visible)
            self.absconding_import_btn.setText("-" if visible else "+")
        self.absconding_import_btn.clicked.connect(toggle_import)

        # Storage for imported AWOL entries
        self.absconding_imported_entries = []

        content_layout.addStretch()
        content_scroll.setWidget(content_widget)
        main_layout.addWidget(content_scroll)

        # Register popup generator
        def generate_absconding_text():
            return self.absconding_preview.text().strip()
        self.popup_generators["absconding"] = generate_absconding_text

        # Initial preview update
        self._update_absconding_preview()

        # Apply stored AWOL detection (from import)
        if hasattr(self, '_extracted_patient_details') and self._extracted_patient_details:
            from PySide6.QtCore import QTimer
            def apply_awol_data():
                awol_found = self._extracted_patient_details.get('awol', False)
                awol_entries = self._extracted_patient_details.get('awol_entries', [])

                if awol_found:
                    self.absconding_awol_yes.setChecked(True)
                    # If we have details, populate them
                    awol_details = self._extracted_patient_details.get('awol_details', [])
                    if awol_details and hasattr(self, 'absconding_details'):
                        self.absconding_details.setPlainText("\n".join(awol_details))
                    print(f"[MOJ-LEAVE] 4i popup: Applied AWOL = YES")
                else:
                    self.absconding_awol_no.setChecked(True)
                    print(f"[MOJ-LEAVE] 4i popup: Applied AWOL = NO")

                # Populate imported entries with context
                if awol_entries:
                    self._populate_awol_imports(awol_entries)

                self._update_absconding_preview()
            QTimer.singleShot(100, apply_awol_data)

        return popup

    def _populate_awol_imports(self, entries):
        """Populate the AWOL imported data section matching 4a style."""
        if not hasattr(self, 'absconding_import_layout'):
            return

        # Clear existing entries
        while self.absconding_import_layout.count():
            item = self.absconding_import_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        if not entries:
            placeholder = QLabel("No AWOL-related entries found in imported data.")
            placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 14px; background: transparent; border: none;")
            self.absconding_import_layout.addWidget(placeholder)
            self.absconding_import_count.setText("0 entries")
            return

        self.absconding_imported_entries = []
        self.awol_import_checkboxes = []

        for entry in entries:
            text = entry.get('text', '')
            date_str = entry.get('date', '') or ''
            keyword = entry.get('keyword', 'unknown')
            within_12_months = entry.get('within_12_months', True)

            entry_frame = QFrame()
            entry_frame.setObjectName("entryFrame")
            entry_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            entry_frame.setStyleSheet("""
                QFrame#entryFrame {
                    background: rgba(255, 255, 255, 0.95);
                    border: 1px solid rgba(180, 150, 50, 0.4);
                    border-radius: 8px;
                    padding: 4px;
                }
            """)
            entry_layout = QVBoxLayout(entry_frame)
            entry_layout.setContentsMargins(10, 4, 16, 4)
            entry_layout.setSpacing(6)


            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            # Toggle button (left side)
            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("""
                QPushButton { background: rgba(180, 150, 50, 0.2); border: none; border-radius: 4px; font-size: 15px; font-weight: bold; color: #806000; }
                QPushButton:hover { background: rgba(180, 150, 50, 0.35); }
            """)
            header_row.addWidget(toggle_btn)

            # Date label (first after toggle)
            if date_str:
                date_label = QLabel(f"\U0001f4c5 {date_str}")
                date_label.setStyleSheet("font-size: 15px; font-weight: 600; color: #806000; background: transparent; border: none;")
                date_label.setCursor(Qt.CursorShape.PointingHandCursor)
                header_row.addWidget(date_label)

            # AWOL keyword tag
            keyword_tag = QLabel(f"AWOL: {keyword}")
            keyword_tag.setStyleSheet("background: #fef3c7; color: #806000; padding: 4px 10px; border-radius: 3px; font-size: 14px; font-weight: 600;")
            header_row.addWidget(keyword_tag)

            # Within 12 months tag (preserve section-specific label)
            if within_12_months:
                window_tag = QLabel("Within 12 months")
                window_tag.setStyleSheet("background: #dcfce7; color: #166534; padding: 4px 8px; border-radius: 3px; font-size: 13px;")
                header_row.addWidget(window_tag)
            else:
                window_tag = QLabel("Outside 12 months")
                window_tag.setStyleSheet("background: #f3f4f6; color: #6b7280; padding: 4px 8px; border-radius: 3px; font-size: 13px;")
                header_row.addWidget(window_tag)

            header_row.addStretch()

            # Checkbox (right side)
            cb = QCheckBox()
            cb.setProperty("full_text", text)
            cb.setFixedSize(20, 20)
            cb.setStyleSheet("QCheckBox { background: transparent; margin-right: 4px; } QCheckBox::indicator { width: 18px; height: 18px; }")
            header_row.addWidget(cb)

            entry_layout.addLayout(header_row)

            # Body text (hidden by default)
            body_text = QTextEdit()
            body_text.setPlainText(text)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("QTextEdit { font-size: 15px; color: #333; background: rgba(255, 248, 220, 0.5); border: none; padding: 8px; border-radius: 6px; }")
            body_text.document().setTextWidth(350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            entry_layout.addWidget(body_text)

            def make_toggle(btn, body, frame):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    frame.updateGeometry()
                return toggle

            toggle_fn = make_toggle(toggle_btn, body_text, entry_frame)
            toggle_btn.clicked.connect(toggle_fn)
            if date_str:
                date_label.mousePressEvent = lambda e, fn=toggle_fn: fn()

            self.absconding_import_layout.addWidget(entry_frame)
            self.absconding_imported_entries.append(entry)
            self.awol_import_checkboxes.append({"checkbox": cb, "text": text, "frame": entry_frame})

        # Update count
        within_count = len([e for e in entries if e.get('within_12_months', True)])
        total_count = len(entries)
        if within_count < total_count:
            self.absconding_import_count.setText(f"{within_count} in window / {total_count} total")
        else:
            self.absconding_import_count.setText(f"{total_count} entries")
        print(f"[MOJ-LEAVE] 4i popup: Populated {total_count} AWOL entries (4a style)")

    def _update_absconding_preview(self):
        """Update the absconding preview text."""
        if not hasattr(self, 'absconding_preview'):
            return

        p = self._get_pronouns()
        parts = []

        # AWOL incidents
        if hasattr(self, 'absconding_awol_na') and self.absconding_awol_na.isChecked():
            self.absconding_preview.setText("N/A")
            # Auto-sync N/A to card - preserve user additions
            if "absconding" in self.cards:
                self._update_text_preserving_additions(self.cards["absconding"].editor, "N/A", "absconding")
            return
        elif hasattr(self, 'absconding_awol_no') and self.absconding_awol_no.isChecked():
            parts.append("There have been no AWOL concerns in the last 12 months.")
        elif hasattr(self, 'absconding_awol_yes') and self.absconding_awol_yes.isChecked():
            details = self.absconding_details.toPlainText().strip() if hasattr(self, 'absconding_details') else ""
            if details:
                parts.append(f"There have been AWOL concerns. {details}")
            else:
                parts.append("There have been AWOL concerns.")

        # Add any checked imported entries
        if hasattr(self, 'absconding_imported_entries'):
            imported_texts = []
            for entry in self.absconding_imported_entries:
                if entry.get("checkbox") and entry["checkbox"].isChecked():
                    date = entry.get("date", "")
                    text = entry.get("text", "").strip()
                    if date and text:
                        imported_texts.append(f"[{date}] {text}")
                    elif text:
                        imported_texts.append(text)

            if imported_texts:
                parts.append("\n--- Imported Notes ---\n" + "\n".join(imported_texts))

        if parts:
            text = " ".join(parts)
            self.absconding_preview.setText(text)
            # Auto-sync to card - preserve user additions
            if "absconding" in self.cards:
                self._update_text_preserving_additions(self.cards["absconding"].editor, text, "absconding")
        else:
            self.absconding_preview.setText("No absconding information entered.")

    def _search_awol_in_notes(self, notes_text: str):
        """Search for AWOL/absconding related entries in imported notes and populate the import section."""
        if not hasattr(self, 'absconding_import_layout'):
            return

        # Clear existing entries
        for entry in self.absconding_imported_entries:
            if entry.get("widget"):
                entry["widget"].deleteLater()
        self.absconding_imported_entries.clear()

        # Hide placeholder initially (safely handle deleted Qt objects)
        if hasattr(self, 'absconding_import_placeholder'):
            try:
                self.absconding_import_placeholder.hide()
            except RuntimeError:
                self.absconding_import_placeholder = None

        # AWOL keywords to search for
        awol_keywords = [
            "awol", "absent without leave", "absconded", "absconding", "abscond",
            "went missing", "missing from ward", "failed to return", "escape",
            "escaped", "left without permission", "unauthorized absence"
        ]

        # Split notes into lines and search for keywords
        lines = notes_text.split('\n')
        found_entries = []

        for line in lines:
            line_lower = line.lower()
            for keyword in awol_keywords:
                if keyword in line_lower:
                    # Extract date if present (common formats)
                    import re
                    date_match = re.search(r'(\d{1,2}[/-]\d{1,2}[/-]\d{2,4})', line)
                    date = date_match.group(1) if date_match else ""
                    found_entries.append({"date": date, "text": line.strip()})
                    break

        # Populate import section with found entries
        if found_entries:
            for entry_data in found_entries:
                entry_widget = QWidget()
                entry_layout = QHBoxLayout(entry_widget)
                entry_layout.setContentsMargins(0, 2, 0, 2)
                entry_layout.setSpacing(8)

                cb = QCheckBox()
                cb.toggled.connect(self._update_absconding_preview)
                entry_layout.addWidget(cb)

                text_lbl = QLabel(entry_data["text"][:100] + "..." if len(entry_data["text"]) > 100 else entry_data["text"])
                text_lbl.setStyleSheet("font-size: 14px; color: #374151;")
                text_lbl.setWordWrap(True)
                entry_layout.addWidget(text_lbl, 1)

                self.absconding_import_layout.addWidget(entry_widget)

                self.absconding_imported_entries.append({
                    "widget": entry_widget,
                    "checkbox": cb,
                    "date": entry_data["date"],
                    "text": entry_data["text"]
                })

            # Auto-select "Yes" if AWOL entries found
            if hasattr(self, 'absconding_awol_yes'):
                self.absconding_awol_yes.setChecked(True)
        else:
            # Show placeholder if no entries found (safely handle deleted Qt objects)
            if hasattr(self, 'absconding_import_placeholder') and self.absconding_import_placeholder:
                try:
                    self.absconding_import_placeholder.show()
                except RuntimeError:
                    self.absconding_import_placeholder = None

    def _create_mappa_popup(self) -> QWidget:
        """Create MAPPA popup with collapsible containers and imported data like 4i."""
        key = "mappa"
        popup = QWidget()
        popup.setObjectName(f"popup_{key}")
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)

        # Hidden label to store text for auto-sync to card
        self.mappa_preview = QLabel()
        self.mappa_preview.hide()

        # === CONTENT PANEL ===
        content_scroll = QScrollArea()
        content_scroll.setWidgetResizable(True)
        content_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        content_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        content_scroll.setStyleSheet("QScrollArea { background: transparent; border: none; }")

        content_widget = QWidget()
        content_widget.setStyleSheet("background: transparent;")
        content_layout = QVBoxLayout(content_widget)
        content_layout.setContentsMargins(8, 8, 8, 8)
        content_layout.setSpacing(10)

        # ============================================================
        # CONVICTED OF MAPPA ELIGIBLE INDEX OFFENCE: Yes / No
        # ============================================================
        eligible_frame = QWidget()
        eligible_frame.setStyleSheet("background: #dbeafe; border-radius: 6px;")
        eligible_layout = QVBoxLayout(eligible_frame)
        eligible_layout.setContentsMargins(12, 10, 12, 10)
        eligible_layout.setSpacing(8)

        eligible_lbl = QLabel("<b>Convicted of MAPPA Eligible Index Offence:</b>")
        eligible_lbl.setStyleSheet("font-size: 14px; color: #1e40af;")
        eligible_layout.addWidget(eligible_lbl)

        eligible_row = QHBoxLayout()
        self.mappa_eligible_group = QButtonGroup(popup)
        self.mappa_eligible_yes = QRadioButton("Yes")
        self.mappa_eligible_no = QRadioButton("No")
        self.mappa_eligible_yes.setStyleSheet("font-size: 13px;")
        self.mappa_eligible_no.setStyleSheet("font-size: 13px;")
        self.mappa_eligible_group.addButton(self.mappa_eligible_yes)
        self.mappa_eligible_group.addButton(self.mappa_eligible_no)
        eligible_row.addWidget(self.mappa_eligible_yes)
        eligible_row.addWidget(self.mappa_eligible_no)
        eligible_row.addStretch()
        eligible_layout.addLayout(eligible_row)

        content_layout.addWidget(eligible_frame)

        # ============================================================
        # MAPPA DETAILS CONTAINER (shown when Yes is selected)
        # ============================================================
        self.mappa_details_container = QWidget()
        mappa_details_layout = QVBoxLayout(self.mappa_details_container)
        mappa_details_layout.setContentsMargins(0, 0, 0, 0)
        mappa_details_layout.setSpacing(10)

        # ============================================================
        # COLLAPSIBLE MAPPA FORM CONTAINER
        # ============================================================
        mappa_container = QWidget()
        mappa_container.setStyleSheet("background: #dbeafe; border-radius: 6px;")
        mappa_main_layout = QVBoxLayout(mappa_container)
        mappa_main_layout.setContentsMargins(10, 8, 10, 8)
        mappa_main_layout.setSpacing(6)

        # Header with collapse button
        header_layout = QHBoxLayout()
        self.mappa_collapse_btn = QPushButton("-")
        self.mappa_collapse_btn.setFixedSize(20, 20)
        self.mappa_collapse_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.mappa_collapse_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #1e40af; background: white; border: 1px solid #93c5fd; border-radius: 4px; } QPushButton:hover { background: #eff6ff; }")
        header_layout.addWidget(self.mappa_collapse_btn)
        header_title = QLabel("MAPPA Details")
        header_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #1e40af;")
        header_layout.addWidget(header_title)
        header_layout.addStretch()
        mappa_main_layout.addLayout(header_layout)

        # Collapsible content
        self.mappa_content = QWidget()
        mappa_content_layout = QVBoxLayout(self.mappa_content)
        mappa_content_layout.setContentsMargins(28, 4, 0, 4)
        mappa_content_layout.setSpacing(8)

        # --- 5a: Coordinator ---
        coord_lbl = QLabel("5a. MAPPA Coordinator name and contact:")
        coord_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        mappa_content_layout.addWidget(coord_lbl)

        self.mappa_coordinator = QTextEdit()
        self.mappa_coordinator.setPlaceholderText("Enter MAPPA coordinator name and contact details...")
        self.mappa_coordinator.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white;")
        self.mappa_coordinator.setMaximumHeight(50)
        self.mappa_coordinator.textChanged.connect(self._update_mappa_preview)
        mappa_content_layout.addWidget(self.mappa_coordinator)

        # --- 5b: Category ---
        cat_lbl = QLabel("5b. MAPPA Category:")
        cat_lbl.setStyleSheet("font-size: 13px; font-weight: 600; margin-top: 6px;")
        mappa_content_layout.addWidget(cat_lbl)

        cat_row = QHBoxLayout()
        self.mappa_category_group = QButtonGroup(popup)
        self.mappa_categories = {}
        for cat in ["Cat 1", "Cat 2", "Cat 3", "Cat 4"]:
            rb = QRadioButton(cat)
            rb.setStyleSheet("font-size: 13px;")
            rb.toggled.connect(self._update_mappa_preview)
            self.mappa_category_group.addButton(rb)
            self.mappa_categories[cat.replace("Cat ", "Category ")] = rb
            cat_row.addWidget(rb)
        cat_row.addStretch()
        mappa_content_layout.addLayout(cat_row)

        # --- 5c: Level ---
        level_lbl = QLabel("5c. MAPPA Level:")
        level_lbl.setStyleSheet("font-size: 13px; font-weight: 600; margin-top: 6px;")
        mappa_content_layout.addWidget(level_lbl)

        level_row = QHBoxLayout()
        self.mappa_level_group = QButtonGroup(popup)
        self.mappa_levels = {}
        for level in ["Level 1", "Level 2", "Level 3"]:
            rb = QRadioButton(level)
            rb.setStyleSheet("font-size: 13px;")
            rb.toggled.connect(self._update_mappa_preview)
            rb.toggled.connect(self._update_mappa_level_visibility)
            self.mappa_level_group.addButton(rb)
            self.mappa_levels[level] = rb
            level_row.addWidget(rb)
        level_row.addStretch()
        mappa_content_layout.addLayout(level_row)

        # --- 5d: Level 1 notification ---
        self.mappa_level1_container = QWidget()
        l1_layout = QVBoxLayout(self.mappa_level1_container)
        l1_layout.setContentsMargins(0, 4, 0, 0)
        l1_layout.setSpacing(4)

        l1_row = QHBoxLayout()
        l1_lbl = QLabel("MAPPA I notification submitted?")
        l1_lbl.setStyleSheet("font-size: 13px;")
        l1_row.addWidget(l1_lbl)
        self.mappa_l1_notif_group = QButtonGroup(popup)
        self.mappa_l1_notif_yes = QRadioButton("Yes")
        self.mappa_l1_notif_no = QRadioButton("No")
        self.mappa_l1_notif_yes.setStyleSheet("font-size: 13px;")
        self.mappa_l1_notif_no.setStyleSheet("font-size: 13px;")
        self.mappa_l1_notif_group.addButton(self.mappa_l1_notif_yes)
        self.mappa_l1_notif_group.addButton(self.mappa_l1_notif_no)
        self.mappa_l1_notif_yes.toggled.connect(self._update_mappa_preview)
        self.mappa_l1_notif_no.toggled.connect(self._update_mappa_l1_visibility)
        l1_row.addWidget(self.mappa_l1_notif_yes)
        l1_row.addWidget(self.mappa_l1_notif_no)
        l1_row.addStretch()
        l1_layout.addLayout(l1_row)

        self.mappa_l1_will_submit_container = QWidget()
        will_layout = QHBoxLayout(self.mappa_l1_will_submit_container)
        will_layout.setContentsMargins(20, 0, 0, 0)
        will_lbl = QLabel("Will submit prior to leave?")
        will_lbl.setStyleSheet("font-size: 13px;")
        will_layout.addWidget(will_lbl)
        self.mappa_l1_will_group = QButtonGroup(popup)
        self.mappa_l1_will_yes = QRadioButton("Yes")
        self.mappa_l1_will_no = QRadioButton("No")
        self.mappa_l1_will_yes.setStyleSheet("font-size: 13px;")
        self.mappa_l1_will_no.setStyleSheet("font-size: 13px;")
        self.mappa_l1_will_group.addButton(self.mappa_l1_will_yes)
        self.mappa_l1_will_group.addButton(self.mappa_l1_will_no)
        self.mappa_l1_will_yes.toggled.connect(self._update_mappa_preview)
        will_layout.addWidget(self.mappa_l1_will_yes)
        will_layout.addWidget(self.mappa_l1_will_no)
        will_layout.addStretch()
        self.mappa_l1_will_submit_container.hide()
        l1_layout.addWidget(self.mappa_l1_will_submit_container)

        self.mappa_level1_container.hide()
        mappa_content_layout.addWidget(self.mappa_level1_container)

        # --- 5e/f: Level 2/3 notification and response ---
        self.mappa_level23_container = QWidget()
        l23_layout = QVBoxLayout(self.mappa_level23_container)
        l23_layout.setContentsMargins(0, 4, 0, 0)
        l23_layout.setSpacing(4)

        l23_row = QHBoxLayout()
        l23_lbl = QLabel("MAPPA notification submitted & response received?")
        l23_lbl.setStyleSheet("font-size: 13px;")
        l23_row.addWidget(l23_lbl)
        self.mappa_l23_notif_group = QButtonGroup(popup)
        self.mappa_l23_notif_yes = QRadioButton("Yes")
        self.mappa_l23_notif_no = QRadioButton("No")
        self.mappa_l23_notif_yes.setStyleSheet("font-size: 13px;")
        self.mappa_l23_notif_no.setStyleSheet("font-size: 13px;")
        self.mappa_l23_notif_group.addButton(self.mappa_l23_notif_yes)
        self.mappa_l23_notif_group.addButton(self.mappa_l23_notif_no)
        self.mappa_l23_notif_yes.toggled.connect(self._update_mappa_preview)
        l23_row.addWidget(self.mappa_l23_notif_yes)
        l23_row.addWidget(self.mappa_l23_notif_no)
        l23_row.addStretch()
        l23_layout.addLayout(l23_row)

        resp_lbl = QLabel("Why managed at this level & conditions requested:")
        resp_lbl.setStyleSheet("font-size: 13px;")
        l23_layout.addWidget(resp_lbl)

        self.mappa_level_reason = QTextEdit()
        self.mappa_level_reason.setPlaceholderText("Explain level rationale and any leave conditions...")
        self.mappa_level_reason.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white;")
        self.mappa_level_reason.setMaximumHeight(60)
        self.mappa_level_reason.textChanged.connect(self._update_mappa_preview)
        l23_layout.addWidget(self.mappa_level_reason)

        self.mappa_level23_container.hide()
        mappa_content_layout.addWidget(self.mappa_level23_container)

        mappa_main_layout.addWidget(self.mappa_content)
        mappa_details_layout.addWidget(mappa_container)

        # Toggle collapse for MAPPA form
        def toggle_mappa():
            visible = not self.mappa_content.isVisible()
            self.mappa_content.setVisible(visible)
            self.mappa_collapse_btn.setText("-" if visible else "+")
        self.mappa_collapse_btn.clicked.connect(toggle_mappa)

        # ============================================================
        # COLLAPSIBLE IMPORTED DATA CONTAINER (matching 4a style)
        # ============================================================
        import_container = QWidget()
        import_container.setStyleSheet("""
            QWidget {
                background: rgba(255, 248, 220, 0.95);
                border: 1px solid rgba(180, 150, 50, 0.4);
                border-radius: 12px;
            }
            QCheckBox {
                background: transparent;
                border: none;
                padding: 4px;
                font-size: 14px;
                color: #4a4a4a;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
        """)
        import_main_layout = QVBoxLayout(import_container)
        import_main_layout.setContentsMargins(12, 10, 12, 10)
        import_main_layout.setSpacing(6)

        import_header = QHBoxLayout()
        self.mappa_import_btn = QPushButton("-")
        self.mappa_import_btn.setFixedSize(20, 20)
        self.mappa_import_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.mappa_import_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #806000; background: rgba(255, 248, 220, 0.95); border: 1px solid rgba(180, 150, 50, 0.4); border-radius: 4px; } QPushButton:hover { background: #fef3c7; }")
        import_header.addWidget(self.mappa_import_btn)
        import_title = QLabel("Imported Data - MAPPA References")
        import_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #806000; background: transparent; border: none;")
        import_header.addWidget(import_title)
        import_header.addStretch()

        self.mappa_import_count = QLabel("0 entries")
        self.mappa_import_count.setStyleSheet("font-size: 13px; color: #806000; background: transparent; border: none;")
        import_header.addWidget(self.mappa_import_count)

        import_main_layout.addLayout(import_header)

        # Collapsible import content
        self.mappa_import_content = QWidget()
        self.mappa_import_content.setStyleSheet("background: transparent; border: none;")
        self.mappa_import_content.setVisible(True)
        import_content_layout = QVBoxLayout(self.mappa_import_content)
        import_content_layout.setContentsMargins(12, 4, 12, 4)
        import_content_layout.setSpacing(4)

        self.mappa_import_scroll = QScrollArea()
        self.mappa_import_scroll.setWidgetResizable(True)
        self.mappa_import_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.mappa_import_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.mappa_import_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        self.mappa_import_scroll.setMaximumHeight(150)
        self.mappa_import_scroll.setStyleSheet("""
            QScrollArea { background: transparent; border: none; }
            QScrollArea > QWidget > QWidget { background: transparent; }
        """)

        self.mappa_import_widget = QWidget()
        self.mappa_import_widget.setStyleSheet("background: transparent;")
        self.mappa_import_layout = QVBoxLayout(self.mappa_import_widget)
        self.mappa_import_layout.setContentsMargins(2, 2, 2, 2)
        self.mappa_import_layout.setSpacing(4)
        self.mappa_import_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        self.mappa_import_placeholder = QLabel("No MAPPA notes found. Import notes to search for MAPPA entries.")
        self.mappa_import_placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 13px; background: transparent; border: none;")
        self.mappa_import_placeholder.setWordWrap(True)
        self.mappa_import_layout.addWidget(self.mappa_import_placeholder)

        self.mappa_import_scroll.setWidget(self.mappa_import_widget)
        import_content_layout.addWidget(self.mappa_import_scroll)

        import_main_layout.addWidget(self.mappa_import_content)
        mappa_details_layout.addWidget(import_container)

        # Toggle collapse for imports
        def toggle_import():
            visible = not self.mappa_import_content.isVisible()
            self.mappa_import_content.setVisible(visible)
            self.mappa_import_btn.setText("-" if visible else "+")
        self.mappa_import_btn.clicked.connect(toggle_import)

        # Storage for imported MAPPA entries
        self.mappa_imported_entries = []

        # Initially hide the details container
        self.mappa_details_container.setVisible(False)
        content_layout.addWidget(self.mappa_details_container)

        # Connect Yes/No radios to show/hide details
        def on_mappa_eligible_changed():
            self.mappa_details_container.setVisible(self.mappa_eligible_yes.isChecked())
            self._update_mappa_preview()

        self.mappa_eligible_yes.toggled.connect(on_mappa_eligible_changed)
        self.mappa_eligible_no.toggled.connect(on_mappa_eligible_changed)

        content_layout.addStretch()
        content_scroll.setWidget(content_widget)
        main_layout.addWidget(content_scroll)

        # Register generator
        def generate_mappa_text():
            return self.mappa_preview.text().strip()
        self.popup_generators["mappa"] = generate_mappa_text

        self._update_mappa_preview()

        # Apply stored MAPPA detection (from import)
        if hasattr(self, '_extracted_patient_details') and self._extracted_patient_details:
            from PySide6.QtCore import QTimer
            def apply_mappa_data():
                mappa_eligible = self._extracted_patient_details.get('mappa_eligible', False)
                mappa_coordinator = self._extracted_patient_details.get('mappa_coordinator', '')
                mappa_category = self._extracted_patient_details.get('mappa_category')
                mappa_level = self._extracted_patient_details.get('mappa_level')
                mappa_entries = self._extracted_patient_details.get('mappa_entries', [])

                if mappa_eligible:
                    self.mappa_eligible_yes.setChecked(True)
                    print(f"[MOJ-LEAVE] 5 popup: Applied MAPPA eligible = YES")

                    # Set coordinator if found
                    if mappa_coordinator and hasattr(self, 'mappa_coordinator'):
                        self.mappa_coordinator.setPlainText(mappa_coordinator)
                        print(f"[MOJ-LEAVE] 5 popup: Applied MAPPA coordinator: {mappa_coordinator}")

                    # Set category if found
                    if mappa_category and hasattr(self, 'mappa_categories'):
                        cat_key = f"Category {mappa_category}"
                        if cat_key in self.mappa_categories:
                            self.mappa_categories[cat_key].setChecked(True)
                            print(f"[MOJ-LEAVE] 5 popup: Applied MAPPA Category {mappa_category}")

                    # Set level if found
                    if mappa_level and hasattr(self, 'mappa_levels'):
                        lvl_key = f"Level {mappa_level}"
                        if lvl_key in self.mappa_levels:
                            self.mappa_levels[lvl_key].setChecked(True)
                            print(f"[MOJ-LEAVE] 5 popup: Applied MAPPA Level {mappa_level}")

                    # For Level 1: Set notification submitted to No, will submit prior to leave to Yes
                    if mappa_level == 1:
                        if hasattr(self, 'mappa_l1_notif_no'):
                            self.mappa_l1_notif_no.setChecked(True)
                            print(f"[MOJ-LEAVE] 5 popup: Set MAPPA notification submitted = NO")
                        if hasattr(self, 'mappa_l1_will_yes'):
                            self.mappa_l1_will_yes.setChecked(True)
                            print(f"[MOJ-LEAVE] 5 popup: Set will submit prior to leave = YES")
                else:
                    self.mappa_eligible_no.setChecked(True)
                    print(f"[MOJ-LEAVE] 5 popup: Applied MAPPA eligible = NO")

                # Populate imported entries
                if mappa_entries:
                    self._populate_mappa_imports(mappa_entries)

                self._update_mappa_preview()
            QTimer.singleShot(100, apply_mappa_data)

        return popup

    def _populate_mappa_imports(self, entries):
        """Populate the MAPPA imported data section matching 4a style."""
        if not hasattr(self, 'mappa_import_layout'):
            return

        # Clear existing entries
        while self.mappa_import_layout.count():
            item = self.mappa_import_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        if not entries:
            placeholder = QLabel("No MAPPA-related entries found in imported data.")
            placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 14px; background: transparent; border: none;")
            self.mappa_import_layout.addWidget(placeholder)
            self.mappa_import_count.setText("0 entries")
            return

        self.mappa_imported_entries = []
        self.mappa_import_checkboxes = []

        for entry in entries:
            text = entry.get('text', '')
            date_str = entry.get('date', '') or ''
            keyword = entry.get('keyword', 'unknown')

            entry_frame = QFrame()
            entry_frame.setObjectName("entryFrame")
            entry_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            entry_frame.setStyleSheet("QFrame#entryFrame { background: rgba(255, 255, 255, 0.95); border: 1px solid rgba(180, 150, 50, 0.4); border-radius: 8px; padding: 4px; }")
            entry_layout = QVBoxLayout(entry_frame)
            entry_layout.setContentsMargins(10, 4, 16, 4)
            entry_layout.setSpacing(6)


            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("QPushButton { background: rgba(180, 150, 50, 0.2); border: none; border-radius: 4px; font-size: 15px; font-weight: bold; color: #806000; } QPushButton:hover { background: rgba(180, 150, 50, 0.35); }")
            header_row.addWidget(toggle_btn)

            # Date label (first after toggle)
            if date_str:
                date_label = QLabel(f"\U0001f4c5 {date_str}")
                date_label.setStyleSheet("font-size: 15px; font-weight: 600; color: #806000; background: transparent; border: none;")
                date_label.setCursor(Qt.CursorShape.PointingHandCursor)
                header_row.addWidget(date_label)

            keyword_tag = QLabel(f"MAPPA: {keyword}")
            keyword_tag.setStyleSheet("background: #fef3c7; color: #806000; padding: 4px 10px; border-radius: 3px; font-size: 14px; font-weight: 600;")
            header_row.addWidget(keyword_tag)

            header_row.addStretch()

            cb = QCheckBox()
            cb.setProperty("full_text", text)
            cb.setFixedSize(20, 20)
            cb.setStyleSheet("QCheckBox { background: transparent; margin-right: 4px; } QCheckBox::indicator { width: 18px; height: 18px; }")
            header_row.addWidget(cb)

            entry_layout.addLayout(header_row)

            body_text = QTextEdit()
            body_text.setPlainText(text)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("QTextEdit { font-size: 15px; color: #333; background: rgba(255, 248, 220, 0.5); border: none; padding: 8px; border-radius: 6px; }")
            body_text.document().setTextWidth(350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            entry_layout.addWidget(body_text)

            def make_toggle(btn, body, frame):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    frame.updateGeometry()
                return toggle
            toggle_fn = make_toggle(toggle_btn, body_text, entry_frame)
            toggle_btn.clicked.connect(toggle_fn)
            if date_str:
                date_label.mousePressEvent = lambda e, fn=toggle_fn: fn()

            self.mappa_import_layout.addWidget(entry_frame)
            self.mappa_imported_entries.append(entry)
            self.mappa_import_checkboxes.append({"checkbox": cb, "text": text, "frame": entry_frame})

        self.mappa_import_count.setText(f"{len(entries)} entries")
        print(f"[MOJ-LEAVE] 5 popup: Populated {len(entries)} MAPPA entries (4a style)")

    def _update_mappa_level_visibility(self):
        """Show/hide level-specific sections based on selected level."""
        if not hasattr(self, 'mappa_levels'):
            return

        level1 = self.mappa_levels.get("Level 1", None)
        level2 = self.mappa_levels.get("Level 2", None)
        level3 = self.mappa_levels.get("Level 3", None)

        is_level1 = level1 and level1.isChecked()
        is_level23 = (level2 and level2.isChecked()) or (level3 and level3.isChecked())

        if hasattr(self, 'mappa_level1_container'):
            self.mappa_level1_container.setVisible(is_level1)
        if hasattr(self, 'mappa_level23_container'):
            self.mappa_level23_container.setVisible(is_level23)

    def _update_mappa_l1_visibility(self):
        """Show/hide 'will submit' question based on Level 1 notification answer."""
        if hasattr(self, 'mappa_l1_notif_no') and hasattr(self, 'mappa_l1_will_submit_container'):
            self.mappa_l1_will_submit_container.setVisible(self.mappa_l1_notif_no.isChecked())

    def _update_mappa_preview(self):
        """Update the MAPPA preview text."""
        if not hasattr(self, 'mappa_preview'):
            return

        parts = []

        # Check if No is selected (not convicted of MAPPA eligible offence)
        if hasattr(self, 'mappa_eligible_no') and self.mappa_eligible_no.isChecked():
            text = "Non MAPPA eligible"
            self.mappa_preview.setText(text)
            # Auto-sync to card - preserve user additions
            if "mappa" in self.cards:
                self._update_text_preserving_additions(self.cards["mappa"].editor, text, "mappa")
            return

        # If Yes is selected, show full MAPPA details
        if hasattr(self, 'mappa_eligible_yes') and self.mappa_eligible_yes.isChecked():
            # Coordinator
            coord = self.mappa_coordinator.toPlainText().strip() if hasattr(self, 'mappa_coordinator') else ""
            if coord:
                parts.append(f"MAPPA Coordinator: {coord}")
            # Category
            if hasattr(self, 'mappa_categories'):
                for cat, rb in self.mappa_categories.items():
                    if rb.isChecked():
                        parts.append(f"MAPPA {cat}.")
                        break

            # Level
            selected_level = None
            if hasattr(self, 'mappa_levels'):
                for lvl, rb in self.mappa_levels.items():
                    if rb.isChecked():
                        selected_level = lvl
                        parts.append(f"Managed at {lvl}.")
                        break

            # Level 1 specifics
            if selected_level == "Level 1":
                if hasattr(self, 'mappa_l1_notif_yes') and self.mappa_l1_notif_yes.isChecked():
                    parts.append("MAPPA I notification has been submitted.")
                elif hasattr(self, 'mappa_l1_notif_no') and self.mappa_l1_notif_no.isChecked():
                    if hasattr(self, 'mappa_l1_will_yes') and self.mappa_l1_will_yes.isChecked():
                        parts.append("MAPPA I notification will be submitted prior to leave.")
                    elif hasattr(self, 'mappa_l1_will_no') and self.mappa_l1_will_no.isChecked():
                        parts.append("MAPPA I notification has NOT been submitted.")

            # Level 2/3 specifics
            if selected_level in ["Level 2", "Level 3"]:
                if hasattr(self, 'mappa_l23_notif_yes') and self.mappa_l23_notif_yes.isChecked():
                    parts.append("MAPPA I notification submitted and response received.")
                elif hasattr(self, 'mappa_l23_notif_no') and self.mappa_l23_notif_no.isChecked():
                    parts.append("MAPPA response NOT yet received.")

                # Response details
                reason = self.mappa_level_reason.toPlainText().strip() if hasattr(self, 'mappa_level_reason') else ""
                if reason:
                    parts.append(f"Level rationale: {reason}")

            # Include imported MAPPA notes (checked entries)
            if hasattr(self, 'mappa_imported_entries'):
                imported = []
                for entry in self.mappa_imported_entries:
                    if entry.get("checkbox") and entry["checkbox"].isChecked():
                        text = entry.get("text", "")
                        date = entry.get("date", "")
                        if date:
                            imported.append(f"[{date}] {text}")
                        else:
                            imported.append(text)
                if imported:
                    parts.append("\n--- Imported MAPPA Notes ---\n" + "\n".join(imported))

        if parts:
            text = " ".join(parts)
            self.mappa_preview.setText(text)
            # Auto-sync to card - preserve user additions
            if "mappa" in self.cards:
                self._update_text_preserving_additions(self.cards["mappa"].editor, text, "mappa")
        else:
            self.mappa_preview.setText("No MAPPA information entered.")

    def _search_mappa_in_notes(self, notes_text: str):
        """Search for MAPPA related entries in imported notes and populate the import section."""
        if not hasattr(self, 'mappa_import_layout'):
            return

        # Clear existing entries
        for entry in getattr(self, 'mappa_imported_entries', []):
            if entry.get("widget"):
                entry["widget"].deleteLater()
        self.mappa_imported_entries = []

        # Hide placeholder initially (safely handle deleted Qt objects)
        if hasattr(self, 'mappa_import_placeholder'):
            try:
                self.mappa_import_placeholder.hide()
            except RuntimeError:
                self.mappa_import_placeholder = None

        # MAPPA keywords to search for
        mappa_keywords = [
            "mappa", "multi-agency public protection", "category 1", "category 2",
            "category 3", "level 1", "level 2", "level 3", "public protection",
            "offender manager", "probation", "mappa coordinator"
        ]

        lines = notes_text.split('\n')
        found_entries = []

        for line in lines:
            line_lower = line.lower()
            for keyword in mappa_keywords:
                if keyword in line_lower:
                    # Extract date if present
                    date_match = None
                    import re
                    date_patterns = [
                        r'(\d{1,2}/\d{1,2}/\d{2,4})',
                        r'(\d{1,2}-\d{1,2}-\d{2,4})',
                        r'(\d{1,2}\s+\w+\s+\d{4})'
                    ]
                    for pattern in date_patterns:
                        match = re.search(pattern, line)
                        if match:
                            date_match = match.group(1)
                            break

                    if line.strip() and line.strip() not in [e.get("text") for e in found_entries]:
                        found_entries.append({
                            "text": line.strip()[:200],
                            "date": date_match or ""
                        })
                    break

        # Add entries to the import layout
        if found_entries:
            for entry_data in found_entries[:20]:  # Limit to 20 entries
                entry_widget = QWidget()
                entry_layout = QHBoxLayout(entry_widget)
                entry_layout.setContentsMargins(0, 2, 0, 2)
                entry_layout.setSpacing(6)

                cb = QCheckBox()
                cb.setStyleSheet("QCheckBox { background: transparent; }")
                cb.toggled.connect(self._update_mappa_preview)
                entry_layout.addWidget(cb)

                text = entry_data["text"]
                if entry_data["date"]:
                    text = f"[{entry_data['date']}] {text}"
                lbl = QLabel(text)
                lbl.setStyleSheet("font-size: 14px; color: #374151;")
                lbl.setWordWrap(True)
                entry_layout.addWidget(lbl, 1)

                self.mappa_import_layout.addWidget(entry_widget)

                self.mappa_imported_entries.append({
                    "widget": entry_widget,
                    "checkbox": cb,
                    "text": entry_data["text"],
                    "date": entry_data["date"]
                })

            # Expand the import section
            if hasattr(self, 'mappa_import_content'):
                self.mappa_import_content.setVisible(True)
            if hasattr(self, 'mappa_import_btn'):
                self.mappa_import_btn.setText("-")
        else:
            # Show placeholder if no entries found (safely handle deleted Qt objects)
            if hasattr(self, 'mappa_import_placeholder') and self.mappa_import_placeholder:
                try:
                    self.mappa_import_placeholder.show()
                except RuntimeError:
                    self.mappa_import_placeholder = None

    def _create_victims_popup(self) -> QWidget:
        """Create Victims popup with structured form fields and preview."""
        key = "victims"
        popup = QWidget()
        popup.setObjectName(f"popup_{key}")
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)

        # Hidden label to store text for auto-sync to card
        self.victims_preview = QLabel()
        self.victims_preview.hide()

        # --- CONTENT PANEL (bottom) ---
        content_scroll = QScrollArea()
        content_scroll.setWidgetResizable(True)
        content_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        content_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        content_scroll.setStyleSheet("QScrollArea { background: transparent; border: none; }")

        content_widget = QWidget()
        content_widget.setStyleSheet("background: transparent;")
        content_widget.setSizePolicy(QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Preferred)
        content_layout = QVBoxLayout(content_widget)
        content_layout.setContentsMargins(8, 8, 8, 8)
        content_layout.setSpacing(10)

        scroll_content = QWidget()
        scroll_content.setSizePolicy(QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Preferred)
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setContentsMargins(4, 4, 4, 4)
        scroll_layout.setSpacing(10)

        # ========== SECTION 6a: VLO Contact Details ==========
        sec_a = QWidget()
        sec_a.setStyleSheet("background: #dbeafe; border-radius: 6px;")
        sec_a_layout = QVBoxLayout(sec_a)
        sec_a_layout.setContentsMargins(10, 8, 10, 8)
        sec_a_layout.setSpacing(6)

        sec_a_title = QLabel("6a. Victim Liaison Officer (VLO)")
        sec_a_title.setStyleSheet("font-weight: 700; font-size: 14px; color: #1e40af;")
        sec_a_layout.addWidget(sec_a_title)

        vlo_lbl = QLabel("Name and contact details of VLO(s):")
        vlo_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        sec_a_layout.addWidget(vlo_lbl)

        self.victims_vlo_contact = QTextEdit()
        self.victims_vlo_contact.setPlaceholderText("Enter VLO name and contact details...")
        self.victims_vlo_contact.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white;")
        self.victims_vlo_contact.setMaximumHeight(60)
        self.victims_vlo_contact.textChanged.connect(self._update_victims_preview)
        sec_a_layout.addWidget(self.victims_vlo_contact)

        scroll_layout.addWidget(sec_a)

        # ========== SECTION 6b: VLO Contacted ==========
        sec_b = QWidget()
        sec_b.setStyleSheet("background: #fef3c7; border-radius: 6px;")
        sec_b_layout = QVBoxLayout(sec_b)
        sec_b_layout.setContentsMargins(10, 8, 10, 8)
        sec_b_layout.setSpacing(6)

        sec_b_title = QLabel("6b. VLO Contact Status")
        sec_b_title.setStyleSheet("font-weight: 700; font-size: 14px; color: #92400e;")
        sec_b_layout.addWidget(sec_b_title)

        contacted_row = QHBoxLayout()
        contacted_lbl = QLabel("Has VLO been contacted regarding this application?")
        contacted_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        contacted_row.addWidget(contacted_lbl)

        self.victims_contacted_group = QButtonGroup(popup)
        self.victims_contacted_yes = QRadioButton("Yes")
        self.victims_contacted_no = QRadioButton("No")
        self.victims_contacted_yes.setStyleSheet("font-size: 13px;")
        self.victims_contacted_no.setStyleSheet("font-size: 13px;")
        self.victims_contacted_group.addButton(self.victims_contacted_yes)
        self.victims_contacted_group.addButton(self.victims_contacted_no)
        self.victims_contacted_yes.toggled.connect(self._update_victims_preview)
        self.victims_contacted_no.toggled.connect(self._update_victims_preview)
        contacted_row.addWidget(self.victims_contacted_yes)
        contacted_row.addWidget(self.victims_contacted_no)
        contacted_row.addStretch()
        sec_b_layout.addLayout(contacted_row)

        scroll_layout.addWidget(sec_b)

        # ========== SECTION 6c: VLO Reply ==========
        sec_c = QWidget()
        sec_c.setStyleSheet("background: #dcfce7; border-radius: 6px;")
        sec_c_layout = QVBoxLayout(sec_c)
        sec_c_layout.setContentsMargins(10, 8, 10, 8)
        sec_c_layout.setSpacing(6)

        sec_c_title = QLabel("6c. VLO Response")
        sec_c_title.setStyleSheet("font-weight: 700; font-size: 14px; color: #166534;")
        sec_c_layout.addWidget(sec_c_title)

        reply_lbl = QLabel("When did the VLO reply?")
        reply_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        sec_c_layout.addWidget(reply_lbl)

        self.victims_reply_date = QLineEdit()
        self.victims_reply_date.setPlaceholderText("Enter date or status (e.g., 'Awaiting response', 'Case is dormant')...")
        self.victims_reply_date.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white;")
        self.victims_reply_date.textChanged.connect(self._update_victims_preview)
        sec_c_layout.addWidget(self.victims_reply_date)

        scroll_layout.addWidget(sec_c)

        # ========== SECTION 6d: Victim Conditions ==========
        sec_d = QWidget()
        sec_d.setStyleSheet("background: #fae8ff; border-radius: 6px;")
        sec_d_layout = QVBoxLayout(sec_d)
        sec_d_layout.setContentsMargins(10, 8, 10, 8)
        sec_d_layout.setSpacing(6)

        sec_d_title = QLabel("6d. Conditions Requested by Victim(s)")
        sec_d_title.setStyleSheet("font-weight: 700; font-size: 14px; color: #86198f;")
        sec_d_layout.addWidget(sec_d_title)

        cond_lbl = QLabel("Non-contact conditions, exclusion zones, etc:")
        cond_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        sec_d_layout.addWidget(cond_lbl)

        self.victims_conditions = QTextEdit()
        self.victims_conditions.setPlaceholderText("Copy directly from VLO's email reply. Include any exclusion zone maps as attachments...")
        self.victims_conditions.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white;")
        self.victims_conditions.setMaximumHeight(80)
        self.victims_conditions.textChanged.connect(self._update_victims_preview)
        sec_d_layout.addWidget(self.victims_conditions)

        scroll_layout.addWidget(sec_d)

        # ========== SECTION 6e: No VLO - Victim Concerns ==========
        sec_e = QWidget()
        sec_e.setStyleSheet("background: #fee2e2; border-radius: 6px;")
        sec_e_layout = QVBoxLayout(sec_e)
        sec_e_layout.setContentsMargins(10, 8, 10, 8)
        sec_e_layout.setSpacing(6)

        sec_e_title = QLabel("6e. Victim Concerns (if no VLO or victim contact)")
        sec_e_title.setStyleSheet("font-weight: 700; font-size: 14px; color: #991b1b;")
        sec_e_layout.addWidget(sec_e_title)

        risk_lbl = QLabel("Risk assessment to victims (attitude, remorse, empathy, plans):")
        risk_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        sec_e_layout.addWidget(risk_lbl)

        self.victims_risk_assessment = QTextEdit()
        self.victims_risk_assessment.setPlaceholderText("Explain assessment of risk patient presents to victims...")
        self.victims_risk_assessment.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white;")
        self.victims_risk_assessment.setMaximumHeight(60)
        self.victims_risk_assessment.textChanged.connect(self._update_victims_preview)
        sec_e_layout.addWidget(self.victims_risk_assessment)

        clinical_lbl = QLabel("Clinical considerations (domestic violence, previous offending):")
        clinical_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        sec_e_layout.addWidget(clinical_lbl)

        self.victims_clinical = QTextEdit()
        self.victims_clinical.setPlaceholderText("Any clinical considerations relevant to this application...")
        self.victims_clinical.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white;")
        self.victims_clinical.setMaximumHeight(60)
        self.victims_clinical.textChanged.connect(self._update_victims_preview)
        sec_e_layout.addWidget(self.victims_clinical)

        scroll_layout.addWidget(sec_e)

        scroll_layout.addStretch()
        content_scroll.setWidget(scroll_content)
        main_layout.addWidget(content_scroll)

        # Register generator
        def generate_victims_text():
            return self.victims_preview.text().strip()
        self.popup_generators["victims"] = generate_victims_text

        self._update_victims_preview()
        return popup

    def _update_victims_preview(self):
        """Update the victims preview text."""
        if not hasattr(self, 'victims_preview'):
            return

        parts = []

        # VLO Contact
        vlo = self.victims_vlo_contact.toPlainText().strip() if hasattr(self, 'victims_vlo_contact') else ""
        if vlo:
            parts.append(f"VLO: {vlo}")

        # Contacted?
        if hasattr(self, 'victims_contacted_yes') and self.victims_contacted_yes.isChecked():
            parts.append("VLO has been contacted regarding this application.")
        elif hasattr(self, 'victims_contacted_no') and self.victims_contacted_no.isChecked():
            parts.append("VLO has NOT been contacted.")

        # Reply date
        reply = self.victims_reply_date.text().strip() if hasattr(self, 'victims_reply_date') else ""
        if reply:
            parts.append(f"VLO response: {reply}")

        # Conditions
        conditions = self.victims_conditions.toPlainText().strip() if hasattr(self, 'victims_conditions') else ""
        if conditions:
            parts.append(f"Victim conditions: {conditions}")

        # Risk assessment
        risk = self.victims_risk_assessment.toPlainText().strip() if hasattr(self, 'victims_risk_assessment') else ""
        if risk:
            parts.append(f"Risk to victims: {risk}")

        # Clinical considerations
        clinical = self.victims_clinical.toPlainText().strip() if hasattr(self, 'victims_clinical') else ""
        if clinical:
            parts.append(f"Clinical considerations: {clinical}")

        if parts:
            text = " ".join(parts)
            self.victims_preview.setText(text)
            # Auto-sync to card - preserve user additions
            if "victims" in self.cards:
                self._update_text_preserving_additions(self.cards["victims"].editor, text, "victims")
        else:
            self.victims_preview.setText("No victim information entered.")

    def _create_transferred_prisoners_popup(self) -> QWidget:
        """Create Transferred Prisoners popup with structured form fields and preview."""
        key = "transferred_prisoners"
        popup = QWidget()
        popup.setStyleSheet("background: #f9fafb;")
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)

        # Hidden label to store text for auto-sync to card
        self.prisoners_preview = QLabel()
        self.prisoners_preview.hide()

        # --- CONTENT PANEL (bottom) ---
        content_scroll = QScrollArea()
        content_scroll.setWidgetResizable(True)
        content_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        content_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        content_scroll.setStyleSheet("QScrollArea { background: transparent; }")

        scroll_content = QWidget()
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setContentsMargins(4, 4, 4, 4)
        scroll_layout.setSpacing(10)

        # ============================================================
        # TRANSFERRED PRISONER? Yes / N/A
        # ============================================================
        prisoner_frame = QWidget()
        prisoner_frame.setStyleSheet("background: #fef3c7; border-radius: 6px;")
        prisoner_layout = QVBoxLayout(prisoner_frame)
        prisoner_layout.setContentsMargins(12, 10, 12, 10)
        prisoner_layout.setSpacing(8)

        prisoner_lbl = QLabel("<b>Transferred Prisoner (s47/48/49 or s45A)?</b>")
        prisoner_lbl.setStyleSheet("font-size: 14px; color: #92400e;")
        prisoner_layout.addWidget(prisoner_lbl)

        prisoner_row = QHBoxLayout()
        self.prisoners_applicable_group = QButtonGroup(popup)
        self.prisoners_applicable_yes = QRadioButton("Yes")
        self.prisoners_applicable_na = QRadioButton("N/A")
        self.prisoners_applicable_yes.setStyleSheet("font-size: 13px;")
        self.prisoners_applicable_na.setStyleSheet("font-size: 13px;")
        self.prisoners_applicable_na.setChecked(True)  # Default to N/A
        self.prisoners_applicable_group.addButton(self.prisoners_applicable_yes)
        self.prisoners_applicable_group.addButton(self.prisoners_applicable_na)
        prisoner_row.addWidget(self.prisoners_applicable_yes)
        prisoner_row.addWidget(self.prisoners_applicable_na)
        prisoner_row.addStretch()
        prisoner_layout.addLayout(prisoner_row)

        scroll_layout.addWidget(prisoner_frame)

        # ============================================================
        # TRANSFERRED PRISONER DETAILS CONTAINER (shown when Yes)
        # ============================================================
        self.prisoners_details_container = QWidget()
        prisoners_details_layout = QVBoxLayout(self.prisoners_details_container)
        prisoners_details_layout.setContentsMargins(0, 0, 0, 0)
        prisoners_details_layout.setSpacing(10)

        # ========== Info Banner ==========
        info_banner = QLabel("Complete this section if patient is a s47/48/49 transferred prisoner or s45A hospital direction.")
        info_banner.setStyleSheet("background: #e0e7ff; color: #3730a3; font-size: 13px; padding: 6px; border-radius: 4px;")
        info_banner.setWordWrap(True)
        prisoners_details_layout.addWidget(info_banner)

        # ========== SECTION 7a: Offender Manager Details ==========
        sec_a = QWidget()
        sec_a.setStyleSheet("background: #dbeafe; border-radius: 6px;")
        sec_a_layout = QVBoxLayout(sec_a)
        sec_a_layout.setContentsMargins(10, 8, 10, 8)
        sec_a_layout.setSpacing(6)

        sec_a_title = QLabel("7a. Offender Manager (Probation Officer)")
        sec_a_title.setStyleSheet("font-weight: 700; font-size: 14px; color: #1e40af;")
        sec_a_layout.addWidget(sec_a_title)

        om_lbl = QLabel("Name and contact details:")
        om_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        sec_a_layout.addWidget(om_lbl)

        self.prisoners_om_contact = QTextEdit()
        self.prisoners_om_contact.setPlaceholderText("Details available from the transferring prison...")
        self.prisoners_om_contact.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white;")
        self.prisoners_om_contact.setMaximumHeight(60)
        self.prisoners_om_contact.textChanged.connect(self._update_prisoners_preview)
        sec_a_layout.addWidget(self.prisoners_om_contact)

        prisoners_details_layout.addWidget(sec_a)

        # ========== SECTION 7b: OM Notified ==========
        sec_b = QWidget()
        sec_b.setStyleSheet("background: #fef3c7; border-radius: 6px;")
        sec_b_layout = QVBoxLayout(sec_b)
        sec_b_layout.setContentsMargins(10, 8, 10, 8)
        sec_b_layout.setSpacing(6)

        sec_b_title = QLabel("7b. Offender Manager Notification")
        sec_b_title.setStyleSheet("font-weight: 700; font-size: 14px; color: #92400e;")
        sec_b_layout.addWidget(sec_b_title)

        notified_row = QHBoxLayout()
        notified_lbl = QLabel("Has Offender Manager been notified of this application?")
        notified_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        notified_row.addWidget(notified_lbl)

        self.prisoners_notified_group = QButtonGroup(popup)
        self.prisoners_notified_yes = QRadioButton("Yes")
        self.prisoners_notified_no = QRadioButton("No")
        self.prisoners_notified_yes.setStyleSheet("font-size: 13px;")
        self.prisoners_notified_no.setStyleSheet("font-size: 13px;")
        self.prisoners_notified_group.addButton(self.prisoners_notified_yes)
        self.prisoners_notified_group.addButton(self.prisoners_notified_no)
        self.prisoners_notified_yes.toggled.connect(self._update_prisoners_preview)
        self.prisoners_notified_no.toggled.connect(self._update_prisoners_preview)
        notified_row.addWidget(self.prisoners_notified_yes)
        notified_row.addWidget(self.prisoners_notified_no)
        notified_row.addStretch()
        sec_b_layout.addLayout(notified_row)

        prisoners_details_layout.addWidget(sec_b)

        # ========== SECTION 7c: OM Response ==========
        sec_c = QWidget()
        sec_c.setStyleSheet("background: #dcfce7; border-radius: 6px;")
        sec_c_layout = QVBoxLayout(sec_c)
        sec_c_layout.setContentsMargins(10, 8, 10, 8)
        sec_c_layout.setSpacing(6)

        sec_c_title = QLabel("7c. Offender Manager Response")
        sec_c_title.setStyleSheet("font-weight: 700; font-size: 14px; color: #166534;")
        sec_c_layout.addWidget(sec_c_title)

        response_lbl = QLabel("Response to leave proposal (issues/concerns raised):")
        response_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        sec_c_layout.addWidget(response_lbl)

        self.prisoners_response = QTextEdit()
        self.prisoners_response.setPlaceholderText("Detail their response including any issues or concerns raised. Ensure remission has been considered...")
        self.prisoners_response.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white;")
        self.prisoners_response.setMaximumHeight(80)
        self.prisoners_response.textChanged.connect(self._update_prisoners_preview)
        sec_c_layout.addWidget(self.prisoners_response)

        prisoners_details_layout.addWidget(sec_c)

        # ========== SECTION 7d: Remission to Prison ==========
        sec_d = QWidget()
        sec_d.setStyleSheet("background: #fae8ff; border-radius: 6px;")
        sec_d_layout = QVBoxLayout(sec_d)
        sec_d_layout.setContentsMargins(10, 8, 10, 8)
        sec_d_layout.setSpacing(6)

        sec_d_title = QLabel("7d. Remission to Prison Consideration")
        sec_d_title.setStyleSheet("font-weight: 700; font-size: 14px; color: #86198f;")
        sec_d_layout.addWidget(sec_d_title)

        prognosis_lbl = QLabel("Prognosis of when patient will be returned to prison:")
        prognosis_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        sec_d_layout.addWidget(prognosis_lbl)

        self.prisoners_prognosis = QTextEdit()
        self.prisoners_prognosis.setPlaceholderText("Where possible, give a prognosis...")
        self.prisoners_prognosis.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white;")
        self.prisoners_prognosis.setMaximumHeight(50)
        self.prisoners_prognosis.textChanged.connect(self._update_prisoners_preview)
        sec_d_layout.addWidget(self.prisoners_prognosis)

        factors_lbl = QLabel("Factors meaning remission is not appropriate:")
        factors_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        sec_d_layout.addWidget(factors_lbl)

        self.prisoners_factors = QTextEdit()
        self.prisoners_factors.setPlaceholderText("Outline factors which mean remission is not considered appropriate at this time...")
        self.prisoners_factors.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white;")
        self.prisoners_factors.setMaximumHeight(50)
        self.prisoners_factors.textChanged.connect(self._update_prisoners_preview)
        sec_d_layout.addWidget(self.prisoners_factors)

        timeframe_lbl = QLabel("Indicative timeframes/treatment requirements:")
        timeframe_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        sec_d_layout.addWidget(timeframe_lbl)

        self.prisoners_timeframe = QTextEdit()
        self.prisoners_timeframe.setPlaceholderText("Where remission is not appropriate, give indicative timeframes and/or treatment requirements...")
        self.prisoners_timeframe.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white;")
        self.prisoners_timeframe.setMaximumHeight(50)
        self.prisoners_timeframe.textChanged.connect(self._update_prisoners_preview)
        sec_d_layout.addWidget(self.prisoners_timeframe)

        unlikely_lbl = QLabel("If unlikely to return to prison, explain clinical view:")
        unlikely_lbl.setStyleSheet("font-size: 13px; font-weight: 600;")
        sec_d_layout.addWidget(unlikely_lbl)

        self.prisoners_unlikely = QTextEdit()
        self.prisoners_unlikely.setPlaceholderText("If considered that patient is unlikely to be returned to prison, explain why...")
        self.prisoners_unlikely.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white;")
        self.prisoners_unlikely.setMaximumHeight(50)
        self.prisoners_unlikely.textChanged.connect(self._update_prisoners_preview)
        sec_d_layout.addWidget(self.prisoners_unlikely)

        prisoners_details_layout.addWidget(sec_d)

        # ============================================================
        # COLLAPSIBLE IMPORTED DATA SECTION (matching 4a style)
        # ============================================================
        prisoners_import_container = QWidget()
        prisoners_import_container.setStyleSheet("""
            QWidget {
                background: rgba(255, 248, 220, 0.95);
                border: 1px solid rgba(180, 150, 50, 0.4);
                border-radius: 12px;
            }
            QCheckBox {
                background: transparent;
                border: none;
                padding: 4px;
                font-size: 14px;
                color: #4a4a4a;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
        """)
        prisoners_import_main_layout = QVBoxLayout(prisoners_import_container)
        prisoners_import_main_layout.setContentsMargins(12, 10, 12, 10)
        prisoners_import_main_layout.setSpacing(6)

        # Header with collapse button
        prisoners_import_header = QHBoxLayout()
        self.prisoners_import_collapse_btn = QPushButton("-")
        self.prisoners_import_collapse_btn.setFixedSize(20, 20)
        self.prisoners_import_collapse_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.prisoners_import_collapse_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #806000; background: rgba(255, 248, 220, 0.95); border: 1px solid rgba(180, 150, 50, 0.4); border-radius: 4px; } QPushButton:hover { background: #fef3c7; }")
        prisoners_import_header.addWidget(self.prisoners_import_collapse_btn)

        prisoners_import_title = QLabel("Imported Data - Offender Manager / Remission")
        prisoners_import_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #806000; background: transparent; border: none;")
        prisoners_import_header.addWidget(prisoners_import_title)
        prisoners_import_header.addStretch()

        self.prisoners_import_count = QLabel("0 entries")
        self.prisoners_import_count.setStyleSheet("font-size: 13px; color: #806000; background: transparent; border: none;")
        prisoners_import_header.addWidget(self.prisoners_import_count)

        prisoners_import_main_layout.addLayout(prisoners_import_header)

        # Collapsible content - scrollable area for entries
        self.prisoners_import_content = QWidget()
        self.prisoners_import_content.setStyleSheet("background: transparent; border: none;")
        prisoners_import_content_layout = QVBoxLayout(self.prisoners_import_content)
        prisoners_import_content_layout.setContentsMargins(12, 4, 12, 4)
        prisoners_import_content_layout.setSpacing(4)

        # Scroll area for imported entries
        prisoners_import_scroll = QScrollArea()
        prisoners_import_scroll.setWidgetResizable(True)
        prisoners_import_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        prisoners_import_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        prisoners_import_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        prisoners_import_scroll.setMaximumHeight(250)
        prisoners_import_scroll.setStyleSheet("""
            QScrollArea { background: transparent; border: none; }
            QScrollArea > QWidget > QWidget { background: transparent; }
        """)

        self.prisoners_import_entries_widget = QWidget()
        self.prisoners_import_entries_widget.setStyleSheet("background: transparent;")
        self.prisoners_import_layout = QVBoxLayout(self.prisoners_import_entries_widget)
        self.prisoners_import_layout.setContentsMargins(2, 2, 2, 2)
        self.prisoners_import_layout.setSpacing(4)
        self.prisoners_import_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # Placeholder
        self.prisoners_import_placeholder = QLabel("No offender manager or remission-related entries found.")
        self.prisoners_import_placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 13px; background: transparent; border: none;")
        self.prisoners_import_layout.addWidget(self.prisoners_import_placeholder)

        prisoners_import_scroll.setWidget(self.prisoners_import_entries_widget)
        prisoners_import_content_layout.addWidget(prisoners_import_scroll)

        prisoners_import_main_layout.addWidget(self.prisoners_import_content)
        prisoners_details_layout.addWidget(prisoners_import_container)

        # Toggle function for import collapse
        def toggle_prisoners_import():
            visible = not self.prisoners_import_content.isVisible()
            self.prisoners_import_content.setVisible(visible)
            self.prisoners_import_collapse_btn.setText("-" if visible else "+")
        self.prisoners_import_collapse_btn.clicked.connect(toggle_prisoners_import)

        # Storage for imported entries
        self.prisoners_imported_entries = []

        # Initially hide the details container
        self.prisoners_details_container.setVisible(False)
        scroll_layout.addWidget(self.prisoners_details_container)

        # Connect Yes/N/A radios to show/hide details
        def on_prisoners_applicable_changed():
            self.prisoners_details_container.setVisible(self.prisoners_applicable_yes.isChecked())
            self._update_prisoners_preview()

        self.prisoners_applicable_yes.toggled.connect(on_prisoners_applicable_changed)
        self.prisoners_applicable_na.toggled.connect(on_prisoners_applicable_changed)

        scroll_layout.addStretch()
        content_scroll.setWidget(scroll_content)
        main_layout.addWidget(content_scroll)

        # Register generator
        def generate_prisoners_text():
            return self.prisoners_preview.text().strip()
        self.popup_generators["transferred_prisoners"] = generate_prisoners_text

        self._update_prisoners_preview()

        # Apply stored transferred prisoner detection (from import)
        if hasattr(self, '_extracted_patient_details') and self._extracted_patient_details:
            from PySide6.QtCore import QTimer
            def apply_prisoners_data():
                is_transferred = self._extracted_patient_details.get('is_transferred_prisoner', False)
                om_contact = self._extracted_patient_details.get('offender_manager_contact', '')
                om_response = self._extracted_patient_details.get('offender_manager_response', '')
                remission_prognosis = self._extracted_patient_details.get('remission_prognosis', '')
                remission_factors = self._extracted_patient_details.get('remission_factors', '')
                prisoners_entries = self._extracted_patient_details.get('prisoners_entries', [])

                if is_transferred:
                    self.prisoners_applicable_yes.setChecked(True)
                    print(f"[MOJ-LEAVE] 7 popup: Applied transferred prisoner = YES")

                    # Set OM contact if found
                    if om_contact and hasattr(self, 'prisoners_om_contact'):
                        self.prisoners_om_contact.setPlainText(om_contact)
                        print(f"[MOJ-LEAVE] 7a popup: Applied OM contact")

                    # Set notified to No by default (can be changed by user)
                    if hasattr(self, 'prisoners_notified_no'):
                        self.prisoners_notified_no.setChecked(True)
                        print(f"[MOJ-LEAVE] 7b popup: Set OM notified = NO (default)")

                    # Set OM response if found
                    if om_response and hasattr(self, 'prisoners_response'):
                        self.prisoners_response.setPlainText(om_response)
                        print(f"[MOJ-LEAVE] 7c popup: Applied OM response")

                    # Set remission prognosis if found
                    if remission_prognosis and hasattr(self, 'prisoners_prognosis'):
                        self.prisoners_prognosis.setPlainText(remission_prognosis)
                        print(f"[MOJ-LEAVE] 7d popup: Applied remission prognosis")

                    # Set remission factors if found
                    if remission_factors and hasattr(self, 'prisoners_factors'):
                        self.prisoners_factors.setPlainText(remission_factors)
                        print(f"[MOJ-LEAVE] 7d popup: Applied remission factors")
                else:
                    self.prisoners_applicable_na.setChecked(True)
                    print(f"[MOJ-LEAVE] 7 popup: Applied transferred prisoner = N/A")

                # Populate imported entries
                if prisoners_entries:
                    self._populate_prisoners_imports(prisoners_entries)

                self._update_prisoners_preview()
            QTimer.singleShot(100, apply_prisoners_data)

        return popup

    def _update_prisoners_preview(self):
        """Update the transferred prisoners preview text."""
        if not hasattr(self, 'prisoners_preview'):
            return

        parts = []

        # Check if N/A is selected
        if hasattr(self, 'prisoners_applicable_na') and self.prisoners_applicable_na.isChecked():
            self.prisoners_preview.setText("N/A")
            # Auto-sync N/A to card - preserve user additions
            if "transferred_prisoners" in self.cards:
                self._update_text_preserving_additions(self.cards["transferred_prisoners"].editor, "N/A", "transferred_prisoners")
            return

        # If Yes is selected, show full details
        if hasattr(self, 'prisoners_applicable_yes') and self.prisoners_applicable_yes.isChecked():
            # OM Contact
            om = self.prisoners_om_contact.toPlainText().strip() if hasattr(self, 'prisoners_om_contact') else ""
            if om:
                parts.append(f"Offender Manager: {om}")

            # Notified?
            if hasattr(self, 'prisoners_notified_yes') and self.prisoners_notified_yes.isChecked():
                parts.append("Offender Manager has been notified of this application.")
            elif hasattr(self, 'prisoners_notified_no') and self.prisoners_notified_no.isChecked():
                parts.append("Offender Manager has NOT been notified.")

            # Response
            response = self.prisoners_response.toPlainText().strip() if hasattr(self, 'prisoners_response') else ""
            if response:
                parts.append(f"OM response: {response}")

            # Remission considerations
            prognosis = self.prisoners_prognosis.toPlainText().strip() if hasattr(self, 'prisoners_prognosis') else ""
            if prognosis:
                parts.append(f"Return prognosis: {prognosis}")

            factors = self.prisoners_factors.toPlainText().strip() if hasattr(self, 'prisoners_factors') else ""
            if factors:
                parts.append(f"Factors against remission: {factors}")

            timeframe = self.prisoners_timeframe.toPlainText().strip() if hasattr(self, 'prisoners_timeframe') else ""
            if timeframe:
                parts.append(f"Timeframe: {timeframe}")

            unlikely = self.prisoners_unlikely.toPlainText().strip() if hasattr(self, 'prisoners_unlikely') else ""
            if unlikely:
                parts.append(f"Clinical view on return: {unlikely}")

        if parts:
            text = " ".join(parts)
            self.prisoners_preview.setText(text)
            # Auto-sync to card - preserve user additions
            if "transferred_prisoners" in self.cards:
                self._update_text_preserving_additions(self.cards["transferred_prisoners"].editor, text, "transferred_prisoners")
        else:
            self.prisoners_preview.setText("No transferred prisoner information entered.")

    def _populate_prisoners_imports(self, entries):
        """Populate the transferred prisoners imported data section matching 4a style."""
        if not hasattr(self, 'prisoners_import_layout'):
            return

        # Clear existing entries
        while self.prisoners_import_layout.count():
            item = self.prisoners_import_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        if not entries:
            placeholder = QLabel("No offender manager or remission-related entries found.")
            placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 14px; background: transparent; border: none;")
            self.prisoners_import_layout.addWidget(placeholder)
            if hasattr(self, 'prisoners_import_count'):
                self.prisoners_import_count.setText("0 entries")
            return

        if hasattr(self, 'prisoners_import_count'):
            self.prisoners_import_count.setText(f"{len(entries)} entries")

        self.prisoners_import_checkboxes = []

        for entry in entries:
            text = entry.get('text', '')
            date_str = entry.get('date', '') or ''
            keyword = entry.get('keyword', '')
            category = entry.get('category', 'general')

            # Preserve category-specific tag colors
            if category == 'offender_manager':
                tag_color, tag_text_color = "#dbeafe", "#1e40af"
                tag_label = f"OM: {keyword}"
            elif category == 'remission':
                tag_color, tag_text_color = "#fae8ff", "#86198f"
                tag_label = f"Remission: {keyword}"
            else:
                tag_color, tag_text_color = "#fef3c7", "#806000"
                tag_label = keyword

            entry_frame = QFrame()
            entry_frame.setObjectName("entryFrame")
            entry_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            entry_frame.setStyleSheet("QFrame#entryFrame { background: rgba(255, 255, 255, 0.95); border: 1px solid rgba(180, 150, 50, 0.4); border-radius: 8px; padding: 4px; }")
            entry_layout = QVBoxLayout(entry_frame)
            entry_layout.setContentsMargins(10, 4, 16, 4)
            entry_layout.setSpacing(6)


            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("QPushButton { background: rgba(180, 150, 50, 0.2); border: none; border-radius: 4px; font-size: 15px; font-weight: bold; color: #806000; } QPushButton:hover { background: rgba(180, 150, 50, 0.35); }")
            header_row.addWidget(toggle_btn)

            # Date label (first after toggle)
            if date_str:
                date_label = QLabel(f"\U0001f4c5 {date_str}")
                date_label.setStyleSheet("font-size: 15px; font-weight: 600; color: #806000; background: transparent; border: none;")
                date_label.setCursor(Qt.CursorShape.PointingHandCursor)
                header_row.addWidget(date_label)

            keyword_tag = QLabel(tag_label)
            keyword_tag.setStyleSheet(f"background: {tag_color}; color: {tag_text_color}; font-size: 14px; font-weight: 600; padding: 4px 10px; border-radius: 3px;")
            header_row.addWidget(keyword_tag)

            header_row.addStretch()

            cb = QCheckBox()
            cb.setProperty("full_text", text)
            cb.setFixedSize(20, 20)
            cb.setStyleSheet("QCheckBox { background: transparent; margin-right: 4px; } QCheckBox::indicator { width: 18px; height: 18px; }")
            header_row.addWidget(cb)

            entry_layout.addLayout(header_row)

            body_text = QTextEdit()
            body_text.setPlainText(text)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("QTextEdit { font-size: 15px; color: #333; background: rgba(255, 248, 220, 0.5); border: none; padding: 8px; border-radius: 6px; }")
            body_text.document().setTextWidth(350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            entry_layout.addWidget(body_text)

            def make_toggle(btn, body, frame):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    frame.updateGeometry()
                return toggle
            toggle_fn = make_toggle(toggle_btn, body_text, entry_frame)
            toggle_btn.clicked.connect(toggle_fn)
            if date_str:
                date_label.mousePressEvent = lambda e, fn=toggle_fn: fn()

            self.prisoners_import_layout.addWidget(entry_frame)
            self.prisoners_import_checkboxes.append({"checkbox": cb, "text": text, "frame": entry_frame})

        self.prisoners_imported_entries = entries

    def _create_fitness_to_plead_popup(self) -> QWidget:
        """Create Fitness to Plead popup identical to ASR unfit to plead popup."""
        key = "fitness_to_plead"
        popup = QWidget()
        popup.setObjectName(f"popup_{key}")
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)

        # Hidden label to store text for auto-sync to card
        self.fitness_preview = QLabel()
        self.fitness_preview.hide()

        # === CONTENT PANEL ===
        content_scroll = QScrollArea()
        content_scroll.setWidgetResizable(True)
        content_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        content_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        content_scroll.setStyleSheet("QScrollArea { background: transparent; border: none; }")

        content_widget = QWidget()
        content_widget.setStyleSheet("background: transparent;")
        content_layout = QVBoxLayout(content_widget)
        content_layout.setContentsMargins(12, 12, 12, 12)
        content_layout.setSpacing(12)

        # ============================================================
        # FIRST QUESTION: Was patient found unfit to plead?
        # ============================================================
        found_lbl = QLabel("Has this patient been found unfit to plead on sentencing?")
        found_lbl.setWordWrap(True)
        found_lbl.setStyleSheet("font-size: 14px; color: #374151;")
        content_layout.addWidget(found_lbl)

        found_row = QHBoxLayout()
        self.fitness_found_group = QButtonGroup(popup)
        self.fitness_found_yes = QRadioButton("Yes")
        self.fitness_found_no = QRadioButton("No")
        self.fitness_found_yes.setStyleSheet("font-size: 14px;")
        self.fitness_found_no.setStyleSheet("font-size: 14px;")
        self.fitness_found_no.setChecked(True)  # Default to No
        self.fitness_found_group.addButton(self.fitness_found_yes)
        self.fitness_found_group.addButton(self.fitness_found_no)
        found_row.addWidget(self.fitness_found_yes)
        found_row.addWidget(self.fitness_found_no)
        found_row.addStretch()
        content_layout.addLayout(found_row)

        # ============================================================
        # DETAILS CONTAINER (shown only if Yes)
        # ============================================================
        self.fitness_details_container = QWidget()
        self.fitness_details_container.setStyleSheet("background: transparent;")
        details_layout = QVBoxLayout(self.fitness_details_container)
        details_layout.setContentsMargins(0, 12, 0, 0)
        details_layout.setSpacing(8)

        # Second question: Is patient now fit to plead?
        fit_lbl = QLabel("Is patient now fit to plead?")
        fit_lbl.setWordWrap(True)
        fit_lbl.setStyleSheet("font-size: 14px; color: #374151;")
        details_layout.addWidget(fit_lbl)

        fit_row = QHBoxLayout()
        self.fitness_fit_group = QButtonGroup(popup)
        self.fitness_fit_yes = QRadioButton("Yes")
        self.fitness_fit_no = QRadioButton("No")
        self.fitness_fit_yes.setStyleSheet("font-size: 14px;")
        self.fitness_fit_no.setStyleSheet("font-size: 14px;")
        self.fitness_fit_group.addButton(self.fitness_fit_yes)
        self.fitness_fit_group.addButton(self.fitness_fit_no)
        fit_row.addWidget(self.fitness_fit_yes)
        fit_row.addWidget(self.fitness_fit_no)
        fit_row.addStretch()
        details_layout.addLayout(fit_row)

        # Details text area
        details_lbl = QLabel("Details:")
        details_lbl.setStyleSheet("font-size: 14px; color: #374151;")
        details_layout.addWidget(details_lbl)

        self.fitness_details_text = QTextEdit()
        self.fitness_details_text.setMaximumHeight(120)
        self.fitness_details_text.setStyleSheet("border: 1px solid #d1d5db; border-radius: 4px; background: white;")
        self.fitness_details_text.textChanged.connect(self._update_fitness_preview)
        details_layout.addWidget(self.fitness_details_text)

        self.fitness_details_container.hide()
        content_layout.addWidget(self.fitness_details_container)

        # Wire up visibility
        def on_found_changed():
            self.fitness_details_container.setVisible(self.fitness_found_yes.isChecked())
            self._update_fitness_preview()

        self.fitness_found_yes.toggled.connect(on_found_changed)
        self.fitness_found_no.toggled.connect(on_found_changed)
        self.fitness_fit_yes.toggled.connect(self._update_fitness_preview)
        self.fitness_fit_no.toggled.connect(self._update_fitness_preview)

        # ============================================================
        # COLLAPSIBLE IMPORTED DATA SECTION (matching 4a style)
        # ============================================================
        fitness_import_container = QWidget()
        fitness_import_container.setStyleSheet("""
            QWidget {
                background: rgba(255, 248, 220, 0.95);
                border: 1px solid rgba(180, 150, 50, 0.4);
                border-radius: 12px;
            }
            QCheckBox {
                background: transparent;
                border: none;
                padding: 4px;
                font-size: 14px;
                color: #4a4a4a;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
        """)
        fitness_import_main_layout = QVBoxLayout(fitness_import_container)
        fitness_import_main_layout.setContentsMargins(12, 10, 12, 10)
        fitness_import_main_layout.setSpacing(6)

        # Header with collapse button
        fitness_import_header = QHBoxLayout()
        self.fitness_import_collapse_btn = QPushButton("-")
        self.fitness_import_collapse_btn.setFixedSize(20, 20)
        self.fitness_import_collapse_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.fitness_import_collapse_btn.setStyleSheet("QPushButton { font-size: 16px; font-weight: 700; color: #806000; background: rgba(255, 248, 220, 0.95); border: 1px solid rgba(180, 150, 50, 0.4); border-radius: 4px; } QPushButton:hover { background: #fef3c7; }")
        fitness_import_header.addWidget(self.fitness_import_collapse_btn)

        fitness_import_title = QLabel("Imported Data - Fitness to Plead")
        fitness_import_title.setStyleSheet("font-size: 14px; font-weight: 600; color: #806000; background: transparent; border: none;")
        fitness_import_header.addWidget(fitness_import_title)
        fitness_import_header.addStretch()

        self.fitness_import_count = QLabel("0 entries")
        self.fitness_import_count.setStyleSheet("font-size: 13px; color: #806000; background: transparent; border: none;")
        fitness_import_header.addWidget(self.fitness_import_count)

        fitness_import_main_layout.addLayout(fitness_import_header)

        # Collapsible content - scrollable area for entries
        self.fitness_import_content = QWidget()
        self.fitness_import_content.setStyleSheet("background: transparent; border: none;")
        fitness_import_content_layout = QVBoxLayout(self.fitness_import_content)
        fitness_import_content_layout.setContentsMargins(12, 4, 12, 4)
        fitness_import_content_layout.setSpacing(4)

        # Scroll area for imported entries
        fitness_import_scroll = QScrollArea()
        fitness_import_scroll.setWidgetResizable(True)
        fitness_import_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        fitness_import_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        fitness_import_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        fitness_import_scroll.setMaximumHeight(250)
        fitness_import_scroll.setStyleSheet("""
            QScrollArea { background: transparent; border: none; }
            QScrollArea > QWidget > QWidget { background: transparent; }
        """)

        self.fitness_import_entries_widget = QWidget()
        self.fitness_import_entries_widget.setStyleSheet("background: transparent;")
        self.fitness_import_layout = QVBoxLayout(self.fitness_import_entries_widget)
        self.fitness_import_layout.setContentsMargins(2, 2, 2, 2)
        self.fitness_import_layout.setSpacing(4)
        self.fitness_import_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # Placeholder
        self.fitness_import_placeholder = QLabel("No fitness to plead entries found.")
        self.fitness_import_placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 13px; background: transparent; border: none;")
        self.fitness_import_layout.addWidget(self.fitness_import_placeholder)

        fitness_import_scroll.setWidget(self.fitness_import_entries_widget)
        fitness_import_content_layout.addWidget(fitness_import_scroll)

        fitness_import_main_layout.addWidget(self.fitness_import_content)
        content_layout.addWidget(fitness_import_container)

        # Toggle function for import collapse
        def toggle_fitness_import():
            visible = not self.fitness_import_content.isVisible()
            self.fitness_import_content.setVisible(visible)
            self.fitness_import_collapse_btn.setText("-" if visible else "+")
        self.fitness_import_collapse_btn.clicked.connect(toggle_fitness_import)

        # Storage for imported entries
        self.fitness_imported_entries = []

        content_layout.addStretch()

        content_scroll.setWidget(content_widget)
        main_layout.addWidget(content_scroll)

        # Register generator
        def generate_fitness_text():
            return self.fitness_preview.text().strip()
        self.popup_generators["fitness_to_plead"] = generate_fitness_text

        self._update_fitness_preview()

        # Apply stored fitness to plead detection (from import)
        if hasattr(self, '_extracted_patient_details') and self._extracted_patient_details:
            from PySide6.QtCore import QTimer
            def apply_fitness_data():
                was_unfit = self._extracted_patient_details.get('was_unfit_to_plead', False)
                is_now_fit = self._extracted_patient_details.get('is_now_fit_to_plead', None)
                fitness_details = self._extracted_patient_details.get('fitness_details', '')
                fitness_entries = self._extracted_patient_details.get('fitness_entries', [])

                if was_unfit:
                    self.fitness_found_yes.setChecked(True)
                    print(f"[MOJ-LEAVE] 8 popup: Applied was unfit to plead = YES")

                    # Set current fitness status if determined
                    if is_now_fit is True and hasattr(self, 'fitness_fit_yes'):
                        self.fitness_fit_yes.setChecked(True)
                        print(f"[MOJ-LEAVE] 8 popup: Applied now fit to plead = YES")
                    elif is_now_fit is False and hasattr(self, 'fitness_fit_no'):
                        self.fitness_fit_no.setChecked(True)
                        print(f"[MOJ-LEAVE] 8 popup: Applied now fit to plead = NO")

                    # Set details if found
                    if fitness_details and hasattr(self, 'fitness_details_text'):
                        self.fitness_details_text.setPlainText(fitness_details)
                        print(f"[MOJ-LEAVE] 8 popup: Applied fitness details")
                else:
                    self.fitness_found_no.setChecked(True)
                    print(f"[MOJ-LEAVE] 8 popup: Applied was unfit to plead = NO")

                # Populate imported entries
                if fitness_entries:
                    self._populate_fitness_imports(fitness_entries)

                self._update_fitness_preview()
            QTimer.singleShot(100, apply_fitness_data)

        return popup

    def _populate_fitness_imports(self, entries):
        """Populate the fitness to plead imported data section matching 4a style."""
        if not hasattr(self, 'fitness_import_layout'):
            return

        # Clear existing entries
        while self.fitness_import_layout.count():
            item = self.fitness_import_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        if not entries:
            placeholder = QLabel("No fitness to plead entries found.")
            placeholder.setStyleSheet("color: #806000; font-style: italic; font-size: 14px; background: transparent; border: none;")
            self.fitness_import_layout.addWidget(placeholder)
            if hasattr(self, 'fitness_import_count'):
                self.fitness_import_count.setText("0 entries")
            return

        if hasattr(self, 'fitness_import_count'):
            self.fitness_import_count.setText(f"{len(entries)} entries")

        self.fitness_import_checkboxes = []

        for entry in entries:
            text = entry.get('text', '')
            date_str = entry.get('date', '') or ''
            keyword = entry.get('keyword', '')
            category = entry.get('category', 'general')

            # Preserve category-specific tag colors
            if category == 'unfit':
                tag_color, tag_text_color = "#fee2e2", "#991b1b"
                tag_label = f"Unfit: {keyword}"
            elif category == 'now_fit':
                tag_color, tag_text_color = "#dcfce7", "#166534"
                tag_label = f"Fit: {keyword}"
            else:
                tag_color, tag_text_color = "#fef3c7", "#806000"
                tag_label = f"Fitness: {keyword}"

            entry_frame = QFrame()
            entry_frame.setObjectName("entryFrame")
            entry_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            entry_frame.setStyleSheet("QFrame#entryFrame { background: rgba(255, 255, 255, 0.95); border: 1px solid rgba(180, 150, 50, 0.4); border-radius: 8px; padding: 4px; }")
            entry_layout = QVBoxLayout(entry_frame)
            entry_layout.setContentsMargins(10, 4, 16, 4)
            entry_layout.setSpacing(6)


            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("QPushButton { background: rgba(180, 150, 50, 0.2); border: none; border-radius: 4px; font-size: 15px; font-weight: bold; color: #806000; } QPushButton:hover { background: rgba(180, 150, 50, 0.35); }")
            header_row.addWidget(toggle_btn)

            # Date label (first after toggle)
            if date_str:
                date_label = QLabel(f"\U0001f4c5 {date_str}")
                date_label.setStyleSheet("font-size: 15px; font-weight: 600; color: #806000; background: transparent; border: none;")
                date_label.setCursor(Qt.CursorShape.PointingHandCursor)
                header_row.addWidget(date_label)

            keyword_tag = QLabel(tag_label)
            keyword_tag.setStyleSheet(f"background: {tag_color}; color: {tag_text_color}; font-size: 14px; font-weight: 600; padding: 4px 10px; border-radius: 3px;")
            header_row.addWidget(keyword_tag)

            header_row.addStretch()

            cb = QCheckBox()
            cb.setProperty("full_text", text)
            cb.setFixedSize(20, 20)
            cb.setStyleSheet("QCheckBox { background: transparent; margin-right: 4px; } QCheckBox::indicator { width: 18px; height: 18px; }")
            header_row.addWidget(cb)

            entry_layout.addLayout(header_row)

            body_text = QTextEdit()
            body_text.setPlainText(text)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("QTextEdit { font-size: 15px; color: #333; background: rgba(255, 248, 220, 0.5); border: none; padding: 8px; border-radius: 6px; }")
            body_text.document().setTextWidth(350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            entry_layout.addWidget(body_text)

            def make_toggle(btn, body, frame):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    frame.updateGeometry()
                return toggle
            toggle_fn = make_toggle(toggle_btn, body_text, entry_frame)
            toggle_btn.clicked.connect(toggle_fn)
            if date_str:
                date_label.mousePressEvent = lambda e, fn=toggle_fn: fn()

            self.fitness_import_layout.addWidget(entry_frame)
            self.fitness_import_checkboxes.append({"checkbox": cb, "text": text, "frame": entry_frame})

        self.fitness_imported_entries = entries

    def _update_fitness_preview(self):
        """Update the fitness to plead preview text."""
        if not hasattr(self, 'fitness_preview'):
            return

        # If No selected for "found unfit to plead"
        if hasattr(self, 'fitness_found_no') and self.fitness_found_no.isChecked():
            self.fitness_preview.setText("N/A")
            # Auto-sync N/A to card - preserve user additions
            if "fitness_to_plead" in self.cards:
                self._update_text_preserving_additions(self.cards["fitness_to_plead"].editor, "N/A", "fitness_to_plead")
            return

        # If Yes selected for "found unfit to plead"
        if hasattr(self, 'fitness_found_yes') and self.fitness_found_yes.isChecked():
            parts = []

            # Check fit to plead status
            if hasattr(self, 'fitness_fit_yes') and self.fitness_fit_yes.isChecked():
                parts.append("The patient is now considered fit to plead.")
            elif hasattr(self, 'fitness_fit_no') and self.fitness_fit_no.isChecked():
                parts.append("The patient remains unfit to plead.")

            # Add details
            if hasattr(self, 'fitness_details_text'):
                details = self.fitness_details_text.toPlainText().strip()
                if details:
                    parts.append(details)

            if parts:
                text = " ".join(parts)
                self.fitness_preview.setText(text)
                # Auto-sync to card - preserve user additions
                if "fitness_to_plead" in self.cards:
                    self._update_text_preserving_additions(self.cards["fitness_to_plead"].editor, text, "fitness_to_plead")
            else:
                self.fitness_preview.setText("Please select fitness status and enter details.")
            return

        self.fitness_preview.setText("No fitness to plead information entered.")

    def _create_additional_comments_popup(self) -> QWidget:
        """Create Additional Comments popup with 9a text and 9b patient discussion."""
        key = "additional_comments"
        popup = QWidget()
        popup.setStyleSheet("background: #f9fafb;")
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)

        # Hidden label to store text for auto-sync to card
        self.comments_preview = QLabel()
        self.comments_preview.hide()

        # --- CONTENT PANEL (bottom) ---
        content_scroll = QScrollArea()
        content_scroll.setWidgetResizable(True)
        content_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        content_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        content_scroll.setStyleSheet("QScrollArea { background: transparent; }")

        scroll_content = QWidget()
        scroll_content.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setContentsMargins(4, 4, 4, 4)
        scroll_layout.setSpacing(12)

        # ========== 9a: Additional Comments Text ==========
        sec_a = QWidget()
        sec_a.setStyleSheet("background: #f3f4f6; border-radius: 6px;")
        sec_a_layout = QVBoxLayout(sec_a)
        sec_a_layout.setContentsMargins(12, 10, 12, 10)
        sec_a_layout.setSpacing(6)

        sec_a_title = QLabel("9a. Additional Comments")
        sec_a_title.setStyleSheet("font-weight: 600; font-size: 14px; color: #374151;")
        sec_a_layout.addWidget(sec_a_title)

        self.additional_comments_text = QTextEdit()
        self.additional_comments_text.setPlaceholderText("Enter any additional information or views pertinent to this leave application...")
        self.additional_comments_text.setStyleSheet("padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; background: white;")
        self.additional_comments_text.setMinimumHeight(100)
        self.additional_comments_text.textChanged.connect(self._update_comments_preview)
        sec_a_layout.addWidget(self.additional_comments_text)

        scroll_layout.addWidget(sec_a)

        # ========== 9b: Patient Discussion ==========
        sec_b = QWidget()
        sec_b.setStyleSheet("background: #dbeafe; border-radius: 6px;")
        sec_b_layout = QVBoxLayout(sec_b)
        sec_b_layout.setContentsMargins(12, 10, 12, 10)
        sec_b_layout.setSpacing(8)

        sec_b_title = QLabel("9b. Patient Discussion")
        sec_b_title.setStyleSheet("font-weight: 600; font-size: 14px; color: #1e40af;")
        sec_b_layout.addWidget(sec_b_title)

        # Has this been discussed with patient?
        discussed_row = QHBoxLayout()
        discussed_lbl = QLabel("Has this been discussed with the patient?")
        discussed_lbl.setStyleSheet("font-size: 13px; font-weight: 500;")
        discussed_row.addWidget(discussed_lbl)

        self.comments_discussed_group = QButtonGroup(popup)
        self.comments_discussed_yes = QRadioButton("Yes")
        self.comments_discussed_no = QRadioButton("No")
        self.comments_discussed_yes.setStyleSheet("font-size: 13px;")
        self.comments_discussed_no.setStyleSheet("font-size: 13px;")
        self.comments_discussed_group.addButton(self.comments_discussed_yes)
        self.comments_discussed_group.addButton(self.comments_discussed_no)
        self.comments_discussed_yes.toggled.connect(self._update_comments_visibility)
        self.comments_discussed_no.toggled.connect(self._update_comments_visibility)
        self.comments_discussed_yes.toggled.connect(self._update_comments_preview)
        self.comments_discussed_no.toggled.connect(self._update_comments_preview)
        discussed_row.addWidget(self.comments_discussed_yes)
        discussed_row.addWidget(self.comments_discussed_no)
        discussed_row.addStretch()
        sec_b_layout.addLayout(discussed_row)

        # Container for "Any issues of concern?" (shown when Yes)
        self.comments_issues_container = QWidget()
        issues_layout = QVBoxLayout(self.comments_issues_container)
        issues_layout.setContentsMargins(20, 4, 0, 0)
        issues_layout.setSpacing(8)

        issues_row = QHBoxLayout()
        issues_lbl = QLabel("Any issues of concern?")
        issues_lbl.setStyleSheet("font-size: 13px; font-weight: 500;")
        issues_row.addWidget(issues_lbl)

        self.comments_issues_group = QButtonGroup(popup)
        self.comments_issues_yes = QRadioButton("Yes")
        self.comments_issues_no = QRadioButton("No")
        self.comments_issues_yes.setStyleSheet("font-size: 13px;")
        self.comments_issues_no.setStyleSheet("font-size: 13px;")
        self.comments_issues_group.addButton(self.comments_issues_yes)
        self.comments_issues_group.addButton(self.comments_issues_no)
        self.comments_issues_yes.toggled.connect(self._update_comments_details_visibility)
        self.comments_issues_no.toggled.connect(self._update_comments_details_visibility)
        self.comments_issues_yes.toggled.connect(self._update_comments_preview)
        self.comments_issues_no.toggled.connect(self._update_comments_preview)
        issues_row.addWidget(self.comments_issues_yes)
        issues_row.addWidget(self.comments_issues_no)
        issues_row.addStretch()
        issues_layout.addLayout(issues_row)

        # Details container (shown when issues = Yes)
        self.comments_details_container = QWidget()
        details_layout = QVBoxLayout(self.comments_details_container)
        details_layout.setContentsMargins(0, 4, 0, 0)
        details_layout.setSpacing(4)

        details_lbl = QLabel("Details:")
        details_lbl.setStyleSheet("font-size: 13px; font-weight: 500;")
        details_layout.addWidget(details_lbl)

        self.comments_issues_details = QTextEdit()
        self.comments_issues_details.setPlaceholderText("Enter details of concerns raised by the patient...")
        self.comments_issues_details.setStyleSheet("padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; background: white;")
        self.comments_issues_details.setMaximumHeight(80)
        self.comments_issues_details.textChanged.connect(self._update_comments_preview)
        details_layout.addWidget(self.comments_issues_details)

        self.comments_details_container.setVisible(False)
        issues_layout.addWidget(self.comments_details_container)

        self.comments_issues_container.setVisible(False)
        sec_b_layout.addWidget(self.comments_issues_container)

        scroll_layout.addWidget(sec_b)

        scroll_layout.addStretch()
        content_scroll.setWidget(scroll_content)
        main_layout.addWidget(content_scroll)

        # Register generator
        def generate_comments_text():
            return self.comments_preview.text().strip()
        self.popup_generators["additional_comments"] = generate_comments_text

        self._update_comments_preview()

        # Auto-set 9b defaults on import: discussed = Yes, issues of concern = No
        from PySide6.QtCore import QTimer
        def apply_9b_defaults():
            if hasattr(self, 'comments_discussed_yes'):
                self.comments_discussed_yes.setChecked(True)
                print(f"[MOJ-LEAVE] 9b popup: Set discussed with patient = YES")
            if hasattr(self, 'comments_issues_no'):
                self.comments_issues_no.setChecked(True)
                print(f"[MOJ-LEAVE] 9b popup: Set issues of concern = NO")
            self._update_comments_visibility()
            self._update_comments_preview()
        QTimer.singleShot(100, apply_9b_defaults)

        return popup

    def _update_comments_visibility(self):
        """Show/hide issues container based on discussed selection."""
        if hasattr(self, 'comments_discussed_yes') and hasattr(self, 'comments_issues_container'):
            self.comments_issues_container.setVisible(self.comments_discussed_yes.isChecked())

    def _update_comments_details_visibility(self):
        """Show/hide details container based on issues selection."""
        if hasattr(self, 'comments_issues_yes') and hasattr(self, 'comments_details_container'):
            self.comments_details_container.setVisible(self.comments_issues_yes.isChecked())

    def _update_comments_preview(self):
        """Update the additional comments preview text."""
        if not hasattr(self, 'comments_preview'):
            return

        lines = []

        # 9a: Additional comments text
        text = self.additional_comments_text.toPlainText().strip() if hasattr(self, 'additional_comments_text') else ""
        if text:
            lines.append(f"9a - {text}")

        # 9b: Patient discussion
        section_9b_parts = []
        if hasattr(self, 'comments_discussed_yes') and self.comments_discussed_yes.isChecked():
            section_9b_parts.append("This has been discussed with the patient.")
            # Check for issues
            if hasattr(self, 'comments_issues_yes') and self.comments_issues_yes.isChecked():
                details = self.comments_issues_details.toPlainText().strip() if hasattr(self, 'comments_issues_details') else ""
                if details:
                    section_9b_parts.append(f"Issues of concern: {details}")
                else:
                    section_9b_parts.append("Issues of concern were raised.")
            elif hasattr(self, 'comments_issues_no') and self.comments_issues_no.isChecked():
                section_9b_parts.append("No issues of concern.")
        elif hasattr(self, 'comments_discussed_no') and self.comments_discussed_no.isChecked():
            section_9b_parts.append("This has not been discussed with the patient.")

        if section_9b_parts:
            lines.append(f"9b - {' '.join(section_9b_parts)}")

        if lines:
            text = "\n".join(lines)
            self.comments_preview.setText(text)
            # Auto-sync to card - preserve user additions
            if "additional_comments" in self.cards:
                self._update_text_preserving_additions(self.cards["additional_comments"].editor, text, "additional_comments")
        else:
            self.comments_preview.setText("No additional comments entered.")

    def _create_signature_popup(self) -> QWidget:
        """Create signature popup matching ASR signature style."""
        key = "signature"
        popup = QWidget()
        popup.setStyleSheet("background: #f9fafb;")
        main_layout = QVBoxLayout(popup)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)

        # Hidden label to store text for auto-sync to card
        self.signature_preview = QLabel()
        self.signature_preview.hide()

        # --- CONTENT PANEL (bottom) ---
        content_scroll = QScrollArea()
        content_scroll.setWidgetResizable(True)
        content_scroll.setFrameShape(QScrollArea.Shape.NoFrame)
        content_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        content_scroll.setStyleSheet("QScrollArea { background: transparent; }")

        scroll_content = QWidget()
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setContentsMargins(4, 4, 4, 4)
        scroll_layout.setSpacing(12)

        # ========== Form Fields (vertical layout) ==========
        form_container = QWidget()
        form_container.setStyleSheet("background: #f3f4f6; border-radius: 6px;")
        form_layout = QVBoxLayout(form_container)
        form_layout.setContentsMargins(12, 12, 12, 12)
        form_layout.setSpacing(10)

        # RC's signature
        rc_sig_lbl = QLabel("RC's signature:")
        rc_sig_lbl.setStyleSheet("font-size: 14px; font-weight: 500; color: #374151;")
        form_layout.addWidget(rc_sig_lbl)

        self.sig_line = QLineEdit()
        self.sig_line.setText("Signed electronically")
        self.sig_line.setStyleSheet("background: white; padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;")
        self.sig_line.textChanged.connect(self._update_signature_preview)
        form_layout.addWidget(self.sig_line)

        # Print name
        name_lbl = QLabel("Print name:")
        name_lbl.setStyleSheet("font-size: 14px; font-weight: 500; color: #374151;")
        form_layout.addWidget(name_lbl)

        self.sig_name = QLineEdit()
        self.sig_name.setStyleSheet("background: white; padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;")
        self.sig_name.textChanged.connect(self._update_signature_preview)
        form_layout.addWidget(self.sig_name)

        # Role
        role_lbl = QLabel("Role/Position:")
        role_lbl.setStyleSheet("font-size: 14px; font-weight: 500; color: #374151;")
        form_layout.addWidget(role_lbl)

        self.sig_role = QLineEdit()
        self.sig_role.setStyleSheet("background: white; padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;")
        self.sig_role.textChanged.connect(self._update_signature_preview)
        form_layout.addWidget(self.sig_role)

        # Date
        date_lbl = QLabel("Date:")
        date_lbl.setStyleSheet("font-size: 14px; font-weight: 500; color: #374151;")
        form_layout.addWidget(date_lbl)

        self.sig_date = NoWheelDateEdit()
        self.sig_date.setCalendarPopup(True)
        self.sig_date.setDate(QDate.currentDate())
        self.sig_date.setDisplayFormat("dd/MM/yyyy")
        self.sig_date.setStyleSheet("background: white; padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;")
        self.sig_date.dateChanged.connect(self._update_signature_preview)
        form_layout.addWidget(self.sig_date)

        scroll_layout.addWidget(form_container)

        # ========== Info ==========
        info_lbl = QLabel("Please send the completed report to: mhcsmailbox@justice.gov.uk")
        info_lbl.setStyleSheet("font-size: 14px; color: #6b7280; font-style: italic;")
        info_lbl.setWordWrap(True)
        scroll_layout.addWidget(info_lbl)

        scroll_layout.addStretch()

        content_scroll.setWidget(scroll_content)
        main_layout.addWidget(content_scroll)

        # Register generator
        def generate_signature_text():
            return self.signature_preview.text().strip()
        self.popup_generators["signature"] = generate_signature_text

        # Prefill from my_details
        if hasattr(self, '_my_details') and self._my_details:
            if self._my_details.get("full_name"):
                self.sig_name.setText(self._my_details["full_name"])
            if self._my_details.get("role_title"):
                self.sig_role.setText(self._my_details["role_title"])

        self._update_signature_preview()
        return popup

    def _update_signature_preview(self):
        """Update the signature preview text."""
        if not hasattr(self, 'signature_preview'):
            return

        parts = []
        sig = self.sig_line.text().strip() if hasattr(self, 'sig_line') else ""
        name = self.sig_name.text().strip() if hasattr(self, 'sig_name') else ""
        role = self.sig_role.text().strip() if hasattr(self, 'sig_role') else ""
        date = self.sig_date.date().toString("dd/MM/yyyy") if hasattr(self, 'sig_date') else ""

        if sig or name:
            sig_text = sig if sig else "Signed electronically"
            parts.append(f"Signature: {sig_text}")
        if name:
            parts.append(f"Name: {name}")
        if role:
            parts.append(f"Role: {role}")
        if date:
            parts.append(f"Date: {date}")

        if parts:
            text = "\n".join(parts)
            self.signature_preview.setText(text)
            # Auto-sync to card - preserve user additions
            if "signature" in self.cards:
                self._update_text_preserving_additions(self.cards["signature"].editor, text, "signature")
        else:
            self.signature_preview.setText("No signature details entered.")

    def _create_annex_a_popup(self) -> QWidget:
        return self._create_simple_text_popup("Annex A - Victim Liaison:", "Enter victim liaison details...", "annex_a_text", "annex_a")

    # ================================================================
    # CARD UPDATE METHODS
    # ================================================================

    def _update_card_preview(self, key: str):
        """Update card preview based on popup fields.
        After initial auto-fill, only the currently active popup can update its own card,
        unless a gender update is in progress."""
        # After auto-fill phase, block cross-card updates (except gender updates)
        if not self._auto_fill_phase and key != self._selected_card_key:
            if not getattr(self, '_gender_update_in_progress', False):
                return
        if key not in self.cards:
            return

        card = self.cards[key]
        text = ""

        if key == "patient_details" and hasattr(self, 'patient_name'):
            name = self.patient_name.text()
            dob = self.patient_dob.date().toString("dd/MM/yyyy") if hasattr(self, 'patient_dob') else ""
            text = f"Name: {name}\nDOB: {dob}"
        elif key == "rc_details" and hasattr(self, 'rc_name'):
            text = f"RC: {self.rc_name.text()}"
        elif key == "leave_type":
            parts = []
            labels = {
                "compassionate_day": "Compassionate (day)",
                "compassionate_overnight": "Compassionate (overnight)",
                "escorted_day": "Escorted community (day)",
                "escorted_overnight": "Escorted (overnight)",
                "unescorted_day": "Unescorted community (day)",
                "unescorted_overnight": "Unescorted community (overnight)",
            }
            if hasattr(self, 'leave_type_checkboxes'):
                for cb_key, label in labels.items():
                    if self.leave_type_checkboxes.get(cb_key) and self.leave_type_checkboxes[cb_key].isChecked():
                        parts.append(label)
            text = ", ".join(parts) if parts else ""
        elif key == "documents" and hasattr(self, 'documents_checkboxes'):
            selected = [cb.text() for cb in self.documents_checkboxes.values() if cb.isChecked()]
            text = ", ".join(selected) if selected else ""

        if text:
            card.editor.setPlainText(text)


    def _styled_label(self, text: str) -> QLabel:
        """Create a QLabel with larger font for popup input sections."""
        lbl = QLabel(text)
        lbl.setStyleSheet("font-size: 22px; color: #374151;")
        lbl.setWordWrap(True)
        return lbl

    def _send_to_card(self, key: str):
        """Send popup content to card.
        After initial auto-fill, only the currently active popup can update its own card,
        unless a gender update is in progress."""
        # After auto-fill phase, block cross-card updates (except gender updates)
        if not self._auto_fill_phase and key != self._selected_card_key:
            if not getattr(self, '_gender_update_in_progress', False):
                return
        if key not in self.cards:
            print(f"[MOJ-LEAVE] _send_to_card: key '{key}' not in cards")
            return

        card = self.cards[key]
        text = ""

        if key == "patient_details":
            parts = []
            if hasattr(self, 'patient_name') and self.patient_name.text():
                parts.append(f"Name: {self.patient_name.text()}")
            if hasattr(self, 'patient_dob'):
                parts.append(f"DOB: {self.patient_dob.date().toString('dd/MM/yyyy')}")
            if hasattr(self, 'hospital_name') and self.hospital_name.text():
                parts.append(f"Hospital: {self.hospital_name.text()}")
            if hasattr(self, 'ward') and self.ward.text():
                parts.append(f"Ward: {self.ward.text()}")
            if hasattr(self, 'mha_section') and self.mha_section.currentText():
                parts.append(f"Section: {self.mha_section.currentText()}")
            if hasattr(self, 'moj_reference') and self.moj_reference.text():
                parts.append(f"MOJ Ref: {self.moj_reference.text()}")
            text = "\n".join(parts)
        elif key == "rc_details":
            parts = []
            if hasattr(self, 'rc_name') and self.rc_name.text():
                parts.append(f"Name: {self.rc_name.text()}")
            if hasattr(self, 'rc_email') and self.rc_email.text():
                parts.append(f"Email: {self.rc_email.text()}")
            if hasattr(self, 'rc_phone') and self.rc_phone.text():
                parts.append(f"Phone: {self.rc_phone.text()}")
            text = "\n".join(parts)
        elif key == "leave_type":
            parts = []
            labels = {
                "compassionate_day": "Compassionate (day)",
                "compassionate_overnight": "Compassionate (overnight)",
                "escorted_day": "Escorted community (day)",
                "escorted_overnight": "Escorted (overnight)",
                "unescorted_day": "Unescorted community (day)",
                "unescorted_overnight": "Unescorted community (overnight)",
            }
            if hasattr(self, 'leave_type_checkboxes'):
                for cb_key, label in labels.items():
                    if self.leave_type_checkboxes.get(cb_key) and self.leave_type_checkboxes[cb_key].isChecked():
                        parts.append(f"☑ {label}")
            text = "\n".join(parts)
        elif key == "documents":
            parts = []
            if hasattr(self, 'documents_checkboxes'):
                selected = [cb.text() for cb in self.documents_checkboxes.values() if cb.isChecked()]
                parts.extend(selected)
            if hasattr(self, 'other_documents') and self.other_documents.text():
                parts.append(self.other_documents.text())
            text = "\n".join(parts)
        elif key == "purpose" and hasattr(self, 'purpose_preview'):
            text = self.purpose_preview.text()
        elif key == "overnight" and hasattr(self, 'overnight_preview'):
            text = self.overnight_preview.text()
        elif key == "escorted_overnight" and hasattr(self, 'escorted_overnight_preview'):
            text = self.escorted_overnight_preview.text()
        elif key == "compassionate" and hasattr(self, 'compassionate_preview'):
            text = self.compassionate_preview.text()
        elif key == "leave_report" and hasattr(self, 'leave_report_preview'):
            text = self.leave_report_preview.text()
        elif key == "procedures" and hasattr(self, 'leave_procedures'):
            text = self.leave_procedures.text()
        elif key == "hospital_admissions" and hasattr(self, 'hospital_admissions'):
            text = self.hospital_admissions.text()
        elif key == "index_offence" and hasattr(self, 'index_offence_preview'):
            text = self.index_offence_preview.text()
        elif key == "mental_disorder" and hasattr(self, 'mental_disorder_preview'):
            text = self.mental_disorder_preview.text()
        elif key == "attitude_behaviour" and hasattr(self, 'attitude_behaviour_preview'):
            text = self.attitude_behaviour_preview.text()
        elif key == "risk_factors" and hasattr(self, 'risk_factors_preview'):
            text = self.risk_factors_preview.text()
        elif key == "medication" and hasattr(self, 'medication_preview'):
            text = self.medication_preview.text()
        elif key == "psychology" and hasattr(self, 'psychology_preview'):
            text = self.psychology_preview.text()
        elif key == "extremism" and hasattr(self, 'extremism_preview'):
            text = self.extremism_preview.text()
        elif key == "absconding" and hasattr(self, 'absconding_preview'):
            text = self.absconding_preview.text()
        elif key == "mappa" and hasattr(self, 'mappa_preview'):
            text = self.mappa_preview.text()
        elif key == "victims" and hasattr(self, 'victims_preview'):
            text = self.victims_preview.text()
        elif key == "transferred_prisoners" and hasattr(self, 'prisoners_preview'):
            text = self.prisoners_preview.text()
        elif key == "fitness_to_plead" and hasattr(self, 'fitness_preview'):
            text = self.fitness_preview.text()
        elif key == "additional_comments" and hasattr(self, 'comments_preview'):
            text = self.comments_preview.text()
        elif key == "signature" and hasattr(self, 'signature_preview'):
            text = self.signature_preview.text()
        else:
            # For simple text fields
            attr_mapping = {
                "mappa": "mappa_text",
                "victims": "victims_text",
                "transferred_prisoners": "transferred_prisoners_text",
                "fitness_to_plead": "fitness_to_plead_text",
                "additional_comments": "additional_comments_text",
                "annex_a": "annex_a_text",
            }
            attr_name = attr_mapping.get(key)
            if attr_name and hasattr(self, attr_name):
                text = getattr(self, attr_name).toPlainText()

        if key in ("hospital_admissions", "index_offence"):
            print(f"[MOJ-LEAVE] _send_to_card({key}): setting card with {len(text)} chars")
        card.editor.setPlainText(text)

    # ================================================================
    # SUMMARY AND IMPORT METHODS
    # ================================================================

    def _copy_leave_summary(self):
        from PySide6.QtWidgets import QApplication
        summary = self.leave_summary_text.toPlainText().strip()
        if summary:
            QApplication.clipboard().setText(summary)

    def _generate_leave_summary(self):
        """Generate summary from imported leave data."""
        imported = self.leave_import_text.toPlainText().strip()
        if not imported:
            self.leave_summary_text.setPlainText("No data to summarize.")
            self.leave_summary_frame.show()
            return

        patterns = [
            r'[Ll]eave[^.]{5,150}\.',
            r'[Ee]scort[^.]{5,100}\.',
            r'[Cc]ommunity[^.]{5,150}\.',
            r'[Gg]round[^.]{5,100}\.',
        ]

        found = []
        for pattern in patterns:
            matches = re.findall(pattern, imported)
            for m in matches[:2]:
                clean = " ".join(m.split())
                if clean not in found:
                    found.append(clean)

        if found:
            summary = " ".join(found[:6])
        else:
            sentences = re.findall(r'[^.]+\.', imported)
            summary = " ".join(s.strip() for s in sentences[:4])

        self.leave_summary_text.setPlainText(summary if summary else "No relevant leave information found.")
        self.leave_summary_frame.show()

    def _send_leave_import_to_report(self):
        """Send leave import data to preview."""
        # This method is kept for compatibility but the new structure
        # uses leave_report_preview which auto-generates from input fields
        pass

    def _copy_psych_summary(self):
        from PySide6.QtWidgets import QApplication
        summary = self.psych_summary_text.toPlainText().strip()
        if summary:
            QApplication.clipboard().setText(summary)

    def _generate_psych_summary(self):
        """Generate summary from imported psychiatric history."""
        imported = self.psych_import_text.toPlainText().strip()
        if not imported:
            self.psych_summary_text.setPlainText("No data to summarize.")
            self.psych_summary_frame.show()
            return

        patterns = [
            r'[Aa]dmitted\s+to[^.]{5,150}\.',
            r'[Dd]etained\s+under[^.]{5,100}\.',
            r'[Ii]npatient[^.]{5,150}\.',
            r'[Ss]ection\s*\d+[^.]{5,100}\.',
            r'[Pp]sychiatric\s+(?:admission|hospital|ward)[^.]{5,150}\.',
            r'[Dd]iagnos(?:is|ed)[^.]{5,150}\.',
        ]

        found = []
        for pattern in patterns:
            matches = re.findall(pattern, imported)
            for m in matches[:2]:
                clean = " ".join(m.split())
                if clean not in found:
                    found.append(clean)

        if found:
            summary = " ".join(found[:6])
        else:
            sentences = re.findall(r'[^.]+\.', imported)
            summary = " ".join(s.strip() for s in sentences[:4])

        self.psych_summary_text.setPlainText(summary if summary else "No relevant psychiatric history found.")
        self.psych_summary_frame.show()

    def _send_psych_to_report(self):
        """Send psychiatric data or summary to report."""
        summary = self.psych_summary_text.toPlainText().strip()
        if summary:
            current = self.hospital_admissions.text()
            text = current + "\n\n" + summary if current else summary
            self.hospital_admissions.setText(text)
            # Auto-sync to card
            if "hospital_admissions" in self.cards:
                self.cards["hospital_admissions"].editor.setPlainText(text)

    def _copy_forensic_summary(self):
        from PySide6.QtWidgets import QApplication
        summary = self.forensic_summary_text.toPlainText().strip()
        if summary:
            QApplication.clipboard().setText(summary)

    def _generate_forensic_summary(self):
        """Generate summary from imported forensic history."""
        imported = self.forensic_import_text.toPlainText().strip()
        if not imported:
            self.forensic_summary_text.setPlainText("No data to summarize.")
            self.forensic_summary_frame.show()
            return

        patterns = [
            r'[Ii]ndex\s+offence[^.]{5,200}\.',
            r'[Cc]onvicted\s+(?:of|for)[^.]{5,150}\.',
            r'[Aa]rrested\s+(?:for|on)[^.]{5,150}\.',
            r'[Ss]entenced\s+to[^.]{5,150}\.',
            r'[Pp]rison[^.]{5,100}\.',
            r'[Oo]ffence[^.]{5,150}\.',
        ]

        found = []
        for pattern in patterns:
            matches = re.findall(pattern, imported)
            for m in matches[:2]:
                clean = " ".join(m.split())
                if clean not in found:
                    found.append(clean)

        if found:
            summary = " ".join(found[:6])
        else:
            sentences = re.findall(r'[^.]+\.', imported)
            summary = " ".join(s.strip() for s in sentences[:4])

        self.forensic_summary_text.setPlainText(summary if summary else "No relevant forensic history found.")
        self.forensic_summary_frame.show()

    def _send_forensic_to_report(self):
        """Send forensic data or summary to report."""
        summary = self.forensic_summary_text.toPlainText().strip()
        if summary:
            current = self.index_offence.toPlainText()
            self.index_offence.setPlainText(current + "\n\n" + summary if current else summary)

    # ================================================================
    # DATA EXTRACTOR
    # ================================================================

    def _get_or_create_data_extractor(self):
        """Get or create persistent data extractor instance."""
        if not hasattr(self, '_data_extractor') or self._data_extractor is None:
            try:
                from data_extractor_popup import DataExtractorPopup
                self._data_extractor = DataExtractorPopup(parent=self)
                self._data_extractor.hide()
                self._data_extractor.setWindowTitle("Data Extractor - MOJ Leave Application")
                self._data_extractor.setMinimumSize(800, 600)
                # Connect the data extraction signal
                if hasattr(self._data_extractor, 'data_extracted'):
                    self._data_extractor.data_extracted.connect(self._on_data_extracted)
            except ImportError:
                from PySide6.QtWidgets import QMessageBox
                QMessageBox.warning(self, "Import Error", "Data extractor module not available.")
                return None
        return self._data_extractor

    def _process_auto_import(self, file_path, leave_type):
        """Process document for auto-generation and apply all defaults based on leave type."""
        from PySide6.QtWidgets import QMessageBox
        from PySide6.QtCore import QTimer
        import os

        print(f"[MOJ-LEAVE] AUTO: Processing file {file_path} for leave type {leave_type}")

        # Store leave type for later use
        self._auto_leave_type = leave_type

        # =============================================
        # FIRST: Create all popups BEFORE loading file
        # This ensures import_layout widgets exist when data_extracted fires
        # =============================================
        required_popups = [
            "rc_details", "leave_type", "documents", "purpose",
            "overnight", "escorted_overnight", "compassionate", "leave_report", "procedures",
            "hospital_admissions", "index_offence", "mental_disorder", "attitude_behaviour",
            "risk_factors", "medication", "psychology", "extremism", "absconding",
            "mappa", "victims", "transferred_prisoners", "fitness_to_plead", "additional_comments",
            "signature"
        ]
        self._ensure_popups_created(required_popups)
        print(f"[MOJ-LEAVE] AUTO: All popups created before file load")

        # Get or create data extractor and load file
        extractor = self._get_or_create_data_extractor()
        if extractor is None:
            QMessageBox.warning(self, "Import Error", "Data extractor module not available.")
            return

        try:
            # Load the file (triggers data extraction and data_extracted signal)
            if hasattr(extractor, 'load_file'):
                extractor.load_file(file_path)
            elif hasattr(extractor, 'process_file'):
                extractor.process_file(file_path)

            # After loading, apply all auto-defaults based on leave type
            # Use timer to allow extraction to complete first
            def apply_auto_defaults():
                self._apply_auto_leave_defaults(leave_type)

                # Export all popup data to cards
                self._export_all_popups_to_cards()

            # Stage 1: Apply defaults after extraction starts (1.5 seconds)
            QTimer.singleShot(1500, apply_auto_defaults)

            # Stage 2: Auto-select imports and send to card after extraction completes (3 seconds)
            def finalize_auto_import():
                self._auto_select_imports_and_send_to_card()

                QMessageBox.information(
                    self,
                    "Auto-Generate Complete",
                    f"Form has been auto-generated for {leave_type.replace('_', ' ').title()} leave.\n\n"
                    "All sections have been populated with defaults. Please review and adjust as needed."
                )

            # Increased from 3s to 4s to ensure data extraction (including gender) completes
            QTimer.singleShot(4000, finalize_auto_import)

        except Exception as e:
            QMessageBox.warning(self, "Import Error", f"Failed to process file: {str(e)}")

    def _ensure_popups_created(self, keys):
        """Ensure popups are created for the given keys so widgets exist."""
        for key in keys:
            if key not in self.popups:
                popup = self._create_popup(key)
                if popup:
                    self.popups[key] = popup
                    self.popup_stack.addWidget(popup)
                    print(f"[MOJ-LEAVE] AUTO: Created popup for {key}")

    def _apply_auto_leave_defaults(self, leave_type):
        """Apply all default values based on selected leave type."""
        print(f"[MOJ-LEAVE] AUTO: Applying defaults for {leave_type}")

        # =============================================
        # FIRST: Ensure all required popups are created so widgets exist
        # =============================================
        required_popups = [
            "rc_details", "leave_type", "documents", "purpose",
            "overnight", "escorted_overnight", "compassionate", "leave_report", "procedures",
            # Section 4 popups
            "hospital_admissions", "index_offence", "mental_disorder", "attitude_behaviour",
            "risk_factors", "medication", "psychology", "extremism", "absconding",
            # Sections 5-9
            "mappa", "victims", "transferred_prisoners", "fitness_to_plead", "additional_comments",
            "signature"
        ]
        self._ensure_popups_created(required_popups)

        # =============================================
        # Card 2: RC Details - send to card (pre-filled from my_details)
        # =============================================
        if hasattr(self, '_send_to_card'):
            self._send_to_card("rc_details")
            print(f"[MOJ-LEAVE] AUTO 2: Sent RC details to card")

        # =============================================
        # 3a: Set leave type checkbox
        # =============================================
        if hasattr(self, 'leave_type_checkboxes') and leave_type in self.leave_type_checkboxes:
            # Uncheck all first
            for cb in self.leave_type_checkboxes.values():
                cb.setChecked(False)
            # Check the selected one
            self.leave_type_checkboxes[leave_type].setChecked(True)
            print(f"[MOJ-LEAVE] AUTO 3a: Set leave type = {leave_type}")
            # Send to card
            if hasattr(self, '_send_to_card'):
                self._send_to_card("leave_type")
                print(f"[MOJ-LEAVE] AUTO 3a: Sent leave_type to card")

        # =============================================
        # 3b: Default checkboxes - check everything EXCEPT sara and other_risk_tools
        # =============================================
        self._apply_3b_defaults()

        # =============================================
        # 2: Exclusion zone = N/A for all
        # =============================================
        self._apply_exclusion_zone_default()

        # =============================================
        # 3c: Purpose of leave, Location, Discharge planning based on leave type
        # =============================================
        self._apply_3c_defaults(leave_type)

        # =============================================
        # 3d: Unescorted overnight - Yes if selected, N/A otherwise
        # =============================================
        self._apply_3d_defaults(leave_type)

        # =============================================
        # 3e: Escorted overnight - Yes if selected, N/A otherwise
        # =============================================
        self._apply_3e_defaults(leave_type)

        # =============================================
        # 3f: Compassionate leave - Yes if selected, N/A otherwise
        # =============================================
        self._apply_3f_defaults(leave_type)

        # =============================================
        # 3g: Leave report - set based on leave type
        # =============================================
        self._apply_3g_defaults(leave_type)

        # =============================================
        # 3h: Proposed Management - set based on leave type
        # =============================================
        self._apply_3h_defaults(leave_type)

        # NOTE: Sections 4-9 auto-select and send to card is called separately
        # after data extraction completes (via _auto_select_imports_and_send_to_card)

    def _auto_select_imports_and_send_to_card(self):
        """Auto-select the first imported entry in each section and send all to card."""
        print(f"[MOJ-LEAVE] AUTO: Auto-selecting imports and sending all sections to card")

        # FIRST: Re-apply extracted patient details to ensure gender is set
        # This is critical for correct pronoun usage in all previews
        if hasattr(self, '_extracted_patient_details') and self._extracted_patient_details:
            details = self._extracted_patient_details
            gender = details.get("gender")
            if gender:
                print(f"[MOJ-LEAVE] AUTO: Found extracted gender: {gender}")
                # Force set gender even if already set (in case it was wrong)
                if gender == "Male" and hasattr(self, 'gender_male'):
                    self.gender_male.setChecked(True)
                    print(f"[MOJ-LEAVE] AUTO: Set gender_male checked")
                elif gender == "Female" and hasattr(self, 'gender_female'):
                    self.gender_female.setChecked(True)
                    print(f"[MOJ-LEAVE] AUTO: Set gender_female checked")
            else:
                print(f"[MOJ-LEAVE] AUTO: No gender in extracted details")
        else:
            print(f"[MOJ-LEAVE] AUTO: No extracted patient details available")

        # Now update all previews with correct gender
        if hasattr(self, '_update_all_previews_for_gender'):
            self._update_all_previews_for_gender()
            print(f"[MOJ-LEAVE] AUTO: Updated all previews for gender")

        # FALLBACK: Ensure extracted items are populated into import sections
        # This handles timing issues where extraction completes after popup creation
        from PySide6.QtWidgets import QApplication

        populated_any = False
        if hasattr(self, '_extracted_psych_items') and self._extracted_psych_items:
            checkboxes = getattr(self, 'psych_import_checkboxes', [])
            if not checkboxes or len(checkboxes) == 0:
                print(f"[MOJ-LEAVE] AUTO: Populating psych imports from {len(self._extracted_psych_items)} stored items")
                if hasattr(self, '_populate_psych_imports_from_categorized') and hasattr(self, 'psych_import_layout'):
                    self._populate_psych_imports_from_categorized(self._extracted_psych_items)
                    populated_any = True

        if hasattr(self, '_extracted_forensic_items') and self._extracted_forensic_items:
            checkboxes = getattr(self, 'forensic_import_checkboxes', [])
            if not checkboxes or len(checkboxes) == 0:
                print(f"[MOJ-LEAVE] AUTO: Populating forensic imports from {len(self._extracted_forensic_items)} stored items")
                if hasattr(self, '_populate_forensic_imports_from_categorized') and hasattr(self, 'forensic_import_layout'):
                    self._populate_forensic_imports_from_categorized(self._extracted_forensic_items)
                    populated_any = True

        # Process events to ensure UI is synced after populating
        if populated_any:
            QApplication.processEvents()

        # List of (import_checkboxes_attr, popup_key, section_name, preview_update_func)
        sections_with_imports = [
            ("psych_import_checkboxes", "hospital_admissions", "4a Past Psych", "_update_psych_preview_from_imports"),
            ("forensic_import_checkboxes", "index_offence", "4b Forensic", "_update_forensic_preview_from_imports"),
            ("mental_disorder_import_checkboxes", "mental_disorder", "4c Mental Disorder", "_update_mental_disorder_preview"),
            ("attitude_import_checkboxes", "attitude_behaviour", "4d Attitude", "_update_attitude_behaviour_preview"),
            ("risk_import_checkboxes", "risk_factors", "4e Risk", "_update_risk_factors_preview"),
            ("med_import_checkboxes", "medication", "4f Medication", "_update_medication_preview"),
            ("psych_report_import_checkboxes", "psychology", "4g Psychology", "_update_psychology_preview"),
            ("extremism_import_checkboxes", "extremism", "4h Extremism", "_update_extremism_preview"),
            ("awol_import_checkboxes", "absconding", "4i Absconding", "_update_absconding_preview"),
            ("mappa_import_checkboxes", "mappa", "5 MAPPA", "_update_mappa_preview"),
            ("victims_import_checkboxes", "victims", "6 Victims", "_update_victims_preview"),
            ("prisoners_import_checkboxes", "transferred_prisoners", "7 Prisoners", "_update_prisoners_preview"),
            ("fitness_import_checkboxes", "fitness_to_plead", "8 Fitness", "_update_fitness_preview"),
        ]

        for checkboxes_attr, popup_key, section_name, preview_func in sections_with_imports:
            if hasattr(self, checkboxes_attr):
                checkboxes = getattr(self, checkboxes_attr)
                if checkboxes and isinstance(checkboxes, list) and len(checkboxes) > 0:
                    # Auto-select the first entry
                    first_item = checkboxes[0]
                    cb = None

                    # Handle different formats:
                    # 1. Tuple format: (cb, entry)
                    if isinstance(first_item, tuple) and len(first_item) >= 1:
                        cb = first_item[0]
                    # 2. Dict format with 'checkbox' key
                    elif isinstance(first_item, dict) and 'checkbox' in first_item:
                        cb = first_item['checkbox']
                    # 3. Dict format with 'cb' key
                    elif isinstance(first_item, dict) and 'cb' in first_item:
                        cb = first_item['cb']

                    if cb is not None:
                        cb.setChecked(True)
                        QApplication.processEvents()  # Ensure checkbox state is processed
                        print(f"[MOJ-LEAVE] AUTO {section_name}: Auto-selected first import entry")

                        # Call preview update function if it exists
                        if preview_func and hasattr(self, preview_func):
                            getattr(self, preview_func)()
                            print(f"[MOJ-LEAVE] AUTO {section_name}: Updated preview")

        # Process events to ensure all preview updates are complete
        QApplication.processEvents()

        # Debug: Check preview widget contents before sending to cards
        if hasattr(self, 'hospital_admissions'):
            psych_text = self.hospital_admissions.text()
            print(f"[MOJ-LEAVE] AUTO: hospital_admissions preview has {len(psych_text)} chars")
        if hasattr(self, 'index_offence_preview'):
            forensic_text = self.index_offence_preview.text()
            print(f"[MOJ-LEAVE] AUTO: index_offence_preview has {len(forensic_text)} chars")

        # Send ALL sections to card
        all_popup_keys = [
            "hospital_admissions", "index_offence", "mental_disorder", "attitude_behaviour",
            "risk_factors", "medication", "psychology", "extremism", "absconding",
            "mappa", "victims", "transferred_prisoners", "fitness_to_plead", "additional_comments",
            "signature"
        ]

        for popup_key in all_popup_keys:
            if hasattr(self, '_send_to_card'):
                self._send_to_card(popup_key)
                print(f"[MOJ-LEAVE] AUTO: Sent {popup_key} to card")

        # End of auto-fill phase — lock cards against cross-popup updates
        self._auto_fill_phase = False
        print(f"[MOJ-LEAVE] AUTO: Auto-fill phase complete — cards now locked against cross-popup changes")

    def _apply_3b_defaults(self):
        """Apply default checkboxes for 3b - documents reviewed.

        Check everything EXCEPT sara and other_risk_tools.
        """
        # Keys to EXCLUDE
        exclude_keys = ["sara", "other_risk_tools"]

        if hasattr(self, 'documents_checkboxes'):
            for key, cb in self.documents_checkboxes.items():
                if key in exclude_keys:
                    cb.setChecked(False)
                    print(f"[MOJ-LEAVE] AUTO 3b: Unchecked {key}")
                else:
                    cb.setChecked(True)
                    print(f"[MOJ-LEAVE] AUTO 3b: Checked {key}")

        # Send data to card
        if hasattr(self, '_send_to_card'):
            self._send_to_card("documents")
            print(f"[MOJ-LEAVE] AUTO 3b: Sent documents to card")

    def _apply_exclusion_zone_default(self):
        """Set exclusion zone to N/A by default (section 2)."""
        if hasattr(self, 'exclusion_na'):
            self.exclusion_na.setChecked(True)
            print(f"[MOJ-LEAVE] AUTO 2: Set exclusion zone = N/A")
            if hasattr(self, '_send_to_card'):
                self._send_to_card("exclusion_zone")

    def _apply_3c_defaults(self, leave_type, send_to_card=True):
        """Apply 3c defaults based on leave type.

        Purpose radios: "starting", "continuing", "unescorted", "rehabilitation"
        Location checkboxes: "ground", "local", "community", "family"
        Discharge slider: 0-4 ("Not started" to "Completed")
        """
        # Define defaults for each leave type
        # Purpose radio keys: starting, continuing, unescorted, rehabilitation
        # Location checkbox keys: ground, local, community, family
        defaults_map = {
            "escorted_day": {
                "purpose": "starting",  # "Starting meaningful testing"
                "locations": ["ground", "local"],
                "discharge": 0,  # "Not started"
            },
            "escorted_overnight": {
                "purpose": "continuing",  # "Continuing previous leave"
                "locations": ["community"],
                "discharge": 2,  # "In progress"
            },
            "unescorted_day": {
                "purpose": "unescorted",  # "Move to unescorted leave"
                "locations": ["ground", "local", "community"],
                "discharge": 2,  # "In progress"
            },
            "unescorted_overnight": {
                "purpose": "rehabilitation",  # "Rehabilitation process"
                "locations": ["community"],
                "discharge": 4,  # "Completed"
            },
            "compassionate_day": {
                "purpose": "rehabilitation",  # "Rehabilitation"
                "locations": ["community"],
                "discharge": 1,  # "Early stages"
            },
            "compassionate_overnight": {
                "purpose": "rehabilitation",  # "Rehabilitation"
                "locations": ["community"],
                "discharge": 2,  # "In progress"
            },
        }

        if leave_type in defaults_map:
            defaults = defaults_map[leave_type]

            # Set purpose radio if exists
            if hasattr(self, 'purpose_radios'):
                purpose_key = defaults["purpose"]
                if purpose_key in self.purpose_radios:
                    self.purpose_radios[purpose_key].setChecked(True)
                    print(f"[MOJ-LEAVE] AUTO 3c1: Set purpose radio = {purpose_key}")

            # Set location checkboxes if exist
            if hasattr(self, 'location_checkboxes'):
                for loc, cb in self.location_checkboxes.items():
                    cb.setChecked(loc in defaults["locations"])
                print(f"[MOJ-LEAVE] AUTO 3c2: Set locations = {defaults['locations']}")

            # Set exclusion zone to N/A
            if hasattr(self, 'exclusion_na'):
                self.exclusion_na.setChecked(True)
                print(f"[MOJ-LEAVE] AUTO 3c: Set exclusion zone = N/A")

            # Set discharge planning slider if exists
            if hasattr(self, 'discharge_slider'):
                self.discharge_slider.setValue(defaults["discharge"])
                print(f"[MOJ-LEAVE] AUTO 3c3: Set discharge slider = {defaults['discharge']}")

            # Update preview before sending to card
            if hasattr(self, '_update_purpose_preview'):
                self._update_purpose_preview()
                print(f"[MOJ-LEAVE] AUTO 3c: Updated purpose preview")

            # Send to card (if requested)
            if send_to_card and hasattr(self, '_send_to_card'):
                self._send_to_card("purpose")
                print(f"[MOJ-LEAVE] AUTO 3c: Sent purpose to card")

    def _apply_3d_defaults(self, leave_type, send_to_card=True):
        """Apply 3d defaults for unescorted overnight leave.

        If leave_type is unescorted_overnight: Yes + fill details
        Otherwise: N/A
        Always send to card.
        """
        if leave_type == "unescorted_overnight":
            # 3d should be Yes
            if hasattr(self, 'overnight_yes'):
                self.overnight_yes.setChecked(True)
                print(f"[MOJ-LEAVE] AUTO 3d: Set unescorted overnight = YES")

            # Accommodation = 24 hour supported
            if hasattr(self, 'accom_24hr'):
                self.accom_24hr.setChecked(True)
                print(f"[MOJ-LEAVE] AUTO 3d: Set accommodation = 24 hour supported")

            # Address prior to recall = Yes
            if hasattr(self, 'prior_recall_yes'):
                self.prior_recall_yes.setChecked(True)
                print(f"[MOJ-LEAVE] AUTO 3d: Set prior recall = YES")

            # Linked to index offence = No
            if hasattr(self, 'index_link_no'):
                self.index_link_no.setChecked(True)
                print(f"[MOJ-LEAVE] AUTO 3d: Set linked to IO = NO")
        else:
            # Not unescorted overnight - set to N/A
            if hasattr(self, 'overnight_na'):
                self.overnight_na.setChecked(True)
                print(f"[MOJ-LEAVE] AUTO 3d: Set unescorted overnight = N/A")

        # Update preview before sending to card
        if hasattr(self, '_update_overnight_preview'):
            self._update_overnight_preview()

        # Send to card (if requested)
        if send_to_card and hasattr(self, '_send_to_card'):
            self._send_to_card("overnight")
            print(f"[MOJ-LEAVE] AUTO 3d: Sent overnight to card")

    def _apply_3e_defaults(self, leave_type, send_to_card=True):
        """Apply 3e defaults for escorted overnight leave.

        If leave_type is escorted_overnight: Yes + fill details
        Otherwise: N/A
        Always send to card.
        """
        if leave_type == "escorted_overnight":
            # 3e should be Yes
            if hasattr(self, 'escorted_overnight_yes'):
                self.escorted_overnight_yes.setChecked(True)
                print(f"[MOJ-LEAVE] AUTO 3e: Set escorted overnight = YES")

            # Capacity for residence = Yes
            if hasattr(self, 'capacity_yes'):
                self.capacity_yes.setChecked(True)
                print(f"[MOJ-LEAVE] AUTO 3e: Set capacity = YES")

            # Initial testing = Yes
            if hasattr(self, 'initial_testing_yes'):
                self.initial_testing_yes.setChecked(True)
                print(f"[MOJ-LEAVE] AUTO 3e: Set initial testing = YES")
        else:
            # Not escorted overnight - set to N/A
            if hasattr(self, 'escorted_overnight_na'):
                self.escorted_overnight_na.setChecked(True)
                print(f"[MOJ-LEAVE] AUTO 3e: Set escorted overnight = N/A")

        # Update preview before sending to card
        if hasattr(self, '_update_escorted_overnight_preview'):
            self._update_escorted_overnight_preview()

        # Send to card (if requested)
        if send_to_card and hasattr(self, '_send_to_card'):
            self._send_to_card("escorted_overnight")
            print(f"[MOJ-LEAVE] AUTO 3e: Sent escorted_overnight to card")

    def _apply_3f_defaults(self, leave_type, send_to_card=True):
        """Apply 3f defaults for compassionate leave.

        If leave_type contains compassionate: Yes + fill details
        Otherwise: N/A
        Always send to card.
        """
        if "compassionate" in leave_type:
            # 3f should be Yes
            if hasattr(self, 'compassionate_yes'):
                self.compassionate_yes.setChecked(True)
                print(f"[MOJ-LEAVE] AUTO 3f: Set compassionate = YES")

            # Virtual = No (requires physical presence)
            if hasattr(self, 'virtual_no'):
                self.virtual_no.setChecked(True)
                print(f"[MOJ-LEAVE] AUTO 3f: Set virtual = NO")

            # Urgent = Yes
            if hasattr(self, 'urgent_yes'):
                self.urgent_yes.setChecked(True)
                print(f"[MOJ-LEAVE] AUTO 3f: Set urgent = YES")
        else:
            # Not compassionate - set to N/A
            if hasattr(self, 'compassionate_na'):
                self.compassionate_na.setChecked(True)
                print(f"[MOJ-LEAVE] AUTO 3f: Set compassionate = N/A")

        # Update preview before sending to card
        if hasattr(self, '_update_compassionate_preview'):
            self._update_compassionate_preview()

        # Send to card (if requested)
        if send_to_card and hasattr(self, '_send_to_card'):
            self._send_to_card("compassionate")
            print(f"[MOJ-LEAVE] AUTO 3f: Sent compassionate to card")

    def _apply_3h_defaults(self, leave_type, send_to_card=True):
        """Apply 3h Proposed Management defaults based on leave type from 3a.

        Common to all: exclusion zone N/A, all pre-leave checked, all on-return checked,
                       specific to patient checked.

        - compassionate (day/overnight): escorts 2, transport hospital
        - escorted_day: escorts 1, transport hospital/taxi/public
        - escorted_overnight: escorts nil, transport hospital
        - unescorted_day: escorts nil, transport hospital/taxi/public
        - unescorted_overnight: escorts nil, transport hospital
        """
        print(f"[MOJ-LEAVE] AUTO 3h: Applying proposed management defaults for {leave_type}")

        # Helper to set all pre-leave checkboxes
        def select_all_preleave():
            if hasattr(self, 'pre_leave_checkboxes'):
                for cb in self.pre_leave_checkboxes.values():
                    cb.setChecked(True)

        # Helper to set all on-return checkboxes
        def select_all_onreturn():
            if hasattr(self, 'on_return_checkboxes'):
                for cb in self.on_return_checkboxes.values():
                    cb.setChecked(True)
            if hasattr(self, 'breach_checkboxes'):
                for cb in self.breach_checkboxes.values():
                    cb.setChecked(True)

        # Helper to clear all transport checkboxes
        def clear_transport():
            if hasattr(self, 'transport_checkboxes'):
                for cb in self.transport_checkboxes.values():
                    cb.setChecked(False)

        # Set exclusion zone to N/A (common to all)
        if hasattr(self, 'exclusion_na'):
            self.exclusion_na.setChecked(True)

        # Select all pre-leave and on-return (common to all)
        select_all_preleave()
        select_all_onreturn()

        # Specific to patient (common to all)
        if hasattr(self, 'specific_to_patient'):
            self.specific_to_patient.setChecked(True)

        # Clear transport first
        clear_transport()

        # Apply leave-type specific defaults
        if "compassionate" in leave_type:
            # Escorts: 2
            if hasattr(self, 'escorts_dropdown'):
                self.escorts_dropdown.setCurrentIndex(2)  # "2"
            # Transport: Hospital only
            if hasattr(self, 'transport_checkboxes'):
                self.transport_checkboxes["hospital"].setChecked(True)
            print(f"[MOJ-LEAVE] AUTO 3h: Compassionate - escorts 2, transport hospital")

        elif leave_type == "escorted_day":
            # Escorts: 1
            if hasattr(self, 'escorts_dropdown'):
                self.escorts_dropdown.setCurrentIndex(1)  # "1"
            # Transport: Hospital, Taxi, Public
            if hasattr(self, 'transport_checkboxes'):
                self.transport_checkboxes["hospital"].setChecked(True)
                self.transport_checkboxes["taxi"].setChecked(True)
                self.transport_checkboxes["public"].setChecked(True)
            print(f"[MOJ-LEAVE] AUTO 3h: Escorted day - escorts 1, transport hospital/taxi/public")

        elif leave_type == "escorted_overnight":
            # Escorts: nil (index 0 = "Select...")
            if hasattr(self, 'escorts_dropdown'):
                self.escorts_dropdown.setCurrentIndex(0)
            # Transport: Hospital only
            if hasattr(self, 'transport_checkboxes'):
                self.transport_checkboxes["hospital"].setChecked(True)
            print(f"[MOJ-LEAVE] AUTO 3h: Escorted overnight - no escorts, transport hospital")

        elif leave_type == "unescorted_day":
            # Escorts: nil
            if hasattr(self, 'escorts_dropdown'):
                self.escorts_dropdown.setCurrentIndex(0)
            # Transport: Hospital, Taxi, Public
            if hasattr(self, 'transport_checkboxes'):
                self.transport_checkboxes["hospital"].setChecked(True)
                self.transport_checkboxes["taxi"].setChecked(True)
                self.transport_checkboxes["public"].setChecked(True)
            print(f"[MOJ-LEAVE] AUTO 3h: Unescorted day - no escorts, transport hospital/taxi/public")

        elif leave_type == "unescorted_overnight":
            # Escorts: nil
            if hasattr(self, 'escorts_dropdown'):
                self.escorts_dropdown.setCurrentIndex(0)
            # Transport: Hospital only
            if hasattr(self, 'transport_checkboxes'):
                self.transport_checkboxes["hospital"].setChecked(True)
            print(f"[MOJ-LEAVE] AUTO 3h: Unescorted overnight - no escorts, transport hospital")

        # Update preview
        if hasattr(self, '_update_section_3h_text'):
            self._update_section_3h_text()

        # Send to card (if requested)
        if send_to_card and hasattr(self, '_send_to_card'):
            self._send_to_card("procedures")
            print(f"[MOJ-LEAVE] AUTO 3h: Sent procedures to card")

    def _update_3a_section_enabled_state(self):
        """Enable/disable 3a checkboxes based on which section is currently active.

        If any checkbox in a section is checked, disable all checkboxes in other sections.
        If no checkboxes are checked, enable all checkboxes.
        """
        if not hasattr(self, 'leave_type_checkboxes'):
            return

        # Find which section(s) have checked checkboxes
        active_section = None
        for cb_key, cb in self.leave_type_checkboxes.items():
            if cb.isChecked():
                active_section = cb_key.rsplit('_', 1)[0]  # e.g., "escorted_day" -> "escorted"
                break

        # Update enabled state for all checkboxes
        for cb_key, cb in self.leave_type_checkboxes.items():
            cb_section = cb_key.rsplit('_', 1)[0]
            if active_section is None:
                # No section active - enable all
                cb.setEnabled(True)
                cb.setStyleSheet("font-size: 19px;")
            elif cb_section == active_section:
                # Same section as active - keep enabled
                cb.setEnabled(True)
                cb.setStyleSheet("font-size: 19px;")
            else:
                # Different section - disable (grey out)
                cb.setEnabled(False)
                cb.setStyleSheet("font-size: 19px; color: #9ca3af;")

    def _on_3a_leave_type_changed(self, leave_type, state):
        """Called when a leave type checkbox in 3a is clicked.

        Updates 3c/3d/3e/3f/3g/3h defaults based on the selected leave type.
        Data stays in the popups - user must explicitly send to card.
        Sections are mutually exclusive (compassionate/escorted/unescorted),
        but day+overnight can be selected within the same section.
        """
        # Determine which section this leave_type belongs to
        section = leave_type.rsplit('_', 1)[0]  # e.g., "escorted_day" -> "escorted"

        # Check if ANY checkbox in ANY section is currently checked
        any_checked_in_section = {}
        if hasattr(self, 'leave_type_checkboxes'):
            for cb_key, cb in self.leave_type_checkboxes.items():
                cb_section = cb_key.rsplit('_', 1)[0]
                if cb_section not in any_checked_in_section:
                    any_checked_in_section[cb_section] = False
                if cb.isChecked():
                    any_checked_in_section[cb_section] = True

        # When checkbox is unchecked
        if state != 2:
            print(f"[MOJ-LEAVE] 3a leave type UNCHECKED: {leave_type}")
            # Check if any checkbox in the same section is still checked
            section_still_has_checked = any_checked_in_section.get(section, False)
            if not section_still_has_checked:
                # No checkboxes in this section are checked anymore - reset and re-enable all
                print(f"[MOJ-LEAVE] 3a: Section {section} has no checkboxes checked - resetting and re-enabling all")
                self._reset_leave_sections()
                self._update_3a_section_enabled_state()
            return

        print(f"[MOJ-LEAVE] 3a leave type changed: {leave_type} (section: {section})")

        # Grey out other sections and uncheck their checkboxes
        if hasattr(self, 'leave_type_checkboxes'):
            for cb_key, cb in self.leave_type_checkboxes.items():
                cb_section = cb_key.rsplit('_', 1)[0]
                if cb_section != section:
                    # Different section - uncheck and disable
                    if cb.isChecked():
                        cb.blockSignals(True)
                        cb.setChecked(False)
                        cb.blockSignals(False)
                        print(f"[MOJ-LEAVE] 3a: Unchecked {cb_key} (different section)")

        # Update enabled/disabled state of all checkboxes
        self._update_3a_section_enabled_state()

        # Ensure all relevant popups exist so we can set their values
        self._ensure_popups_created(["purpose", "overnight", "escorted_overnight", "compassionate", "leave_report", "procedures"])

        # Apply defaults for all sections (stays in popup only - no auto-send to card)
        self._apply_3c_defaults(leave_type, send_to_card=False)
        print(f"[MOJ-LEAVE] 3c defaults applied to popup for {leave_type}")

        self._apply_3d_defaults(leave_type, send_to_card=False)
        print(f"[MOJ-LEAVE] 3d defaults applied to popup for {leave_type}")

        self._apply_3e_defaults(leave_type, send_to_card=False)
        print(f"[MOJ-LEAVE] 3e defaults applied to popup for {leave_type}")

        self._apply_3f_defaults(leave_type, send_to_card=False)
        print(f"[MOJ-LEAVE] 3f defaults applied to popup for {leave_type}")

        self._apply_3g_defaults(leave_type, send_to_card=False)
        print(f"[MOJ-LEAVE] 3g defaults applied to popup for {leave_type}")

        self._apply_3h_defaults(leave_type, send_to_card=False)
        print(f"[MOJ-LEAVE] 3h defaults applied to popup for {leave_type}")

    def _apply_3g_defaults(self, leave_type, send_to_card=True):
        """Apply 3g Leave Report defaults based on leave type from 3a.

        - escorted_day: Empty, preview = "No leave taken yet", suspended = No
        - escorted_overnight: Escorted, 3 leaves weekly 2hrs, Ground/Local/Community 33% each, suspended = No
        - unescorted_day: Same as escorted_overnight
        - unescorted_overnight: Escorted same + Unescorted Ground(11%)/Local(36%)/Community(53%), suspended = No
        - compassionate (day or overnight): All leave nil, suspended = No
        """
        print(f"[MOJ-LEAVE] AUTO 3g: Applying leave report defaults for {leave_type}")

        # Helper to set leave type weights
        def set_escorted_defaults():
            """Set escorted leave: 3 leaves weekly 2hrs, Ground/Local/Community at 33%."""
            # Block signals to prevent cascading redistributions during bulk update
            widgets_to_unblock = []
            for attr in ['leaves_dropdown', 'frequency_dropdown', 'duration_dropdown',
                         'leave_escorted_radio', 'leave_unescorted_radio']:
                if hasattr(self, attr):
                    getattr(self, attr).blockSignals(True)
                    widgets_to_unblock.append(getattr(self, attr))
            if hasattr(self, 'leave_type_widgets'):
                for widgets in self.leave_type_widgets.values():
                    widgets["cb"].blockSignals(True)
                    widgets["slider"].blockSignals(True)
                    widgets_to_unblock.append(widgets["cb"])
                    widgets_to_unblock.append(widgets["slider"])

            if hasattr(self, 'leave_escorted_radio'):
                self.leave_escorted_radio.setChecked(True)

            if hasattr(self, 'leaves_dropdown'):
                self.leaves_dropdown.setCurrentIndex(2)  # "3" (0-indexed: 0=1, 1=2, 2=3)

            if hasattr(self, 'frequency_dropdown'):
                self.frequency_dropdown.setCurrentIndex(0)  # "Weekly"

            if hasattr(self, 'duration_dropdown'):
                self.duration_dropdown.setCurrentIndex(2)  # "2 hours" (0=30mins, 1=1hr, 2=2hrs)

            if hasattr(self, 'leave_type_widgets'):
                # Uncheck all first
                for key, widgets in self.leave_type_widgets.items():
                    widgets["cb"].setChecked(False)
                    widgets["slider"].setValue(0)
                    widgets["slider"].setEnabled(False)
                    widgets["label"].setText("0%")

                # Check Ground, Local, Community with 33% each
                for key in ["ground", "local", "community"]:
                    if key in self.leave_type_widgets:
                        self.leave_type_widgets[key]["cb"].setChecked(True)
                        self.leave_type_widgets[key]["slider"].setEnabled(True)
                        self.leave_type_widgets[key]["slider"].setValue(33)
                        self.leave_type_widgets[key]["label"].setText("33%")

            # Unblock signals after all values are set
            for w in widgets_to_unblock:
                w.blockSignals(False)

            print(f"[MOJ-LEAVE] AUTO 3g: Set escorted defaults (3 weekly, 2hrs, Ground/Local/Community 33%)")

        def set_unescorted_defaults():
            """Add unescorted leave: Ground(11%)/Local(36%)/Community(53%)."""
            # Block signals to prevent cascading redistributions during bulk update
            widgets_to_unblock = []
            for attr in ['leaves_dropdown', 'frequency_dropdown', 'duration_dropdown',
                         'leave_escorted_radio', 'leave_unescorted_radio']:
                if hasattr(self, attr):
                    getattr(self, attr).blockSignals(True)
                    widgets_to_unblock.append(getattr(self, attr))
            if hasattr(self, 'leave_type_widgets'):
                for widgets in self.leave_type_widgets.values():
                    widgets["cb"].blockSignals(True)
                    widgets["slider"].blockSignals(True)
                    widgets_to_unblock.append(widgets["cb"])
                    widgets_to_unblock.append(widgets["slider"])

            if hasattr(self, 'leave_unescorted_radio'):
                self.leave_unescorted_radio.setChecked(True)

            if hasattr(self, 'leaves_dropdown'):
                self.leaves_dropdown.setCurrentIndex(2)  # "3"

            if hasattr(self, 'frequency_dropdown'):
                self.frequency_dropdown.setCurrentIndex(0)  # "Weekly"

            if hasattr(self, 'duration_dropdown'):
                self.duration_dropdown.setCurrentIndex(2)  # "2 hours"

            if hasattr(self, 'leave_type_widgets'):
                # Uncheck all first
                for key, widgets in self.leave_type_widgets.items():
                    widgets["cb"].setChecked(False)
                    widgets["slider"].setValue(0)
                    widgets["slider"].setEnabled(False)
                    widgets["label"].setText("0%")

                # Check Ground (11%), Local (36%), Community (53%)
                percentages = {"ground": 11, "local": 36, "community": 53}
                for key, pct in percentages.items():
                    if key in self.leave_type_widgets:
                        self.leave_type_widgets[key]["cb"].setChecked(True)
                        self.leave_type_widgets[key]["slider"].setEnabled(True)
                        self.leave_type_widgets[key]["slider"].setValue(pct)
                        self.leave_type_widgets[key]["label"].setText(f"{pct}%")

            # Unblock signals after all values are set
            for w in widgets_to_unblock:
                w.blockSignals(False)

            print(f"[MOJ-LEAVE] AUTO 3g: Set unescorted defaults (Ground 11%, Local 36%, Community 53%)")

        def clear_all_leave():
            """Clear all leave settings."""
            if hasattr(self, 'leave_type_widgets'):
                for key, widgets in self.leave_type_widgets.items():
                    widgets["cb"].setChecked(False)
                    widgets["slider"].setValue(0)
                    widgets["slider"].setEnabled(False)
                    widgets["label"].setText("0%")

            # Clear other leave checkboxes
            if hasattr(self, 'leave_medical_cb'):
                self.leave_medical_cb.setChecked(False)
            if hasattr(self, 'leave_court_cb'):
                self.leave_court_cb.setChecked(False)
            if hasattr(self, 'leave_compassionate_cb'):
                self.leave_compassionate_cb.setChecked(False)

            print(f"[MOJ-LEAVE] AUTO 3g: Cleared all leave settings")

        # Always set leave suspended to No by default
        if hasattr(self, 'suspended_no'):
            self.suspended_no.setChecked(True)
            print(f"[MOJ-LEAVE] AUTO 3g: Set leave suspended = No")

        # Apply defaults based on leave type
        if leave_type == "escorted_day":
            # Empty 3g, preview = "No leave taken yet"
            clear_all_leave()
            if hasattr(self, 'leave_report_preview'):
                self.leave_report_preview.setText("No leave taken yet.")
            print(f"[MOJ-LEAVE] AUTO 3g: Escorted day - no leave taken yet")

        elif leave_type == "escorted_overnight":
            # Set escorted leave defaults
            set_escorted_defaults()
            if hasattr(self, '_update_leave_report_preview'):
                self._update_leave_report_preview()

        elif leave_type == "unescorted_day":
            # Same as escorted_overnight
            set_escorted_defaults()
            if hasattr(self, '_update_leave_report_preview'):
                self._update_leave_report_preview()

        elif leave_type == "unescorted_overnight":
            # First set escorted state, then switch to unescorted with different weights
            # Save escorted state first
            if hasattr(self, '_leave_escorted_state'):
                # Set escorted defaults
                set_escorted_defaults()
                # Save this as escorted state
                if hasattr(self, '_save_leave_state'):
                    self._save_leave_state(self._leave_escorted_state)

            # Now set unescorted state
            set_unescorted_defaults()
            if hasattr(self, '_update_leave_report_preview'):
                self._update_leave_report_preview()

        elif "compassionate" in leave_type:
            # All leave to nil
            clear_all_leave()
            if hasattr(self, 'leave_report_preview'):
                self.leave_report_preview.setText("No leave taken yet.")
            print(f"[MOJ-LEAVE] AUTO 3g: Compassionate - no leave taken")

        # Send to card (if requested)
        if send_to_card and hasattr(self, '_send_to_card'):
            self._send_to_card("leave_report")
            print(f"[MOJ-LEAVE] AUTO 3g: Sent leave_report to card")

    def _export_all_popups_to_cards(self):
        """Export data from all popups to their respective cards."""
        print(f"[MOJ-LEAVE] AUTO: Exporting all popups to cards")

        # List of all popup keys to export
        popup_keys = [
            "patient_details", "previous_leave", "leave_type", "clinical_info",
            "leave_purpose", "overnight", "escorted_overnight", "compassionate",
            "leave_overview", "exclusion_zone", "risk_history", "current_risk",
            "risk_management", "psychology", "extremism", "awol", "mappa",
            "transferred_prisoners", "fitness_to_plead", "victim_liaison",
            "additional_comments"
        ]

        for key in popup_keys:
            if hasattr(self, '_send_to_card'):
                try:
                    self._send_to_card(key)
                    print(f"[MOJ-LEAVE] AUTO: Exported {key} to card")
                except Exception as e:
                    print(f"[MOJ-LEAVE] AUTO: Failed to export {key}: {e}")

    def _import_data(self):
        """Import file and auto-generate form - shows leave type selection, then file picker."""
        from PySide6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel,
                                        QPushButton, QButtonGroup, QFileDialog,
                                        QMessageBox, QGroupBox, QRadioButton)
        from PySide6.QtCore import Qt

        # Create dialog for leave type selection
        dialog = QDialog(self)
        dialog.setWindowTitle("Import Data")
        dialog.setFixedWidth(530)
        dialog.setStyleSheet("background: white;")

        layout = QVBoxLayout(dialog)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(16)

        # Intro message
        intro = QLabel("Select the type of leave you are applying for, then upload your data.\n\n"
                       "The form will be auto-populated and all sections sent to cards.")
        intro.setWordWrap(True)
        intro.setStyleSheet("font-size: 17px; color: #374151; line-height: 1.5;")
        layout.addWidget(intro)

        # Leave type selection group
        leave_group = QGroupBox("Select Leave Type")
        leave_group.setStyleSheet("QGroupBox { font-weight: 600; font-size: 15px; padding-top: 12px; }")
        leave_layout = QVBoxLayout(leave_group)
        leave_layout.setSpacing(8)

        self._auto_leave_type = None
        leave_button_group = QButtonGroup(dialog)

        leave_options = [
            ("escorted_day", "Escorted Community (Day)"),
            ("escorted_overnight", "Escorted (Overnight)"),
            ("unescorted_day", "Unescorted Community (Day)"),
            ("unescorted_overnight", "Unescorted Community (Overnight)"),
            ("compassionate_day", "Compassionate (Day)"),
            ("compassionate_overnight", "Compassionate (Overnight)"),
        ]

        self._auto_leave_radios = {}
        for key, label in leave_options:
            radio = QRadioButton(label)
            radio.setStyleSheet("font-size: 15px; padding: 4px;")
            leave_button_group.addButton(radio)
            leave_layout.addWidget(radio)
            self._auto_leave_radios[key] = radio

        layout.addWidget(leave_group)

        # Buttons row
        btn_row = QHBoxLayout()
        btn_row.addStretch()

        cancel_btn = QPushButton("Cancel")
        cancel_btn.setFixedSize(100, 36)
        cancel_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        cancel_btn.setStyleSheet("""
            QPushButton { background: #e5e7eb; color: #374151; font-size: 17px;
                          font-weight: 600; border: none; border-radius: 6px; }
            QPushButton:hover { background: #d1d5db; }
        """)
        cancel_btn.clicked.connect(dialog.reject)
        btn_row.addWidget(cancel_btn)

        from PySide6.QtWidgets import QToolButton, QMenu
        from shared_data_store import get_shared_store
        upload_btn = QToolButton()
        upload_btn.setText("Select Doc & Generate")
        upload_btn.setFixedSize(180, 36)
        upload_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        upload_btn.setPopupMode(QToolButton.InstantPopup)
        auto_menu = QMenu()
        upload_btn.setMenu(auto_menu)
        upload_btn.setStyleSheet("""
            QToolButton { background: #2563eb; color: white; font-size: 17px;
                          font-weight: 600; border: none; border-radius: 6px; }
            QToolButton:hover { background: #1d4ed8; }
            QToolButton::menu-indicator { image: none; }
        """)

        def populate_auto_menu(docs=None):
            auto_menu.clear()
            if docs is None:
                docs = get_shared_store().get_uploaded_documents()
            if not docs:
                action = auto_menu.addAction("No documents uploaded")
                action.setEnabled(False)
            else:
                for doc in docs:
                    path = doc["path"]
                    action = auto_menu.addAction(doc["filename"])
                    action.triggered.connect(lambda checked=False, p=path: on_select_doc(p))

        def on_select_doc(file_path):
            selected_leave = None
            for key, radio in self._auto_leave_radios.items():
                if radio.isChecked():
                    selected_leave = key
                    break
            if not selected_leave:
                QMessageBox.warning(dialog, "Selection Required", "Please select a leave type first.")
                return
            self._auto_selected_leave_type = selected_leave
            dialog.accept()
            self._process_auto_import(file_path, selected_leave)

        populate_auto_menu()
        get_shared_store().uploaded_documents_changed.connect(populate_auto_menu)
        btn_row.addWidget(upload_btn)

        layout.addLayout(btn_row)

        dialog.exec()

    def _view_data(self):
        """View data extractor popup (no longer shown)."""
        pass

    def _extract_patient_details_from_data(self):
        """Extract all patient details (Section 1) from imported document/notes text."""
        import re
        from datetime import datetime

        def _short_kw_matches(kw, text_lower):
            """Check if keyword matches in text, using word boundaries for short keywords (<=5 chars)."""
            if len(kw) <= 5:
                return bool(re.search(r'(?<!\w)' + re.escape(kw) + r'(?!\w)', text_lower, re.IGNORECASE))
            return kw in text_lower

        # Get document text from extractor notes
        document_text = ""
        demographics_header = ""
        source_info = []  # Track where data comes from
        if hasattr(self, '_data_extractor') and self._data_extractor:
            # Try to get notes from the extractor
            notes = getattr(self._data_extractor, 'notes', [])
            if not notes and hasattr(self._data_extractor, '_raw_notes'):
                notes = self._data_extractor._raw_notes

            # Check for demographics header (Carenotes exports have patient details
            # in pre-date header rows that aren't part of any note's text)
            for note in notes:
                demo = note.get("demographics_header", "")
                if demo:
                    demographics_header = demo
                    print(f"[MOJ-LEAVE] Found demographics header ({len(demo)} chars)")
                    break

            # Combine text from all notes
            for note in notes:
                text = note.get("text", "") or note.get("body", "") or note.get("content", "")
                if text:
                    document_text += text + "\n"
                    # Track source info
                    source = note.get("source", {})
                    filename = source.get("filename", "unknown") if isinstance(source, dict) else "unknown"
                    report_type = note.get("report_type", "unknown")
                    source_info.append(f"{filename} ({report_type})")

            # Prepend demographics header so name/DOB/NHS patterns can find it
            if demographics_header:
                document_text = demographics_header + "\n" + document_text

        if not document_text.strip():
            print("[MOJ-LEAVE] No document text available for patient details extraction")
            return

        print(f"[MOJ-LEAVE] Extracting patient details from {len(document_text)} chars")
        print(f"[MOJ-LEAVE] Data sources: {', '.join(source_info) if source_info else 'unknown'}")

        # ================================================================
        # EXTRACT PATIENT NAME
        # ================================================================
        # Strategy: Patient details are at the top of notes.
        # The patient's first name repeats throughout the document.
        # We use both label-based patterns AND frequency analysis.

        # Focus on the first 5000 chars (header area) for label-based patterns
        # Carenotes exports can have system menus before the patient demographics
        header_text = document_text[:5000]

        name_patterns = [
            # CLINICAL SYSTEM HEADER: "SURNAME, Firstname Middle (Title)" at start of document
            # e.g., "ADENIYI, Antonia Oluwaseuni (Miss)4 Jun 1985"
            (r'^([A-Z][A-Z\-\']+),\s*([A-Z][a-zA-Z\-\']+(?:\s+[A-Z][a-zA-Z\-\']+)?)', 'surname_first_header', 'header'),
            # "Surname, Firstname (Title)" — Carenotes/clinical system format
            # e.g., "Hornberger, Jayne (Mx)" or "Smith, John (Mr)"
            (r'\b([A-Z][a-zA-Z\-\']{2,}),\s+([A-Z][a-zA-Z\-\']+(?:\s+[A-Z][a-zA-Z\-\']+)?)\s*\((?:Mr|Mrs|Ms|Miss|Mx|Dr)\.?\)', 'surname_comma_title', 'full'),
            # "PATIENT NAME" followed by name (with or without colon) - stops at newline
            (r'patient\s+name\s*[:]?\s*([A-Z][a-zA-Z\-\']+(?:[ ]+[A-Z][a-zA-Z\-\']+){0,3})(?=\n|$)', 'patient_name_label', 'full'),
            # "Name of Patient:" on one line, name on next (RC reports)
            (r'name\s+of\s+patient\s*[:]?\s*\n\s*([A-Z][a-zA-Z\-\']+(?:[ ]+[A-Z][a-zA-Z\-\']+){0,3})(?=\n|$)', 'name_of_patient', 'full'),
            # "Patient Name:" or "Name:" followed by text (same line)
            (r'(?:patient\s+)?name\s*[:]\s*([A-Z][a-zA-Z\-\']+(?:[ ]+[A-Z][a-zA-Z\-\']+){0,3})(?=\n|$)', 'name_colon', 'full'),
            # "Patient:" followed by text
            (r'patient\s*[:]\s*([A-Z][a-zA-Z\-\']+(?:[ ]+[A-Z][a-zA-Z\-\']+){0,3})(?=\n|$)', 'patient_colon', 'full'),
            # "Re:" followed by name (common in letters/reports)
            (r're\s*[:]\s*([A-Z][a-zA-Z\-\']+(?:[ ]+[A-Z][a-zA-Z\-\']+){0,3})(?=\n|$)', 're_colon', 'full'),
            # "SURNAME, Firstname" — all-caps surname (clinical format)
            (r'\b([A-Z][A-Z\-\']+),\s+([A-Z][a-zA-Z\-\']+(?:\s+[A-Z][a-zA-Z\-\']+)?)\s*(?:\(|$|\n)', 'surname_comma_allcaps', 'full'),
            # Title followed by name (Mr/Mrs/Ms/Miss/Dr)
            (r'\b((?:Mr|Mrs|Ms|Miss|Mx|Dr)\.?\s+[A-Z][a-zA-Z\-\']+(?:[ ]+[A-Z][a-zA-Z\-\']+){0,2})\b', 'title_name', 'full'),
        ]

        extracted_name = None
        for pattern_tuple in name_patterns:
            pattern, pattern_name, scope = pattern_tuple
            search_text = header_text if scope == 'header' else document_text
            match = re.search(pattern, search_text, re.IGNORECASE if 'header' not in pattern_name else 0)
            if match:
                if pattern_name in ('surname_first_header', 'surname_comma_title', 'surname_comma_allcaps'):
                    surname = match.group(1).strip()
                    firstname = match.group(2).strip()
                    if surname.isupper():
                        surname = surname.title()
                    name = f"{firstname} {surname}"
                else:
                    name = match.group(1).strip()

                name = re.sub(r'\s*\(.*?\)\s*', ' ', name)
                name = re.sub(r'[,;:\s]+$', '', name)
                name = name.strip()

                if 2 <= len(name) <= 60:
                    extracted_name = name
                    print(f"[MOJ-LEAVE] Extracted patient name: '{extracted_name}' (pattern: {pattern_name})")
                    break

        # ----------------------------------------------------------------
        # FREQUENCY-BASED NAME DETECTION (fallback / validation)
        # ----------------------------------------------------------------
        # Clinical notes repeat the patient's first name many times.
        # Extract candidate proper nouns from the header area and count
        # how often each appears in the full document.

        # Common words to exclude from name candidates
        EXCLUDE_WORDS = {
            # Common English words
            "the", "and", "for", "with", "from", "has", "have", "had", "was", "were",
            "been", "being", "are", "this", "that", "will", "would", "could", "should",
            "not", "but", "his", "her", "she", "him", "they", "them", "their",
            "there", "here", "when", "what", "which", "where", "who", "how", "all",
            "any", "each", "other", "some", "such", "than", "then", "also", "into",
            "about", "over", "after", "before", "between", "under", "during", "since",
            "through", "until", "while", "upon", "within", "without", "only",
            "more", "most", "very", "just", "still", "already", "again",
            # Clinical / form terms
            "patient", "ward", "hospital", "doctor", "nurse", "staff", "team",
            "section", "mental", "health", "act", "leave", "community", "risk",
            "report", "clinical", "notes", "date", "name", "number", "address",
            "diagnosis", "medication", "treatment", "assessment", "review",
            "progress", "behaviour", "behavior", "history", "forensic",
            "offence", "offense", "violence", "self", "harm", "suicide",
            "tribunal", "responsible", "clinician", "approved", "ministry",
            "justice", "secretary", "state", "application", "nhs", "care",
            "plan", "discharge", "admission", "transfer", "detention",
            "capacity", "consent", "insight", "psychology", "psychiatry",
            "social", "work", "occupational", "therapy", "nursing",
            "escorted", "unescorted", "ground", "local", "overnight",
            "restricted", "unrestricted", "index", "current", "previous",
            "presenting", "complaint", "examination", "summary", "opinion",
            "recommendation", "male", "female", "age", "born", "years",
            "page", "continued", "none", "nil", "yes", "unknown",
            "good", "poor", "moderate", "high", "low", "level", "type",
            "form", "miss", "mrs", "submitted",
            # Days and months
            "january", "february", "march", "april", "may", "june",
            "july", "august", "september", "october", "november", "december",
            "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday",
            # Schema therapy / psychology terms that appear capitalised
            "child", "parent", "adult", "vulnerable", "angry", "impulsive", "happy",
            "healthy", "punitive", "demanding", "critical", "detached", "protector",
            "compliant", "surrenderer", "overcompensator", "mode", "modes", "schema",
            "schemas", "maladaptive", "coping", "avoidant", "autonomy",
            # Common clinical note words that may be capitalised
            "session", "author", "writer", "facilitated", "discussed", "reported",
            "observations", "recommendations", "confirmed", "plan", "aims", "aim",
            "title", "general", "note", "inpatients", "inpatient", "shift",
            "night", "morning", "afternoon", "evening", "daily",
            "programme", "program", "status", "alert", "alerts",
            "consultant", "primary", "worker", "coordinator", "senior",
            "specialist", "registrar", "practitioner", "assistant",
            "support", "service", "location", "return", "select",
            "label", "field", "input", "search", "manage", "groups",
            "bedstate", "live", "tasks", "outstanding", "diary",
            "caseload", "carenotes", "casenotes",
            # Other common words that get capitalised at line starts
            "however", "therefore", "although", "because", "whether",
            "continued", "following", "regarding", "discussed", "agreed",
            "attended", "engaged", "presented", "appeared", "stated",
            "explained", "described", "reported", "noted", "identified",
            "suggested", "encouraged", "informed", "advised", "provided",
            "completed", "offered", "declined", "accepted",
        }

        def _extract_name_by_frequency(header, full_text):
            """Find the patient name by looking for proper nouns in the header
            that repeat frequently in the full document."""
            from collections import Counter

            # Extract capitalised words from the full document header area
            # Expand to first 5000 chars to catch patient demographics that may
            # appear after system menus (e.g., Carenotes header rows)
            header_words = re.findall(r'\b([A-Z][a-z]{2,})\b', header[:5000])

            # Also extract from the full document for counting
            word_counts = Counter()
            seen = set()
            for word in header_words:
                wl = word.lower()
                if wl in seen or wl in EXCLUDE_WORDS or len(word) < 3:
                    continue
                seen.add(wl)
                # Count whole-word occurrences in full document
                count = len(re.findall(r'\b' + re.escape(word) + r'\b', full_text, re.IGNORECASE))
                if count >= 3:
                    word_counts[word] = count

            if not word_counts:
                return None, None

            print(f"[MOJ-LEAVE] Name frequency candidates: {dict(word_counts.most_common(10))}")

            # Verify candidates are used as person names by checking if they
            # appear in subject-of-sentence patterns (e.g., "Jayne said", "Jayne was")
            PERSON_VERBS = r'(?:said|was|is|has|had|did|does|will|would|could|can|may|might|' \
                           r'reported|stated|explained|described|confirmed|agreed|' \
                           r'engaged|attended|presented|appeared|noted|denied|' \
                           r'asked|told|spoke|looked|felt|wanted|needed|started|' \
                           r'acknowledged|nodded|consented|declined|refused)'
            verified_counts = Counter()
            for word, count in word_counts.items():
                # Check if this word is used as a subject (Name + verb)
                person_uses = len(re.findall(
                    r'\b' + re.escape(word) + r'\s+' + PERSON_VERBS,
                    full_text, re.IGNORECASE
                ))
                if person_uses >= 2:
                    # Boost count by person-usage confirmation
                    verified_counts[word] = count
                    print(f"[MOJ-LEAVE] '{word}' verified as person name ({person_uses} person-verb patterns, {count} total)")

            # Use verified counts if we have any, otherwise fall back to raw counts
            if verified_counts:
                word_counts = verified_counts

            # The most-repeated proper noun from the header is likely the first name
            most_common = word_counts.most_common(5)
            candidate_first = most_common[0][0]
            candidate_first_count = most_common[0][1]

            # Now find the surname: look for a capitalised word that appears
            # RIGHT NEXT TO the first name in the header area
            # Try "Firstname Surname" and "SURNAME, Firstname" patterns
            surname = None

            # Pattern 1: "Firstname Surname" in header
            fn_surname_match = re.search(
                r'\b' + re.escape(candidate_first) + r'\s+([A-Z][a-zA-Z\-\']{2,})\b',
                header[:1500]
            )
            if fn_surname_match:
                sn = fn_surname_match.group(1)
                if sn.lower() not in EXCLUDE_WORDS:
                    surname = sn
                    print(f"[MOJ-LEAVE] Found surname after first name: '{surname}'")

            # Pattern 2: "SURNAME, Firstname" or "Surname Firstname" — surname before
            if not surname:
                surname_fn_match = re.search(
                    r'\b([A-Z][a-zA-Z\-\']{2,})\s*,?\s+' + re.escape(candidate_first) + r'\b',
                    header[:1500]
                )
                if surname_fn_match:
                    sn = surname_fn_match.group(1)
                    if sn.lower() not in EXCLUDE_WORDS:
                        surname = sn
                        if sn.isupper():
                            surname = sn.title()
                        print(f"[MOJ-LEAVE] Found surname before first name: '{surname}'")

            # Pattern 3: check if there's another high-frequency proper noun that
            # appears adjacent to the first name
            if not surname and len(most_common) >= 2:
                for other_word, other_count in most_common[1:]:
                    if other_word.lower() == candidate_first.lower():
                        continue
                    # Check if these two words appear together anywhere
                    together = re.search(
                        r'\b' + re.escape(candidate_first) + r'\s+' + re.escape(other_word) + r'\b',
                        header[:2000], re.IGNORECASE
                    )
                    if not together:
                        together = re.search(
                            r'\b' + re.escape(other_word) + r'\s+' + re.escape(candidate_first) + r'\b',
                            header[:2000], re.IGNORECASE
                        )
                    if together:
                        surname = other_word
                        print(f"[MOJ-LEAVE] Found co-occurring surname: '{surname}' (count: {other_count})")
                        break

            return candidate_first, surname

        # If no name from labels, or as validation
        if not extracted_name:
            freq_first, freq_surname = _extract_name_by_frequency(header_text, document_text)
            if freq_first:
                if freq_surname:
                    extracted_name = f"{freq_first} {freq_surname}"
                else:
                    extracted_name = freq_first
                print(f"[MOJ-LEAVE] Extracted patient name by frequency: '{extracted_name}'")
        else:
            # Validate: check if the extracted first name actually repeats
            first_word = extracted_name.split()[0] if extracted_name else ""
            if first_word and len(first_word) >= 3 and first_word.lower() not in EXCLUDE_WORDS:
                repeat_count = len(re.findall(r'\b' + re.escape(first_word) + r'\b', document_text, re.IGNORECASE))
                if repeat_count < 2:
                    print(f"[MOJ-LEAVE] Warning: extracted first name '{first_word}' only appears {repeat_count} time(s) - trying frequency method")
                    freq_first, freq_surname = _extract_name_by_frequency(header_text, document_text)
                    if freq_first:
                        freq_name = f"{freq_first} {freq_surname}" if freq_surname else freq_first
                        print(f"[MOJ-LEAVE] Overriding with frequency-based name: '{freq_name}'")
                        extracted_name = freq_name
                else:
                    print(f"[MOJ-LEAVE] Validated: first name '{first_word}' appears {repeat_count} times")

        # ================================================================
        # EXTRACT DATE OF BIRTH
        # ================================================================
        dob_patterns = [
            # "Date of Birth:" on one line, date on next (RC reports) - text format "7 October 1979"
            r'date\s+of\s+birth\s*[:]?\s*\n\s*(\d{1,2}\s+[A-Za-z]+\s+\d{4})',
            # "Date of Birth:" or "DOB:" followed by date (same line or next line) - numeric format
            r'(?:d\.?o\.?b\.?|date\s+of\s+birth)\s*[:]\s*\n?\s*(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})',
            # "DOB:" followed by text date like "1 January 1980" (same line or next)
            r'(?:d\.?o\.?b\.?|date\s+of\s+birth)\s*[:]\s*\n?\s*(\d{1,2}\s+[A-Za-z]+\s+\d{4})',
            # "Born:" followed by date
            r'born\s*[:]\s*\n?\s*(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})',
            # "Born" followed directly by date (no colon) — Carenotes format
            r'born\s+(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})',
        ]

        extracted_dob = None
        for pattern in dob_patterns:
            match = re.search(pattern, document_text, re.IGNORECASE)
            if match:
                date_str = match.group(1).strip()
                print(f"[MOJ-LEAVE] Found DOB match: '{date_str}'")

                # Try to parse the date in various formats
                date_formats = [
                    "%d/%m/%Y", "%d-%m-%Y", "%d.%m.%Y",  # DD/MM/YYYY variants
                    "%d/%m/%y", "%d-%m-%y", "%d.%m.%y",  # DD/MM/YY variants
                    "%d %B %Y", "%d %b %Y",               # DD Month YYYY
                    "%d %B %y", "%d %b %y",               # DD Month YY
                ]

                for fmt in date_formats:
                    try:
                        parsed_date = datetime.strptime(date_str, fmt)
                        # Handle 2-digit years
                        if parsed_date.year > 2050:
                            parsed_date = parsed_date.replace(year=parsed_date.year - 100)
                        extracted_dob = parsed_date
                        print(f"[MOJ-LEAVE] Parsed DOB: {extracted_dob.strftime('%d/%m/%Y')}")
                        break
                    except ValueError:
                        continue

                if extracted_dob:
                    break

        # ================================================================
        # EXTRACT NHS NUMBER
        # ================================================================
        nhs_patterns = [
            # "NHS Number:" on one line, number on next
            r'nhs\s+(?:number|no\.?)\s*[:]?\s*\n\s*(\d[\d\s]{8,12}\d)',
            # "NHS Number:" followed by number on same line
            r'nhs\s+(?:number|no\.?)\s*[:]\s*(\d[\d\s]{8,12}\d)',
            # "NHS No." followed by number — Carenotes format (no colon)
            r'nhs\s+no\.?\s+(\d[\d\s]{8,12}\d)',
            # "Hospital Number:" patterns
            r'hospital\s+(?:number|no\.?)\s*[:]?\s*\n?\s*(\d[\d\s]{6,15})',
        ]

        extracted_nhs = None
        for pattern in nhs_patterns:
            match = re.search(pattern, document_text, re.IGNORECASE)
            if match:
                nhs = match.group(1).strip()
                # Clean up - keep spaces in NHS numbers (they're usually formatted)
                extracted_nhs = nhs
                print(f"[MOJ-LEAVE] Extracted NHS Number: '{extracted_nhs}'")
                break

        # ================================================================
        # EXTRACT HOSPITAL AND WARD (from "Usual Place of Residence")
        # ================================================================
        residence_patterns = [
            # "Usual Place of Residence:" on one line, location on next
            r'usual\s+place\s+of\s+residence\s*[:]?\s*\n\s*(.+?)(?=\n|$)',
            # "Hospital:" followed by name
            r'hospital\s*[:]\s*\n?\s*([A-Za-z][A-Za-z\s\-\']+?)(?=\n|$)',
            # "Ward:" followed by name
            r'ward\s*[:]\s*\n?\s*([A-Za-z][A-Za-z\s\-\']+?)(?=\n|$)',
            # "Location:" followed by name
            r'location\s*[:]\s*\n?\s*([A-Za-z][A-Za-z\s\-\']+?)(?=\n|$)',
        ]

        extracted_ward = None
        extracted_hospital = None
        for pattern in residence_patterns:
            match = re.search(pattern, document_text, re.IGNORECASE)
            if match:
                location = match.group(1).strip()
                print(f"[MOJ-LEAVE] Found location: '{location}'")

                # Try to split into ward and hospital
                # Common patterns: "Onyx Ward Brooklands Hospital", "Ward Name, Hospital Name"
                # Look for "Ward" keyword to split
                ward_match = re.match(r'([A-Za-z\s\-\']+\s+Ward)\s+(.+)', location, re.IGNORECASE)
                if ward_match:
                    extracted_ward = ward_match.group(1).strip()
                    extracted_hospital = ward_match.group(2).strip()
                    print(f"[MOJ-LEAVE] Split into Ward: '{extracted_ward}', Hospital: '{extracted_hospital}'")
                else:
                    # Check if it contains "Hospital" - put it in hospital field
                    if 'hospital' in location.lower():
                        extracted_hospital = location
                    else:
                        # Just use as ward
                        extracted_ward = location
                break

        # ================================================================
        # EXTRACT MHA SECTION
        # ================================================================
        mha_patterns = [
            # "Mental Health Act Status:" on one line, section on next
            r'mental\s+health\s+act\s+(?:status|section)\s*[:]?\s*\n\s*(S?\d+[\/\-]?\d*[A-Za-z]?)',
            # "MHA Section:" or "Section:" followed by section code
            r'(?:mha\s+)?section\s*[:]\s*\n?\s*(S?\d+[\/\-]?\d*[A-Za-z]?)',
            # Direct pattern for common sections
            r'\b(S?37[\/\-]41|S?47[\/\-]49|S?48[\/\-]49|S?45A)\b',
        ]

        extracted_mha = None
        for pattern in mha_patterns:
            match = re.search(pattern, document_text, re.IGNORECASE)
            if match:
                mha = match.group(1).strip()
                # Normalize: remove leading S, use /
                mha = re.sub(r'^S', '', mha)
                mha = mha.replace('-', '/')
                extracted_mha = mha
                print(f"[MOJ-LEAVE] Extracted MHA Section: '{extracted_mha}'")
                break

        # ================================================================
        # EXTRACT GENDER (comprehensive detection)
        # ================================================================
        extracted_gender = None
        doc_text_for_gender = document_text  # Preserve case for some checks
        doc_lower_gender = document_text.lower()

        # 1. HIGHEST PRIORITY: Explicit "Female" or "Male" words
        #    This catches headers like "...40 years)FemaleNHS..." or "Gender: Female"
        #    Use lookahead/lookbehind to allow "FemaleNHS" pattern (no space needed after)
        if re.search(r'(?<![a-zA-Z])Female(?![a-z])', doc_text_for_gender):
            extracted_gender = "Female"
            print(f"[MOJ-LEAVE] Detected explicit 'Female' in document")
        elif re.search(r'(?<![a-zA-Z])Male(?![a-z])', doc_text_for_gender):
            # Make sure we don't match "Female" as containing "Male"
            if not re.search(r'(?<![a-zA-Z])Female(?![a-z])', doc_text_for_gender):
                extracted_gender = "Male"
                print(f"[MOJ-LEAVE] Detected explicit 'Male' in document")

        # 2. Check for titles in parentheses like "(Miss)", "(Mrs)", "(Ms)", "(Mr)"
        if not extracted_gender:
            if re.search(r'\(\s*(?:Miss|Mrs|Ms)\s*\)', doc_text_for_gender, re.IGNORECASE):
                extracted_gender = "Female"
                print(f"[MOJ-LEAVE] Detected female title in parentheses")
            elif re.search(r'\(\s*Mr\s*\)', doc_text_for_gender, re.IGNORECASE):
                extracted_gender = "Male"
                print(f"[MOJ-LEAVE] Detected male title in parentheses")

        # 3. Check for titles followed by names: "Mr Smith", "Miss Jones"
        if not extracted_gender:
            if re.search(r'\bMr\.?\s+[A-Z]', doc_text_for_gender):
                extracted_gender = "Male"
                print(f"[MOJ-LEAVE] Inferred gender from 'Mr' title")
            elif re.search(r'\b(?:Mrs|Ms|Miss)\.?\s+[A-Z]', doc_text_for_gender):
                extracted_gender = "Female"
                print(f"[MOJ-LEAVE] Inferred gender from female title")

        # 4. Check for gender/sex labels in forms
        if not extracted_gender:
            gender_match = re.search(r'(?:gender|sex)\s*[:]\s*\n?\s*(male|female|m|f)\b', doc_lower_gender)
            if gender_match:
                g = gender_match.group(1).lower()
                extracted_gender = "Male" if g in ('male', 'm') else "Female"
                print(f"[MOJ-LEAVE] Extracted gender from label: {extracted_gender}")

        # 5. Count gendered pronouns in clinical text to infer gender
        if not extracted_gender:
            # Count female pronouns (she/her/herself)
            female_pronouns = len(re.findall(r'\b(?:she|her|herself)\b', doc_lower_gender))
            # Count male pronouns (he/him/himself) - but not "the"
            male_pronouns = len(re.findall(r'\b(?:he|him|himself)\b', doc_lower_gender))

            # Need clear majority (2:1 ratio) to infer gender from pronouns
            if female_pronouns > male_pronouns * 2 and female_pronouns >= 5:
                extracted_gender = "Female"
                print(f"[MOJ-LEAVE] Inferred Female from pronouns (she/her: {female_pronouns}, he/him: {male_pronouns})")
            elif male_pronouns > female_pronouns * 2 and male_pronouns >= 5:
                extracted_gender = "Male"
                print(f"[MOJ-LEAVE] Inferred Male from pronouns (he/him: {male_pronouns}, she/her: {female_pronouns})")

        # ================================================================
        # EXTRACT AGE (from pattern or calculate from DOB)
        # ================================================================
        extracted_age = None
        age_patterns = [
            r"(?:AGE)[:\s]*(\d{1,3})\s*(?:years?|yrs?|y\.?o\.?)?\b",
            r"\b(\d{1,3})\s*(?:year|yr)\s*old\b",
            r"\b(\d{1,3})\s*y\.?o\.?\b",
            r"\baged?\s*(\d{1,3})\b",
            r'\(\s*(\d{1,3})\s*years?\s*\)',  # "(40 years)" pattern common in headers
        ]
        for pattern in age_patterns:
            match = re.search(pattern, document_text, re.IGNORECASE)
            if match:
                age_val = int(match.group(1))
                if 0 < age_val < 120:
                    extracted_age = age_val
                    print(f"[MOJ-LEAVE] Extracted age from pattern: {extracted_age}")
                    break

        # Calculate age from DOB if not found explicitly
        if not extracted_age and extracted_dob:
            today = datetime.today()
            age = today.year - extracted_dob.year - ((today.month, today.day) < (extracted_dob.month, extracted_dob.day))
            if 0 < age < 120:
                extracted_age = age
                print(f"[MOJ-LEAVE] Calculated age from DOB: {extracted_age}")

        # ================================================================
        # EXTRACT ETHNICITY
        # ================================================================
        extracted_ethnicity = None
        ethnicity_patterns = [
            r"(?:ETHNICITY|ETHNIC\s*(?:GROUP|ORIGIN)?)[:\s]+([A-Za-z][A-Za-z\s\-\/]+?)(?:\n|$|,)",
            r"\b(White\s*(?:British|Irish|European|Other)?)\b",
            r"\b(Black\s*(?:British|African|Caribbean|Other)?)\b",
            r"\b(Asian\s*(?:British|Indian|Pakistani|Bangladeshi|Chinese|Other)?)\b",
            r"\b(Mixed\s*(?:White\s*(?:and|&)\s*(?:Black\s*(?:Caribbean|African)|Asian))?)\b",
        ]
        for pattern in ethnicity_patterns:
            match = re.search(pattern, document_text, re.IGNORECASE)
            if match:
                ethnicity_val = match.group(1).strip()
                if len(ethnicity_val) > 2:
                    extracted_ethnicity = ethnicity_val.title()
                    print(f"[MOJ-LEAVE] Extracted ethnicity: {extracted_ethnicity}")
                    break

        # ================================================================
        # EXTRACT DIAGNOSES (match to ICD-10)
        # ================================================================
        extracted_diagnoses = []
        doc_lower = document_text.lower()
        matched_categories = set()  # Track matched categories to prevent duplicates

        def find_icd10_entry(search_term, course_preference="continuous"):
            """Find ICD-10 entry, preferring specified course type."""
            search_lower = search_term.lower()
            best_match = None
            preferred_match = None

            for diag_name, meta in ICD10_DICT.items():
                diag_lower = diag_name.lower()
                if search_lower in diag_lower:
                    icd_code = meta.get("icd10", "") if isinstance(meta, dict) else ""
                    display = f"{diag_name} ({icd_code})" if icd_code else diag_name

                    # Check for preferred course type
                    if course_preference == "continuous" and "continuous" in diag_lower:
                        preferred_match = display
                        break
                    elif course_preference == "remission" and "remission" in diag_lower:
                        preferred_match = display
                        break
                    elif best_match is None:
                        best_match = display

            return preferred_match or best_match

        # Check for late autism diagnosis indicators
        late_autism_indicators = [
            "late diagnos", "recently diagnos", "adult diagnos", "diagnosed as an adult",
            "diagnosed in adult", "diagnosed late", "diagnosis was made in", "diagnosed at age",
            "diagnosed aged", "diagnosed when he was", "diagnosed when she was"
        ]
        is_late_autism = any(indicator in doc_lower for indicator in late_autism_indicators)

        # Also check for autism diagnosis date - if diagnosed as adult (age 18+), it's atypical
        if not is_late_autism and extracted_dob:
            # Look for "diagnosed with autism in [month] [year]" or "autism... diagnosed in [year]"
            autism_diag_match = re.search(
                r'(?:diagnosed\s+with\s+autism|autism.*?diagnos\w*)\s+(?:in\s+)?'
                r'(?:(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+)?(\d{4})',
                doc_lower
            )
            if autism_diag_match:
                diag_year = int(autism_diag_match.group(1))
                birth_year = extracted_dob.year
                age_at_diagnosis = diag_year - birth_year
                print(f"[MOJ-LEAVE] Autism diagnosed in {diag_year}, patient born {birth_year}, age at diagnosis: ~{age_at_diagnosis}")
                if age_at_diagnosis >= 18:
                    is_late_autism = True
                    print(f"[MOJ-LEAVE] Late autism diagnosis detected (age {age_at_diagnosis} >= 18)")

        # Check for schizophrenia course indicators
        def get_schizophrenia_course():
            if "complete remission" in doc_lower or "in remission" in doc_lower:
                return "remission"
            elif "episodic" in doc_lower:
                return "episodic"
            else:
                return "continuous"  # Default to continuous

        schizo_course = get_schizophrenia_course()

        # Diagnosis patterns with category tracking
        DIAGNOSIS_PATTERNS = [
            # Schizophrenia variants (category: schizophrenia)
            (r'paranoid\s+schizophrenia', 'Paranoid schizophrenia', 'schizophrenia'),
            (r'catatonic\s+schizophrenia', 'Catatonic schizophrenia', 'schizophrenia'),
            (r'hebephrenic\s+schizophrenia', 'Hebephrenic schizophrenia', 'schizophrenia'),
            (r'residual\s+schizophrenia', 'Residual schizophrenia', 'schizophrenia'),
            (r'simple\s+schizophrenia', 'Simple schizophrenia', 'schizophrenia'),
            (r'undifferentiated\s+schizophrenia', 'Undifferentiated schizophrenia', 'schizophrenia'),
            (r'schizoaffective', 'Schizoaffective disorder', 'schizoaffective'),
            (r'schizophrenia', 'Schizophrenia, unspecified', 'schizophrenia'),
            # Autism (category: autism) - check late diagnosis
            (r'autism\s+spectrum\s+disorder', None, 'autism'),  # Will be resolved dynamically
            (r'autistic\s+spectrum', None, 'autism'),
            (r'asd\b', None, 'autism'),
            (r'asperger', 'Asperger', 'autism'),
            (r'atypical\s+autism', 'Atypical autism', 'autism'),
            # Mood disorders
            (r'bipolar\s+affective\s+disorder', 'Bipolar affective disorder', 'bipolar'),
            (r'bipolar\s+disorder', 'Bipolar affective disorder', 'bipolar'),
            (r'manic\s+depressi', 'Bipolar affective disorder', 'bipolar'),
            (r'recurrent\s+depressi', 'Recurrent depressive disorder', 'depression'),
            (r'major\s+depressi', 'Depressive episode', 'depression'),
            (r'depressi(?:ve|on)', 'Depressive episode', 'depression'),
            # Personality disorders
            (r'emotionally\s+unstable\s+personality', 'Emotionally unstable personality disorder', 'personality'),
            (r'borderline\s+personality', 'Emotionally unstable personality disorder', 'personality'),
            (r'antisocial\s+personality', 'Dissocial personality disorder', 'personality'),
            (r'dissocial\s+personality', 'Dissocial personality disorder', 'personality'),
            (r'narcissistic\s+personality', 'Other specific personality disorders', 'personality'),
            (r'paranoid\s+personality', 'Paranoid personality disorder', 'personality'),
            (r'personality\s+disorder', 'Personality disorder', 'personality'),
            # Anxiety
            (r'generalised\s+anxiety', 'Generalized anxiety disorder', 'anxiety'),
            (r'generalized\s+anxiety', 'Generalized anxiety disorder', 'anxiety'),
            (r'ptsd', 'Post-traumatic stress disorder', 'ptsd'),
            (r'post[- ]?traumatic\s+stress', 'Post-traumatic stress disorder', 'ptsd'),
            # Psychosis
            (r'acute.*psycho(?:tic|sis)', 'Acute and transient psychotic disorders', 'psychosis'),
            # Learning disability
            (r'learning\s+disabilit', 'Mental retardation', 'learning'),
            (r'intellectual\s+disabilit', 'Mental retardation', 'learning'),
            # Substance
            (r'alcohol\s+dependence', 'Alcohol dependence syndrome', 'alcohol'),
            (r'drug\s+dependence', 'Drug dependence', 'drugs'),
            (r'opioid\s+dependence', 'Opioid dependence', 'drugs'),
        ]

        if ICD10_DICT:
            for pattern, search_term, category in DIAGNOSIS_PATTERNS:
                # Skip if we've already matched this category
                if category in matched_categories:
                    continue

                if re.search(pattern, doc_lower):
                    # Handle autism specially - check for late diagnosis
                    if category == 'autism' and search_term is None:
                        if is_late_autism:
                            search_term = 'Atypical autism'
                            print(f"[MOJ-LEAVE] Late autism diagnosis detected -> Atypical autism")
                        else:
                            search_term = 'Childhood autism'

                    # Handle schizophrenia - use appropriate course
                    if category == 'schizophrenia':
                        display = find_icd10_entry(search_term, schizo_course)
                        print(f"[MOJ-LEAVE] Schizophrenia with course '{schizo_course}' -> {display}")
                    else:
                        display = find_icd10_entry(search_term)

                    if display and display not in extracted_diagnoses:
                        extracted_diagnoses.append(display)
                        matched_categories.add(category)
                        print(f"[MOJ-LEAVE] Matched diagnosis: '{pattern}' -> '{display}'")

                    # Limit to 3 diagnoses
                    if len(extracted_diagnoses) >= 3:
                        break

        print(f"[MOJ-LEAVE] Extracted {len(extracted_diagnoses)} diagnoses")

        # ================================================================
        # EXTRACT EXACERBATING FACTORS FROM INDEX OFFENCE
        # ================================================================
        extracted_factors = ["Non-compliance"]  # Default
        extracted_phys_health_condition = None  # Track which physical health condition was found

        # Keywords for each factor - must be found near "index offence" context
        # Removed overly broad terms: "illness", "relative", "family"
        FACTOR_KEYWORDS = {
            "Alcohol": [
                "alcohol", "drunk", "intoxicat", "beer", "wine", "vodka",
                "whisky", "whiskey", "lager", "spirits"
            ],
            "Substance misuse": [
                "cannabis", "cocaine", "heroin", "amphetamine", "meth",
                "spice", "crack", "ecstasy", "mdma", "ketamine", "lsd"
            ],
            "Use of weapons": [
                "knife", "knives", "weapon", "blade", "stabbed", "stabbing",
                "gun", "firearm", "hammer", "bat", "machete", "sword", "axe",
                "screwdriver", "bottle", "brick", "armed"
            ],
            "Financial": [
                "money", "debt", "financial", "steal", "stole", "theft", "robbery",
                "burglary", "fraud", "benefit", "homeless", "evict"
            ],
            "Personal relationships": [
                "partner", "girlfriend", "boyfriend", "wife", "husband", "ex-",
                "relationship", "affair", "jealous", "domestic", "intimate",
                "dating", "broke up", "split"
            ],
            "Family stress": [
                # Specific family members only - no general terms like "relative" or "family"
                "mother", "father", "parent", "sibling", "brother", "sister",
                "child", "son", "daughter", "uncle", "aunt", "cousin", "grandparent",
                "grandmother", "grandfather", "stepfather", "stepmother"
            ],
            "Physical health": [
                # Specific conditions only - no general terms like "illness"
                "diabetes", "epilepsy", "seizure", "cancer", "heart disease",
                "stroke", "asthma", "copd", "arthritis", "chronic pain",
                "disabled", "wheelchair", "amputation", "brain injury"
            ],
        }

        # Get patient name for exclusion (don't match family keywords in patient's own name)
        patient_name_lower = (extracted_name or "").lower()

        # Split document into sections/blocks (by double newlines or section markers)
        # This prevents matching across unrelated sections
        section_separators = r'(?:\n\s*\n|\n={3,}|\n-{3,}|\n\*{3,})'
        text_blocks = re.split(section_separators, doc_lower)

        print(f"\n[MOJ-LEAVE] === FACTOR DETECTION DEBUG ===")
        print(f"[MOJ-LEAVE] Searching in: {', '.join(source_info) if source_info else 'combined document text'}")
        print(f"[MOJ-LEAVE] Text length: {len(doc_lower)} chars, split into {len(text_blocks)} blocks")

        # Find blocks that contain "index offence" (or variations)
        index_offence_patterns = [
            r'index\s+offen[cs]e',
            r'index\s+incident',
            r'presenting\s+offen[cs]e',
            r'current\s+offen[cs]e'
        ]

        relevant_blocks = []
        for block in text_blocks:
            for io_pattern in index_offence_patterns:
                if re.search(io_pattern, block):
                    relevant_blocks.append(block)
                    break

        if not relevant_blocks:
            print(f"[MOJ-LEAVE] No 'index offence' context found - skipping factor detection")
        else:
            print(f"[MOJ-LEAVE] Found {len(relevant_blocks)} block(s) containing 'index offence'")

            for factor, keywords in FACTOR_KEYWORDS.items():
                if factor in extracted_factors:
                    continue  # Already added

                factor_found = False
                for block in relevant_blocks:
                    if factor_found:
                        break

                    # Find all occurrences of "index offence" in this block
                    for io_pattern in index_offence_patterns:
                        for io_match in re.finditer(io_pattern, block):
                            if factor_found:
                                break

                            # Get 100 words before and after "index offence"
                            io_start = io_match.start()
                            io_end = io_match.end()

                            # Extract surrounding text (approx 100 words = ~600 chars)
                            context_start = max(0, io_start - 600)
                            context_end = min(len(block), io_end + 600)
                            context_text = block[context_start:context_end]

                            # Search for factor keywords within this context
                            for keyword in keywords:
                                pattern = rf'\b{re.escape(keyword)}'
                                kw_match = re.search(pattern, context_text)
                                if kw_match:
                                    # For family keywords, skip if it's the patient's name
                                    if factor == "Family stress":
                                        if patient_name_lower and keyword in patient_name_lower:
                                            print(f"[MOJ-LEAVE] SKIPPED '{factor}' - keyword '{keyword}' is in patient name")
                                            continue

                                    # Get display context (80 chars around keyword)
                                    kw_pos = kw_match.start()
                                    display_start = max(0, kw_pos - 80)
                                    display_end = min(len(context_text), kw_match.end() + 80)
                                    display_context = context_text[display_start:display_end].replace('\n', ' ').strip()

                                    extracted_factors.append(factor)
                                    print(f"[MOJ-LEAVE] FACTOR: '{factor}'")
                                    print(f"[MOJ-LEAVE]   Keyword: '{keyword}'")
                                    print(f"[MOJ-LEAVE]   Near: 'index offence' (within ~100 words)")
                                    print(f"[MOJ-LEAVE]   Context: ...{display_context}...")

                                    # Track physical health condition specifically
                                    if factor == "Physical health":
                                        extracted_phys_health_condition = keyword
                                        print(f"[MOJ-LEAVE]   Physical health condition: '{keyword}'")

                                    factor_found = True
                                    break

        print(f"[MOJ-LEAVE] === FINAL FACTORS (excluding default Non-compliance): {[f for f in extracted_factors if f != 'Non-compliance']} ===")

        # ================================================================
        # EXTRACT MENTAL STATE & INSIGHT FROM NOTES/REPORTS
        # ================================================================
        # Mental state options: 0=Stable, 1=Minor, 2=Moderate, 3=Significant, 4=Severe
        # Insight options: 0=Nil, 1=Some, 2=Partial, 3=Moderate, 4=Good, 5=Full

        extracted_mental_state = None
        extracted_insight = None
        mental_state_findings = []

        # Determine if this is notes or a report
        is_notes = False
        is_report = False
        report_types = [info.split('(')[-1].rstrip(')') for info in source_info]
        for rt in report_types:
            rt_lower = rt.lower()
            if 'note' in rt_lower or rt_lower == 'unknown':
                is_notes = True
            if 'report' in rt_lower or 'rc' in rt_lower:
                is_report = True

        print(f"\n[MOJ-LEAVE] === MENTAL STATE/INSIGHT EXTRACTION DEBUG ===")
        print(f"[MOJ-LEAVE] Source types: notes={is_notes}, report={is_report}")

        # Keywords for mental state assessment
        STABLE_KEYWORDS = [
            "settled", "stable", "well", "euthymic", "calm", "relaxed",
            "no concerns", "doing well", "mental state normal", "mse normal",
            "unremarkable", "no symptoms", "symptom free", "asymptomatic"
        ]
        UNSTABLE_KEYWORDS = [
            "not settled", "unsettled", "unstable", "not stable", "disturbed",
            "agitated", "distressed", "anxious", "paranoid", "psychotic",
            "delusional", "hallucinating", "hearing voices", "thought disorder",
            "disorganised", "deteriorat", "relaps", "declin"
        ]
        MODERATE_KEYWORDS = [
            "some symptoms", "minor symptoms", "occasional", "intermittent",
            "fluctuating", "variable", "improving", "residual symptoms"
        ]

        # Keywords for insight assessment
        GOOD_INSIGHT_KEYWORDS = [
            "good insight", "full insight", "excellent insight", "accepts diagnosis",
            "understands illness", "recognises need", "medication compliant",
            "engages well", "acknowledges", "aware of illness"
        ]
        POOR_INSIGHT_KEYWORDS = [
            "no insight", "nil insight", "lacks insight", "poor insight",
            "denies illness", "refuses medication", "does not accept",
            "does not believe", "limited insight", "minimal insight"
        ]
        PARTIAL_INSIGHT_KEYWORDS = [
            "partial insight", "some insight", "developing insight",
            "variable insight", "inconsistent", "ambivalent"
        ]

        if is_notes:
            # For notes: search last 1 year of entries
            from datetime import datetime, timedelta
            one_year_ago = datetime.now() - timedelta(days=365)

            notes = getattr(self._data_extractor, 'notes', [])
            if not notes and hasattr(self._data_extractor, '_raw_notes'):
                notes = self._data_extractor._raw_notes

            recent_notes = []
            for note in notes:
                note_date = note.get("date")
                if note_date:
                    if isinstance(note_date, datetime):
                        if note_date >= one_year_ago:
                            recent_notes.append(note)
                    else:
                        # If no date filtering possible, include all
                        recent_notes.append(note)
                else:
                    recent_notes.append(note)

            print(f"[MOJ-LEAVE] Notes: {len(notes)} total, {len(recent_notes)} from last year")

            # Count stability indicators across recent notes
            stable_count = 0
            unstable_count = 0
            moderate_count = 0
            good_insight_count = 0
            poor_insight_count = 0
            partial_insight_count = 0

            for note in recent_notes:
                text = (note.get("text", "") or note.get("body", "") or note.get("content", "")).lower()
                note_date = note.get("date", "unknown")

                # Check mental state keywords
                for kw in STABLE_KEYWORDS:
                    if kw in text:
                        stable_count += 1
                        mental_state_findings.append(f"STABLE: '{kw}' found (date: {note_date})")
                        break

                for kw in UNSTABLE_KEYWORDS:
                    if kw in text:
                        unstable_count += 1
                        mental_state_findings.append(f"UNSTABLE: '{kw}' found (date: {note_date})")
                        break

                for kw in MODERATE_KEYWORDS:
                    if kw in text:
                        moderate_count += 1
                        mental_state_findings.append(f"MODERATE: '{kw}' found (date: {note_date})")
                        break

                # Check insight keywords
                for kw in GOOD_INSIGHT_KEYWORDS:
                    if kw in text:
                        good_insight_count += 1
                        break
                for kw in POOR_INSIGHT_KEYWORDS:
                    if kw in text:
                        poor_insight_count += 1
                        break
                for kw in PARTIAL_INSIGHT_KEYWORDS:
                    if kw in text:
                        partial_insight_count += 1
                        break

            # Determine mental state slider position based on counts
            print(f"[MOJ-LEAVE] Mental state counts: stable={stable_count}, moderate={moderate_count}, unstable={unstable_count}")

            if unstable_count > stable_count and unstable_count > moderate_count:
                # More unstable findings
                if unstable_count > 3:
                    extracted_mental_state = 4  # Severe
                else:
                    extracted_mental_state = 3  # Significant
            elif moderate_count > stable_count:
                extracted_mental_state = 2  # Moderate
            elif stable_count > unstable_count:
                if moderate_count > 0:
                    extracted_mental_state = 1  # Minor
                else:
                    extracted_mental_state = 0  # Stable
            elif stable_count > 0 or moderate_count > 0 or unstable_count > 0:
                extracted_mental_state = 2  # Default to moderate if mixed

            # Determine insight slider position
            print(f"[MOJ-LEAVE] Insight counts: good={good_insight_count}, partial={partial_insight_count}, poor={poor_insight_count}")

            if good_insight_count > poor_insight_count and good_insight_count > partial_insight_count:
                extracted_insight = 4 if good_insight_count > 2 else 4  # Good
            elif poor_insight_count > good_insight_count:
                extracted_insight = 1 if poor_insight_count > 2 else 1  # Some
            elif partial_insight_count > 0:
                extracted_insight = 2  # Partial
            elif good_insight_count > 0:
                extracted_insight = 3  # Moderate

        if is_report:
            # For reports: search "current progress" section
            # Find section containing "progress" or "current mental state"
            progress_patterns = [
                r'(?:current\s+)?progress[:\s]',
                r'current\s+mental\s+state',
                r'mental\s+state\s+examination',
                r'mse[:\s]',
                r'psychiatric\s+review'
            ]

            progress_text = ""
            for pattern in progress_patterns:
                match = re.search(pattern, doc_lower)
                if match:
                    # Extract ~1000 chars after the match
                    start = match.start()
                    end = min(len(doc_lower), start + 1000)
                    progress_text = doc_lower[start:end]
                    print(f"[MOJ-LEAVE] Found progress section (pattern: '{pattern}')")
                    break

            if progress_text:
                # Search for stability indicators in progress text
                stable_found = False
                unstable_found = False
                moderate_found = False

                for kw in STABLE_KEYWORDS:
                    if kw in progress_text:
                        stable_found = True
                        mental_state_findings.append(f"REPORT STABLE: '{kw}' in progress section")
                        break

                for kw in UNSTABLE_KEYWORDS:
                    if kw in progress_text:
                        unstable_found = True
                        mental_state_findings.append(f"REPORT UNSTABLE: '{kw}' in progress section")
                        break

                for kw in MODERATE_KEYWORDS:
                    if kw in progress_text:
                        moderate_found = True
                        mental_state_findings.append(f"REPORT MODERATE: '{kw}' in progress section")
                        break

                # Determine slider position
                if unstable_found:
                    extracted_mental_state = 3  # Significant
                elif moderate_found:
                    extracted_mental_state = 2  # Moderate
                elif stable_found:
                    extracted_mental_state = 0  # Stable

                # Search for insight in progress text
                for kw in GOOD_INSIGHT_KEYWORDS:
                    if kw in progress_text:
                        extracted_insight = 4  # Good
                        break
                for kw in POOR_INSIGHT_KEYWORDS:
                    if kw in progress_text:
                        extracted_insight = 1  # Some
                        break
                for kw in PARTIAL_INSIGHT_KEYWORDS:
                    if kw in progress_text:
                        extracted_insight = 2  # Partial
                        break

        # Log findings
        if mental_state_findings:
            print(f"[MOJ-LEAVE] Mental state findings:")
            for finding in mental_state_findings[:10]:  # Limit to first 10
                print(f"[MOJ-LEAVE]   {finding}")

        print(f"[MOJ-LEAVE] Extracted mental state: {extracted_mental_state} (0=Stable to 4=Severe)")
        print(f"[MOJ-LEAVE] Extracted insight: {extracted_insight} (0=Nil to 5=Full)")

        # ================================================================
        # EXTRACT OBSERVATION LEVEL (from report or last week of notes)
        # ================================================================
        extracted_observation = "General"  # Default to General if not found

        # Keywords for observation levels
        OBSERVATION_PATTERNS = {
            "4:1": [r'4\s*:\s*1', r'four\s+to\s+one'],
            "3:1": [r'3\s*:\s*1', r'three\s+to\s+one'],
            "2:1": [r'2\s*:\s*1', r'two\s+to\s+one'],
            "1:1 arms length": [r'1\s*:\s*1\s*arms?\s*length', r'one\s+to\s+one\s+arms?\s*length'],
            "1:1 eyesight": [r'1\s*:\s*1\s*(?:eye\s*sight|within\s*sight)', r'one\s+to\s+one\s+(?:eye\s*sight|within\s*sight)', r'1\s*:\s*1(?!\s*arms)'],
            "4x/hour": [r'4\s*(?:x|times?)\s*/?\s*(?:per\s+)?hour', r'every\s+15\s*min'],
            "3x/hour": [r'3\s*(?:x|times?)\s*/?\s*(?:per\s+)?hour', r'every\s+20\s*min'],
            "2x/hour": [r'2\s*(?:x|times?)\s*/?\s*(?:per\s+)?hour', r'every\s+30\s*min', r'half\s*hourly'],
            "Hourly": [r'hourly', r'every\s+(?:1\s+)?hour'],
            "2 hourly": [r'2\s*hourly', r'every\s+2\s+hours?', r'two\s+hourly'],
            "3 hourly": [r'3\s*hourly', r'every\s+3\s+hours?', r'three\s+hourly'],
            "Twice/day & night": [r'twice\s*/?\s*(?:per\s+)?(?:day|daily)', r'bd\s+obs', r'2\s*x\s*daily'],
            "Once/day & night": [r'once\s*/?\s*(?:per\s+)?(?:day|daily)', r'daily\s+obs', r'od\s+obs'],
            "General": [r'general\s+obs', r'general\s+observation'],
        }

        print(f"\n[MOJ-LEAVE] === OBSERVATION LEVEL EXTRACTION DEBUG ===")

        obs_search_text = ""
        if is_report:
            # Search in report for observation level
            obs_section_patterns = [
                r'observation[s]?\s*(?:level)?[:\s]',
                r'current\s+observation',
                r'obs\s+level',
            ]
            for pattern in obs_section_patterns:
                match = re.search(pattern, doc_lower)
                if match:
                    start = max(0, match.start() - 50)
                    end = min(len(doc_lower), match.end() + 200)
                    obs_search_text = doc_lower[start:end]
                    print(f"[MOJ-LEAVE] Found observation section in report")
                    break
            if not obs_search_text:
                # Search whole report
                obs_search_text = doc_lower

        if is_notes or not obs_search_text:
            # For notes: search last week of entries
            from datetime import datetime, timedelta
            one_week_ago = datetime.now() - timedelta(days=7)

            notes = getattr(self._data_extractor, 'notes', [])
            if not notes and hasattr(self._data_extractor, '_raw_notes'):
                notes = self._data_extractor._raw_notes

            recent_week_notes = []
            for note in notes:
                note_date = note.get("date")
                if note_date:
                    if isinstance(note_date, datetime):
                        if note_date >= one_week_ago:
                            recent_week_notes.append(note)
                    else:
                        recent_week_notes.append(note)
                else:
                    recent_week_notes.append(note)

            print(f"[MOJ-LEAVE] Searching {len(recent_week_notes)} notes from last week for observation level")

            for note in recent_week_notes:
                text = (note.get("text", "") or note.get("body", "") or note.get("content", "")).lower()
                obs_search_text += text + " "

        # Search for observation level patterns (check more specific patterns first)
        obs_found = False
        for obs_level, patterns in OBSERVATION_PATTERNS.items():
            if obs_found:
                break
            for pattern in patterns:
                if re.search(pattern, obs_search_text):
                    extracted_observation = obs_level
                    print(f"[MOJ-LEAVE] Found observation level: '{obs_level}' (pattern: '{pattern}')")
                    obs_found = True
                    break

        if not obs_found:
            print(f"[MOJ-LEAVE] No observation level found, defaulting to 'General'")

        # ================================================================
        # TRACK PHYSICAL HEALTH FOR IMPACT SLIDER
        # ================================================================
        # If Physical health factor was found linked to index offence, set impact slider
        extracted_phys_impact = None
        if "Physical health" in extracted_factors:
            extracted_phys_impact = 3  # Moderate (middle of scale)
            condition_msg = f" (condition: '{extracted_phys_health_condition}')" if extracted_phys_health_condition else ""
            print(f"[MOJ-LEAVE] Physical health factor found{condition_msg} - setting impact slider to Moderate (3)")

        # ================================================================
        # EXTRACT 4d ATTITUDE & BEHAVIOUR
        # ================================================================
        print(f"\n[MOJ-LEAVE] === 4d ATTITUDE & BEHAVIOUR EXTRACTION DEBUG ===")

        extracted_attitude = {
            "ward_rules": None,  # Compliant, Mostly compliant, Partially compliant, Non-compliant
            "conflict": None,  # Avoids, De-escalates, Neutral, Escalates, Aggressive
            "staff_relationship": None,  # 0-4: Limited, Some, Good, Close, Very good
            "peers_relationship": None,
            "ot_engagement": None,  # 0-5: Limited, Mixed, Reasonable, Good, Very Good, Excellent
            "psych_engagement": None,
            # Behaviour items (True=Yes, False=No, None=unset)
            "verbal_physical": None,
            "substance_abuse": None,
            "self_harm": None,
            "fire_setting": None,
            "intimidation": None,
            "secretive": None,
            "subversive": None,
            "sexually_disinhibited": None,
            "extremist": None,
            "seclusion": None,
            # Understanding/compliance
            "understanding": None,  # good, fair, poor
            "compliance": None,  # full, reasonable, partial, nil
        }

        # Track evidence for each finding (for imported data section)
        attitude_evidence = []  # List of {"category": str, "field": str, "value": str, "evidence": str, "keyword": str}

        def get_evidence_context(text, keyword, chars_before=60, chars_after=60):
            """Get context around a keyword match for evidence."""
            idx = text.find(keyword)
            if idx == -1:
                return ""
            start = max(0, idx - chars_before)
            end = min(len(text), idx + len(keyword) + chars_after)
            context = text[start:end].replace('\n', ' ').strip()
            return f"...{context}..."

        def is_historical_context(text, keyword):
            """Check if the keyword appears in a historical context (old date nearby)."""
            from datetime import datetime
            import re

            # Get wider context around keyword (200 chars each side)
            idx = text.find(keyword)
            if idx == -1:
                return False
            start = max(0, idx - 200)
            end = min(len(text), idx + len(keyword) + 200)
            context = text[start:end]

            # Current year for comparison
            current_year = datetime.now().year
            cutoff_year = current_year - 1  # Anything older than last year is historical

            # Look for year patterns in the context
            year_patterns = [
                r'\b(19\d{2})\b',  # 1900s
                r'\b(20[0-2]\d)\b',  # 2000-2029
            ]

            for pattern in year_patterns:
                matches = re.findall(pattern, context)
                for year_str in matches:
                    year = int(year_str)
                    if year < cutoff_year:
                        print(f"[MOJ-LEAVE] Historical date detected: {year} in context for '{keyword}'")
                        return True

            # Also check for date patterns like "19 jun 2006"
            date_pattern = r'\b\d{1,2}\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(19\d{2}|20[0-2]\d)\b'
            matches = re.findall(date_pattern, context, re.IGNORECASE)
            for year_str in matches:
                year = int(year_str)
                if year < cutoff_year:
                    print(f"[MOJ-LEAVE] Historical date pattern detected: {year} in context for '{keyword}'")
                    return True

            return False

        # Keywords for attitude/behaviour extraction
        WARD_RULES_KEYWORDS = {
            "Compliant": ["compliant with ward rules", "follows ward rules", "adheres to ward rules", "follows rules well"],
            "Mostly compliant": ["mostly compliant with ward", "generally compliant with ward", "usually follows ward rules"],
            "Partially compliant": ["partially compliant with ward", "sometimes compliant with ward", "inconsistent with ward rules"],
            "Non-compliant": ["non-compliant with ward rules", "not compliant with ward rules", "refuses to follow ward", "breaks ward rules", "rule-breaking on ward"],
        }

        CONFLICT_KEYWORDS = {
            "Avoids": ["avoids conflict", "conflict avoidant", "walks away from conflict"],
            "De-escalates": ["de-escalates", "deescalates", "calms situations", "diffuses conflict"],
            "Neutral": ["neutral in conflict", "does not engage"],
            "Escalates": ["escalates conflict", "escalates situations", "provokes"],
            "Aggressive": ["aggressive in conflict", "responds aggressively", "becomes aggressive"],
        }

        RELATIONSHIP_KEYWORDS = {
            "staff": {
                4: ["excellent relationship with staff", "very good relationship with staff", "strong rapport with staff"],
                3: ["close relationship with staff", "good rapport with staff"],
                2: ["good relationship with staff", "relates well to staff", "appropriate with staff"],
                1: ["some relationship with staff", "limited rapport with staff"],
                0: ["poor relationship with staff", "limited relationship with staff", "does not engage with staff"],
            },
            "peers": {
                4: ["very good relationship with peers", "excellent relationship with peers"],
                3: ["close with peers", "good friendships"],
                2: ["good relationship with peers", "relates well to peers", "friendly with peers"],
                1: ["some interaction with peers", "limited interaction"],
                0: ["poor relationship with peers", "isolates from peers", "avoids peers"],
            },
        }

        ENGAGEMENT_KEYWORDS = {
            "ot": {
                5: ["excellent engagement with ot", "excellent ot engagement", "fully engaged in ot"],
                4: ["very good ot engagement", "very good engagement with occupational"],
                3: ["good ot engagement", "good engagement with occupational", "engages well with ot"],
                2: ["reasonable ot engagement", "adequate ot engagement"],
                1: ["mixed ot engagement", "variable engagement with ot"],
                0: ["limited ot engagement", "poor ot engagement", "does not engage with ot"],
            },
            "psych": {
                5: ["excellent engagement with psychology", "excellent psychology engagement"],
                4: ["very good psychology engagement", "very good engagement with psychology"],
                3: ["good psychology engagement", "good engagement with psychology", "engages well with psychology"],
                2: ["reasonable psychology engagement", "adequate psychology engagement"],
                1: ["mixed psychology engagement", "variable engagement with psychology"],
                0: ["limited psychology engagement", "poor psychology engagement", "does not engage with psychology"],
            },
        }

        BEHAVIOUR_KEYWORDS = {
            "verbal_physical": {
                # Negative patterns - check these FIRST (no violence/aggression)
                False: [
                    "no verbal aggression", "no physical aggression", "no aggressive incidents", "no aggression",
                    "no violence", "no incidents of violence", "no episodes of violence", "nil violence",
                    "nil incidents of violence", "nil episodes of violence", "episodes of violence nil",
                    "incidents of violence nil", "violence nil", "no violent incidents", "nil violent",
                    "no violent behaviour", "nil violent behaviour", "nil aggression", "aggression nil",
                    "no incidents of aggression", "nil incidents of aggression",
                ],
                # Positive patterns - only match if no negative found
                True: [
                    "verbal aggression towards", "physical aggression towards", "aggressive incident on",
                    "assaulted staff", "assaulted peer", "hit staff", "hit peer", "was violent",
                    "there were incidents of violence", "episodes of violence have", "violence has occurred",
                    "has been aggressive", "was aggressive", "became aggressive", "displayed aggression",
                ],
            },
            "substance_abuse": {
                False: [
                    "no substance abuse", "no drug use", "negative drug tests", "abstinent",
                    "nil substance", "nil drug use", "no positive drug", "drug tests negative",
                    "no illicit", "nil illicit", "no evidence of substance",
                ],
                True: [
                    "substance abuse noted", "positive drug test", "tested positive for",
                    "used drugs on", "alcohol use on ward", "intoxicated on",
                    "found with drugs", "smuggled drugs", "illicit substance use",
                ],
            },
            "self_harm": {
                False: [
                    "no self-harm", "no self harm", "no incidents of self-harm", "no incidents of self harm",
                    "nil self-harm", "nil self harm", "self-harm nil", "self harm nil",
                    "no episodes of self-harm", "no episodes of self harm", "nil episodes of self",
                    "no self-injur", "nil self-injur", "no evidence of self-harm",
                ],
                True: [
                    "self-harmed on", "self harmed on", "incident of self-harm", "incident of self harm",
                    "self-injured on", "cut himself on", "cut herself on", "overdose on",
                    "episode of self-harm", "episode of self harm", "engaged in self-harm",
                ],
            },
            "fire_setting": {
                False: [
                    "no fire-setting", "no fire setting", "nil fire-setting", "nil fire setting",
                    "no incidents of fire", "nil incidents of fire", "fire-setting nil",
                ],
                True: [
                    "fire-setting incident", "fire setting incident", "set fire to", "started fire on",
                    "incident of fire-setting", "caught setting fire",
                ],
            },
            "intimidation": {
                False: [
                    "no intimidation", "no threats", "no threatening behaviour", "nil threats",
                    "nil intimidation", "no incidents of intimidation", "nil threatening",
                    "intimidation nil", "threats nil",
                ],
                True: [
                    "intimidation towards", "made threats to", "threatening towards",
                    "threatened staff on", "threatened peers on", "incident of intimidation",
                ],
            },
            "secretive": {
                False: [
                    "no secretive behaviour", "no manipulative behaviour", "not secretive",
                    "nil secretive", "nil manipulative", "transparent in dealings",
                    "no deceptive", "nil deceptive",
                ],
                True: [
                    "secretive behaviour noted", "manipulative behaviour noted",
                    "has been deceptive", "caught lying", "deceptive towards",
                ],
            },
            "subversive": {
                False: [
                    "no subversive behaviour", "no subversive", "nil subversive",
                    "no undermining", "nil undermining",
                ],
                True: [
                    "subversive behaviour noted", "has been subversive", "undermining staff",
                    "undermining treatment", "subversive towards",
                ],
            },
            "sexually_disinhibited": {
                False: [
                    "no sexually inappropriate", "no sexual concerns", "nil sexually inappropriate",
                    "nil sexual concerns", "no sexual disinhibition", "nil sexual disinhibition",
                ],
                True: [
                    "sexually inappropriate towards", "sexually disinhibited behaviour",
                    "sexual harassment towards", "incident of sexual", "sexually inappropriate behaviour noted",
                ],
            },
            "extremist": {
                False: [
                    "no extremist", "no radicalisation concerns", "nil extremist",
                    "nil radicalisation", "no concerns about radicalisation",
                ],
                True: [
                    "extremist behaviour noted", "extremist views expressed",
                    "radicalisation concerns raised", "expressing extremist",
                ],
            },
            "seclusion": {
                False: [
                    "no seclusion", "no periods of seclusion", "nil seclusion",
                    "seclusion nil", "no episodes of seclusion", "nil episodes of seclusion",
                ],
                True: [
                    "placed in seclusion", "period of seclusion on", "secluded on",
                    "required seclusion", "episode of seclusion",
                ],
            },
        }

        UNDERSTANDING_KEYWORDS = {
            "good": ["good understanding", "understands treatment", "good insight into treatment"],
            "fair": ["fair understanding", "some understanding", "partial understanding"],
            "poor": ["poor understanding", "limited understanding", "does not understand"],
        }

        COMPLIANCE_KEYWORDS = {
            "full": ["fully compliant with medication", "fully compliant with treatment", "full compliance with medication", "takes medication as prescribed", "takes all medication", "compliant with prescribed medication"],
            "reasonable": ["reasonably compliant with medication", "mostly compliant with medication", "generally takes medication"],
            "partial": ["partially compliant with medication", "sometimes refuses medication", "inconsistent with medication", "variable medication compliance"],
            "nil": ["non-compliant with medication", "refuses medication", "not taking medication", "refuses to take medication", "non-compliant with treatment", "refuses treatment"],
        }

        # Get text to search based on source type
        attitude_search_text = ""

        print(f"[MOJ-LEAVE] 4d source detection: is_report={is_report}, is_notes={is_notes}")

        if is_report or (not is_notes and not is_report):
            # For reports: search the WHOLE document, prioritizing relevant sections
            # Also fallback to this if source type couldn't be determined
            print(f"[MOJ-LEAVE] 4d: Searching full report document ({len(doc_lower)} chars)")

            # First try to find and prioritize relevant sections
            attitude_section_patterns = [
                r'(?:current\s+)?progress[:\s]',
                r'attitude\s+and\s+behaviour',
                r'behaviour\s+on\s+ward',
                r'ward\s+behaviour',
                r'engagement',
                r'relationships',
            ]
            sections_found = []
            for pattern in attitude_section_patterns:
                match = re.search(pattern, doc_lower)
                if match:
                    start = match.start()
                    end = min(len(doc_lower), start + 2000)
                    sections_found.append(doc_lower[start:end])
                    print(f"[MOJ-LEAVE] 4d: Found relevant section (pattern: '{pattern}')")

            # Always search the whole document for reports
            attitude_search_text = doc_lower
            print(f"[MOJ-LEAVE] 4d: Using full document text for report search")

        elif is_notes:
            # For notes: search last 12 months of entries
            from datetime import datetime, timedelta
            twelve_months_ago = datetime.now() - timedelta(days=365)

            notes = getattr(self._data_extractor, 'notes', [])
            if not notes and hasattr(self._data_extractor, '_raw_notes'):
                notes = self._data_extractor._raw_notes

            recent_12m_notes = []
            for note in notes:
                note_date = note.get("date")
                if note_date:
                    if isinstance(note_date, datetime):
                        if note_date >= twelve_months_ago:
                            recent_12m_notes.append(note)
                    else:
                        recent_12m_notes.append(note)
                else:
                    recent_12m_notes.append(note)

            print(f"[MOJ-LEAVE] 4d: Searching {len(recent_12m_notes)} notes from last 12 months")

            for note in recent_12m_notes:
                text = (note.get("text", "") or note.get("body", "") or note.get("content", "")).lower()
                attitude_search_text += text + " "

        # Ensure we have text to search
        if not attitude_search_text.strip():
            print(f"[MOJ-LEAVE] 4d: No search text available, using full doc_lower as fallback")
            attitude_search_text = doc_lower

        # Extract ward rules
        for level, keywords in WARD_RULES_KEYWORDS.items():
            for kw in keywords:
                if kw in attitude_search_text:
                    extracted_attitude["ward_rules"] = level
                    evidence = get_evidence_context(attitude_search_text, kw)
                    attitude_evidence.append({
                        "category": "Attitude",
                        "field": "Ward Rules",
                        "value": level,
                        "evidence": evidence,
                        "keyword": kw
                    })
                    print(f"[MOJ-LEAVE] 4d Ward rules: '{level}' (keyword: '{kw}')")
                    break
            if extracted_attitude["ward_rules"]:
                break

        # Extract conflict response
        for level, keywords in CONFLICT_KEYWORDS.items():
            for kw in keywords:
                if kw in attitude_search_text:
                    extracted_attitude["conflict"] = level
                    evidence = get_evidence_context(attitude_search_text, kw)
                    attitude_evidence.append({
                        "category": "Attitude",
                        "field": "Conflict Response",
                        "value": level,
                        "evidence": evidence,
                        "keyword": kw
                    })
                    print(f"[MOJ-LEAVE] 4d Conflict: '{level}' (keyword: '{kw}')")
                    break
            if extracted_attitude["conflict"]:
                break

        # Extract relationships
        rel_level_labels = ["Limited", "Some", "Good", "Close", "Very good"]
        for rel_type, levels in RELATIONSHIP_KEYWORDS.items():
            for level, keywords in sorted(levels.items(), reverse=True):
                for kw in keywords:
                    if kw in attitude_search_text:
                        extracted_attitude[f"{rel_type}_relationship"] = level
                        evidence = get_evidence_context(attitude_search_text, kw)
                        level_label = rel_level_labels[level] if 0 <= level < len(rel_level_labels) else str(level)
                        attitude_evidence.append({
                            "category": "Relationships",
                            "field": f"{rel_type.title()} Relationship",
                            "value": level_label,
                            "evidence": evidence,
                            "keyword": kw
                        })
                        print(f"[MOJ-LEAVE] 4d {rel_type.title()} relationship: {level} (keyword: '{kw}')")
                        break
                if extracted_attitude.get(f"{rel_type}_relationship") is not None:
                    break

        # Extract engagement levels
        eng_level_labels = ["Limited", "Mixed", "Reasonable", "Good", "Very Good", "Excellent"]
        for eng_type, levels in ENGAGEMENT_KEYWORDS.items():
            for level, keywords in sorted(levels.items(), reverse=True):
                for kw in keywords:
                    if kw in attitude_search_text:
                        extracted_attitude[f"{eng_type}_engagement"] = level
                        evidence = get_evidence_context(attitude_search_text, kw)
                        level_label = eng_level_labels[level] if 0 <= level < len(eng_level_labels) else str(level)
                        attitude_evidence.append({
                            "category": "Engagement",
                            "field": f"{eng_type.upper()} Engagement",
                            "value": level_label,
                            "evidence": evidence,
                            "keyword": kw
                        })
                        print(f"[MOJ-LEAVE] 4d {eng_type.upper()} engagement: {level} (keyword: '{kw}')")
                        break
                if extracted_attitude.get(f"{eng_type}_engagement") is not None:
                    break

        # Extract behaviour items
        behaviour_labels = {
            "verbal_physical": "Verbal/Physical Aggression",
            "substance_abuse": "Substance Abuse",
            "self_harm": "Self-Harm",
            "fire_setting": "Fire-Setting",
            "intimidation": "Intimidation/Threats",
            "secretive": "Secretive/Manipulative",
            "subversive": "Subversive Behaviour",
            "sexually_disinhibited": "Sexually Inappropriate",
            "extremist": "Extremist Behaviour",
            "seclusion": "Periods of Seclusion",
        }
        for beh_key, values in BEHAVIOUR_KEYWORDS.items():
            # IMPORTANT: Check for NEGATIVE patterns FIRST (e.g., "no self-harm" before "self-harm")
            # This prevents false positives when text says "no incidents of X"
            for kw in values.get(False, []):
                if kw in attitude_search_text:
                    extracted_attitude[beh_key] = False
                    evidence = get_evidence_context(attitude_search_text, kw)
                    attitude_evidence.append({
                        "category": "Behaviour",
                        "field": behaviour_labels.get(beh_key, beh_key),
                        "value": "No",
                        "evidence": evidence,
                        "keyword": kw
                    })
                    print(f"[MOJ-LEAVE] 4d Behaviour '{beh_key}': NO (keyword: '{kw}')")
                    break
            # Only check for positive patterns if no negative pattern was found
            if extracted_attitude.get(beh_key) is None:
                for kw in values.get(True, []):
                    if kw in attitude_search_text:
                        # Skip if this appears in a historical context (old dates nearby)
                        if is_historical_context(attitude_search_text, kw):
                            print(f"[MOJ-LEAVE] 4d Behaviour '{beh_key}': SKIPPED - historical context for '{kw}'")
                            continue
                        extracted_attitude[beh_key] = True
                        evidence = get_evidence_context(attitude_search_text, kw)
                        attitude_evidence.append({
                            "category": "Behaviour",
                            "field": behaviour_labels.get(beh_key, beh_key),
                            "value": "Yes",
                            "evidence": evidence,
                            "keyword": kw
                        })
                        print(f"[MOJ-LEAVE] 4d Behaviour '{beh_key}': YES (keyword: '{kw}')")
                        break

        # Extract understanding
        for level, keywords in UNDERSTANDING_KEYWORDS.items():
            for kw in keywords:
                if kw in attitude_search_text:
                    extracted_attitude["understanding"] = level
                    evidence = get_evidence_context(attitude_search_text, kw)
                    attitude_evidence.append({
                        "category": "Attitude",
                        "field": "Understanding",
                        "value": level.title(),
                        "evidence": evidence,
                        "keyword": kw
                    })
                    print(f"[MOJ-LEAVE] 4d Understanding: '{level}' (keyword: '{kw}')")
                    break
            if extracted_attitude["understanding"]:
                break

        # Extract compliance
        for level, keywords in COMPLIANCE_KEYWORDS.items():
            for kw in keywords:
                if kw in attitude_search_text:
                    extracted_attitude["compliance"] = level
                    evidence = get_evidence_context(attitude_search_text, kw)
                    attitude_evidence.append({
                        "category": "Attitude",
                        "field": "Compliance",
                        "value": level.title(),
                        "evidence": evidence,
                        "keyword": kw
                    })
                    print(f"[MOJ-LEAVE] 4d Compliance: '{level}' (keyword: '{kw}')")
                    break
            if extracted_attitude["compliance"]:
                break

        # Search for OT groups mentioned
        OT_GROUPS = {
            "breakfast_club": ["breakfast club", "breakfast group"],
            "cooking": ["cooking group", "cooking session"],
            "current_affairs": ["current affairs"],
            "self_care": ["self care", "self-care group"],
            "music": ["music group", "music session", "music therapy"],
            "art": ["art group", "art therapy", "art session"],
            "gym": ["gym", "gymnasium", "fitness"],
            "horticulture": ["horticulture", "gardening", "garden group"],
            "woodwork": ["woodwork", "wood work", "carpentry"],
            "walking": ["walking group", "walk group", "walks"],
        }

        detected_ot_groups = []
        for group_key, keywords in OT_GROUPS.items():
            for kw in keywords:
                if kw in attitude_search_text:
                    detected_ot_groups.append(group_key)
                    print(f"[MOJ-LEAVE] 4d: Detected OT group '{group_key}' (keyword: '{kw}')")
                    break

        extracted_attitude["ot_groups"] = detected_ot_groups

        # Search for psychology sessions mentioned
        PSYCH_SESSIONS = {
            "one_to_one": ["1-1", "one to one", "individual session"],
            "risk": ["risk work", "risk session"],
            "insight": ["insight work", "insight session"],
            "psychoeducation": ["psychoeducation", "psychoed"],
            "managing_emotions": ["managing emotions", "emotion management", "emotional regulation"],
            "drugs_alcohol": ["drugs and alcohol", "substance misuse work"],
            "discharge_planning": ["discharge planning"],
            "relapse_prevention_group": ["relapse prevention group"],
            "relapse_prevention_1to1": ["relapse prevention 1-1", "relapse prevention one to one"],
        }

        detected_psych_sessions = []
        for session_key, keywords in PSYCH_SESSIONS.items():
            for kw in keywords:
                if kw in attitude_search_text:
                    detected_psych_sessions.append(session_key)
                    print(f"[MOJ-LEAVE] 4d: Detected psychology session '{session_key}' (keyword: '{kw}')")
                    break

        extracted_attitude["psych_sessions"] = detected_psych_sessions

        # Set engagement levels based on detected activities
        if detected_ot_groups and extracted_attitude.get("ot_engagement") is None:
            # More groups = better engagement
            if len(detected_ot_groups) >= 4:
                extracted_attitude["ot_engagement"] = 4  # Very Good
            elif len(detected_ot_groups) >= 2:
                extracted_attitude["ot_engagement"] = 3  # Good
            else:
                extracted_attitude["ot_engagement"] = 2  # Reasonable
            print(f"[MOJ-LEAVE] 4d: Set OT engagement to {extracted_attitude['ot_engagement']} based on {len(detected_ot_groups)} groups")

        if detected_psych_sessions and extracted_attitude.get("psych_engagement") is None:
            if len(detected_psych_sessions) >= 3:
                extracted_attitude["psych_engagement"] = 4  # Very Good
            elif len(detected_psych_sessions) >= 2:
                extracted_attitude["psych_engagement"] = 3  # Good
            else:
                extracted_attitude["psych_engagement"] = 2  # Reasonable
            print(f"[MOJ-LEAVE] 4d: Set psych engagement to {extracted_attitude['psych_engagement']} based on {len(detected_psych_sessions)} sessions")

        # Apply defaults if nothing found - default to good/full for attitude
        if extracted_attitude.get("understanding") is None:
            extracted_attitude["understanding"] = "good"
            print(f"[MOJ-LEAVE] 4d: Defaulting understanding to 'good'")

        if extracted_attitude.get("compliance") is None:
            extracted_attitude["compliance"] = "full"
            print(f"[MOJ-LEAVE] 4d: Defaulting compliance to 'full'")

        if extracted_attitude.get("ward_rules") is None:
            extracted_attitude["ward_rules"] = "Compliant"
            print(f"[MOJ-LEAVE] 4d: Defaulting ward rules to 'Compliant'")

        if extracted_attitude.get("conflict") is None:
            extracted_attitude["conflict"] = "Avoids"
            print(f"[MOJ-LEAVE] 4d: Defaulting conflict to 'Avoids'")

        # Default all behaviour items to No if not found
        behaviour_keys = ["verbal_physical", "substance_abuse", "self_harm", "fire_setting",
                         "intimidation", "secretive", "subversive", "sexually_disinhibited",
                         "extremist", "seclusion"]
        for beh_key in behaviour_keys:
            if extracted_attitude.get(beh_key) is None:
                extracted_attitude[beh_key] = False
                print(f"[MOJ-LEAVE] 4d: Defaulting behaviour '{beh_key}' to No")

        if extracted_attitude.get("staff_relationship") is None:
            extracted_attitude["staff_relationship"] = 2  # Good
            print(f"[MOJ-LEAVE] 4d: Defaulting staff relationship to 'Good' (2)")

        if extracted_attitude.get("peers_relationship") is None:
            extracted_attitude["peers_relationship"] = 2  # Good
            print(f"[MOJ-LEAVE] 4d: Defaulting peers relationship to 'Good' (2)")

        print(f"[MOJ-LEAVE] 4d extraction complete - {len(attitude_evidence)} evidence items found")

        # ================================================================
        # 4G: INDEX OFFENCE WORK DETECTION
        # ================================================================
        # Slider options: ["None", "Considering", "Starting", "Engaging", "Well Engaged", "Almost Complete", "Complete"]
        extracted_index_offence_work = None
        doc_lower = document_text.lower()

        print(f"\n[MOJ-LEAVE] === 4G INDEX OFFENCE WORK DETECTION ===")
        print(f"[MOJ-LEAVE] 4g: Source types - is_notes={is_notes}, is_report={is_report}")

        # Keywords for different stages of index offence work
        COMPLETE_KEYWORDS = [
            "completed work on index offence", "completed offence work", "finished psychology",
            "completed psychology programme", "completed treatment programme",
            "has completed work", "work is complete", "programme completed"
        ]
        ALMOST_COMPLETE_KEYWORDS = [
            "nearing completion", "almost complete", "nearly finished", "approaching completion",
            "final stages", "concluding work", "winding down", "last sessions"
        ]
        WELL_ENGAGED_KEYWORDS = [
            "well engaged", "fully engaged", "actively engaged", "engaging well",
            "good engagement", "excellent engagement", "consistent engagement",
            "regularly attending psychology", "fully participating"
        ]
        ENGAGING_KEYWORDS = [
            "engaging with", "engaged in", "participating in", "attending psychology",
            "working with psychology", "psychology sessions", "offence focused work",
            "addressing index offence", "exploring offence", "working on offence"
        ]
        STARTING_KEYWORDS = [
            "starting work", "begun work", "commenced work", "initiated work",
            "early stages", "beginning therapy", "new referral", "recently started",
            "initial assessment", "formulation stage"
        ]
        CONSIDERING_KEYWORDS = [
            "considering referral", "awaiting psychology", "pending referral",
            "referred to psychology", "on waiting list", "assessment pending",
            "being considered for", "may benefit from", "recommended for psychology"
        ]
        NO_WORK_KEYWORDS = [
            "no psychology", "not engaged", "declined psychology", "refuses to engage",
            "no offence work", "not addressing", "avoids discussion of index offence",
            "denies index offence", "no insight into offence"
        ]

        # Search text based on document type
        search_text = ""

        if is_report:
            # For reports, search specific sections
            REPORT_QUESTIONS = [
                "give a summary of the patient's current progress, behaviour, capacity and insight",
                "what is the patient's understanding of, compliance with, and likely future willingness",
                "work to address index offence",
                "psychology involvement",
                "offence related work"
            ]

            for question in REPORT_QUESTIONS:
                if question in doc_lower:
                    q_pos = doc_lower.find(question)
                    # Get answer section (up to 1000 chars after question)
                    answer_section = document_text[q_pos:q_pos + 1500]
                    search_text += answer_section + "\n"
                    print(f"[MOJ-LEAVE] 4g: Found report section: '{question[:50]}...'")

            # Also search for general index offence mentions
            if "index offence" in doc_lower:
                io_matches = list(re.finditer(r'index\s+offence[^.]*\.', doc_lower, re.IGNORECASE))
                for match in io_matches[:5]:  # Limit to 5 matches
                    search_text += match.group() + "\n"

        if is_notes or not search_text:
            # For notes, search for psychology-related entries
            NOTES_KEYWORDS = [
                "psychology", "index offence", "offence work", "therapeutic work",
                "formulation", "treatment programme", "psychologist", "therapy session"
            ]

            for kw in NOTES_KEYWORDS:
                if _short_kw_matches(kw, doc_lower):
                    # Find all sentences containing the keyword
                    for match in re.finditer(rf'[^.]*{re.escape(kw)}[^.]*\.', doc_lower):
                        search_text += match.group() + "\n"

        search_lower = search_text.lower()
        print(f"[MOJ-LEAVE] 4g: Searching {len(search_text)} chars of relevant text")

        # Determine slider value based on keywords (check in order of completion)
        if any(kw in search_lower for kw in COMPLETE_KEYWORDS):
            extracted_index_offence_work = 6  # Complete
            print(f"[MOJ-LEAVE] 4g: Detected COMPLETE index offence work")
        elif any(kw in search_lower for kw in ALMOST_COMPLETE_KEYWORDS):
            extracted_index_offence_work = 5  # Almost Complete
            print(f"[MOJ-LEAVE] 4g: Detected ALMOST COMPLETE index offence work")
        elif any(kw in search_lower for kw in WELL_ENGAGED_KEYWORDS):
            extracted_index_offence_work = 4  # Well Engaged
            print(f"[MOJ-LEAVE] 4g: Detected WELL ENGAGED with index offence work")
        elif any(kw in search_lower for kw in ENGAGING_KEYWORDS):
            extracted_index_offence_work = 3  # Engaging
            print(f"[MOJ-LEAVE] 4g: Detected ENGAGING with index offence work")
        elif any(kw in search_lower for kw in STARTING_KEYWORDS):
            extracted_index_offence_work = 2  # Starting
            print(f"[MOJ-LEAVE] 4g: Detected STARTING index offence work")
        elif any(kw in search_lower for kw in CONSIDERING_KEYWORDS):
            extracted_index_offence_work = 1  # Considering
            print(f"[MOJ-LEAVE] 4g: Detected CONSIDERING index offence work")
        elif any(kw in search_lower for kw in NO_WORK_KEYWORDS):
            extracted_index_offence_work = 0  # None
            print(f"[MOJ-LEAVE] 4g: Detected NO index offence work")
        else:
            # Default based on whether any psychology mention was found
            if "psychology" in search_lower or "index offence" in search_lower:
                extracted_index_offence_work = 3  # Engaging (default if mentioned)
                print(f"[MOJ-LEAVE] 4g: Psychology/offence mentioned, defaulting to ENGAGING")
            else:
                extracted_index_offence_work = 0  # None
                print(f"[MOJ-LEAVE] 4g: No psychology/offence mentions, defaulting to NONE")

        # ================================================================
        # 4G SECTION 2: OFFENDING BEHAVIOUR - INSIGHT & RESPONSIBILITY
        # ================================================================
        # Slider options:
        #   Insight: ["Nil", "Limited", "Partial", "Good", "Full"]
        #   Responsibility: ["Denies", "Minimises", "Partial", "Mostly", "Full"]
        #   Empathy: ["Nil", "Limited", "Developing", "Good", "Full"]

        extracted_offend_insight = None
        extracted_responsibility = None
        extracted_empathy = None

        print(f"\n[MOJ-LEAVE] === 4G SECTION 2: INSIGHT & RESPONSIBILITY DETECTION ===")

        # Use the same search_text built for Section 1 (Notes vs Reports)
        # Also add specific searches for responsibility/empathy

        section2_search = search_lower  # Start with existing search text

        # Additional report sections for insight/responsibility/empathy
        if is_report:
            SECTION2_QUESTIONS = [
                "insight into offending",
                "accepts responsibility",
                "victim empathy",
                "victim awareness",
                "understanding of harm",
                "remorse",
                "takes responsibility",
                "accountability"
            ]

            for question in SECTION2_QUESTIONS:
                if question in doc_lower:
                    q_pos = doc_lower.find(question)
                    answer_section = document_text[q_pos:q_pos + 800].lower()
                    section2_search += answer_section + "\n"
                    print(f"[MOJ-LEAVE] 4g-s2: Found report section: '{question}'")

        # Additional notes keywords for insight/responsibility
        if is_notes or not section2_search:
            SECTION2_NOTES_KW = [
                "insight", "responsibility", "empathy", "remorse", "victim",
                "accountability", "understanding of harm", "accepts", "denies"
            ]
            for kw in SECTION2_NOTES_KW:
                if _short_kw_matches(kw, doc_lower):
                    for match in re.finditer(rf'[^.]*{re.escape(kw)}[^.]*\.', doc_lower):
                        section2_search += match.group() + "\n"

        print(f"[MOJ-LEAVE] 4g-s2: Searching {len(section2_search)} chars of relevant text")

        # ---- INSIGHT INTO OFFENDING ----
        # Slider: Nil(0), Limited(1), Partial(2), Good(3), Full(4)
        FULL_INSIGHT_KEYWORDS = [
            "full insight into offending", "complete insight into offence",
            "fully understands", "comprehensive understanding of offending",
            "excellent insight into offence", "demonstrates full insight"
        ]
        GOOD_INSIGHT_KEYWORDS = [
            "good insight into offending", "good insight into offence",
            "demonstrates good insight", "shows good understanding of offending",
            "reasonable insight into offence", "adequate insight"
        ]
        PARTIAL_INSIGHT_KEYWORDS = [
            "partial insight", "some insight into offending", "developing insight",
            "emerging insight", "beginning to understand", "limited but developing",
            "some understanding of offending", "partially understands"
        ]
        LIMITED_INSIGHT_KEYWORDS = [
            "limited insight into offending", "poor insight into offence",
            "little insight", "minimal insight", "lacking insight",
            "superficial insight", "shallow understanding"
        ]
        NIL_INSIGHT_KEYWORDS = [
            "no insight into offending", "nil insight", "lacks any insight",
            "denies offending", "no understanding of offence", "refuses to acknowledge",
            "complete lack of insight", "absent insight"
        ]

        if any(kw in section2_search for kw in FULL_INSIGHT_KEYWORDS):
            extracted_offend_insight = 4  # Full
            print(f"[MOJ-LEAVE] 4g-s2: Detected FULL insight into offending")
        elif any(kw in section2_search for kw in GOOD_INSIGHT_KEYWORDS):
            extracted_offend_insight = 3  # Good
            print(f"[MOJ-LEAVE] 4g-s2: Detected GOOD insight into offending")
        elif any(kw in section2_search for kw in PARTIAL_INSIGHT_KEYWORDS):
            extracted_offend_insight = 2  # Partial
            print(f"[MOJ-LEAVE] 4g-s2: Detected PARTIAL insight into offending")
        elif any(kw in section2_search for kw in LIMITED_INSIGHT_KEYWORDS):
            extracted_offend_insight = 1  # Limited
            print(f"[MOJ-LEAVE] 4g-s2: Detected LIMITED insight into offending")
        elif any(kw in section2_search for kw in NIL_INSIGHT_KEYWORDS):
            extracted_offend_insight = 0  # Nil
            print(f"[MOJ-LEAVE] 4g-s2: Detected NIL insight into offending")
        else:
            extracted_offend_insight = 2  # Default to Partial
            print(f"[MOJ-LEAVE] 4g-s2: No specific insight level detected, defaulting to PARTIAL")

        # ---- ACCEPTS RESPONSIBILITY ----
        # Slider: Denies(0), Minimises(1), Partial(2), Mostly(3), Full(4)
        FULL_RESPONSIBILITY_KEYWORDS = [
            "fully accepts responsibility", "full responsibility", "takes full responsibility",
            "complete acceptance of responsibility", "fully accountable",
            "accepts total responsibility", "wholly accepts"
        ]
        MOSTLY_RESPONSIBILITY_KEYWORDS = [
            "mostly accepts responsibility", "largely accepts responsibility",
            "accepts most responsibility", "takes responsibility for most",
            "significant acceptance", "substantially accepts"
        ]
        PARTIAL_RESPONSIBILITY_KEYWORDS = [
            "partial responsibility", "some responsibility", "partly accepts",
            "accepts some responsibility", "partial acceptance",
            "beginning to accept responsibility", "emerging acceptance"
        ]
        MINIMISES_KEYWORDS = [
            "minimises responsibility", "minimises role", "minimises involvement",
            "downplays", "blames others", "externalises blame", "deflects responsibility",
            "attributes to others", "makes excuses", "justifies actions"
        ]
        DENIES_KEYWORDS = [
            "denies responsibility", "denies involvement", "refuses to accept",
            "no acceptance of responsibility", "maintains innocence",
            "completely denies", "rejects responsibility", "denies any role"
        ]

        if any(kw in section2_search for kw in FULL_RESPONSIBILITY_KEYWORDS):
            extracted_responsibility = 4  # Full
            print(f"[MOJ-LEAVE] 4g-s2: Detected FULL responsibility acceptance")
        elif any(kw in section2_search for kw in MOSTLY_RESPONSIBILITY_KEYWORDS):
            extracted_responsibility = 3  # Mostly
            print(f"[MOJ-LEAVE] 4g-s2: Detected MOSTLY accepts responsibility")
        elif any(kw in section2_search for kw in PARTIAL_RESPONSIBILITY_KEYWORDS):
            extracted_responsibility = 2  # Partial
            print(f"[MOJ-LEAVE] 4g-s2: Detected PARTIAL responsibility acceptance")
        elif any(kw in section2_search for kw in MINIMISES_KEYWORDS):
            extracted_responsibility = 1  # Minimises
            print(f"[MOJ-LEAVE] 4g-s2: Detected MINIMISES responsibility")
        elif any(kw in section2_search for kw in DENIES_KEYWORDS):
            extracted_responsibility = 0  # Denies
            print(f"[MOJ-LEAVE] 4g-s2: Detected DENIES responsibility")
        else:
            extracted_responsibility = 2  # Default to Partial
            print(f"[MOJ-LEAVE] 4g-s2: No specific responsibility level detected, defaulting to PARTIAL")

        # ---- VICTIM EMPATHY ----
        # Slider: Nil(0), Limited(1), Developing(2), Good(3), Full(4)
        FULL_EMPATHY_KEYWORDS = [
            "full victim empathy", "complete victim empathy", "excellent empathy",
            "full understanding of victim impact", "fully empathises",
            "deep empathy for victim", "comprehensive victim awareness"
        ]
        GOOD_EMPATHY_KEYWORDS = [
            "good victim empathy", "good empathy", "demonstrates empathy",
            "shows empathy for victim", "understands victim impact",
            "victim awareness", "remorse for victim", "genuine remorse"
        ]
        DEVELOPING_EMPATHY_KEYWORDS = [
            "developing empathy", "emerging empathy", "beginning to show empathy",
            "some victim empathy", "partial empathy", "growing awareness of victim",
            "starting to understand impact", "developing victim awareness"
        ]
        LIMITED_EMPATHY_KEYWORDS = [
            "limited empathy", "little empathy", "minimal empathy",
            "poor victim empathy", "lacks empathy", "superficial empathy",
            "shallow understanding of victim", "limited victim awareness"
        ]
        NIL_EMPATHY_KEYWORDS = [
            "no victim empathy", "nil empathy", "lacks any empathy",
            "no understanding of victim impact", "no remorse",
            "absent empathy", "callous", "dismissive of victim"
        ]

        if any(kw in section2_search for kw in FULL_EMPATHY_KEYWORDS):
            extracted_empathy = 4  # Full
            print(f"[MOJ-LEAVE] 4g-s2: Detected FULL victim empathy")
        elif any(kw in section2_search for kw in GOOD_EMPATHY_KEYWORDS):
            extracted_empathy = 3  # Good
            print(f"[MOJ-LEAVE] 4g-s2: Detected GOOD victim empathy")
        elif any(kw in section2_search for kw in DEVELOPING_EMPATHY_KEYWORDS):
            extracted_empathy = 2  # Developing
            print(f"[MOJ-LEAVE] 4g-s2: Detected DEVELOPING victim empathy")
        elif any(kw in section2_search for kw in LIMITED_EMPATHY_KEYWORDS):
            extracted_empathy = 1  # Limited
            print(f"[MOJ-LEAVE] 4g-s2: Detected LIMITED victim empathy")
        elif any(kw in section2_search for kw in NIL_EMPATHY_KEYWORDS):
            extracted_empathy = 0  # Nil
            print(f"[MOJ-LEAVE] 4g-s2: Detected NIL victim empathy")
        else:
            extracted_empathy = 2  # Default to Developing
            print(f"[MOJ-LEAVE] 4g-s2: No specific empathy level detected, defaulting to DEVELOPING")

        # ================================================================
        # DETECT HISTORICAL RISKS (same logic as 4E, for use in 4G Section 3)
        # ================================================================
        print(f"\n[MOJ-LEAVE] === DETECTING HISTORICAL RISKS FOR 4G ===")

        RISK_KEYWORD_MAP_4G = {
            "violence_others": {
                "positive": ["violen", "aggress", "assault", "attack", "punch", "hit", "kick", "weapon", "knife", "stabbed"],
                "negative": ["no violen", "no aggress", "not presented with any violen", "no incidents of violen", "nil violen", "no assault"],
            },
            "violence_property": {
                "positive": ["damage to property", "criminal damage", "smashed", "broke window", "fire setting", "arson"],
                "negative": ["no damage", "no criminal damage"],
            },
            "self_harm": {
                "positive": ["self-harm", "self harm", "cut himself", "cut herself", "ligature", "self-injur"],
                "negative": ["no self-harm", "no self harm", "no incidents of self-harm", "nil self-harm", "not self-harm"],
            },
            "suicide": {
                "positive": ["suicid", "end my life", "kill myself", "take my life", "overdose", "hanging"],
                "negative": ["no suicid", "not suicid", "nil suicid", "denies suicid"],
            },
            "self_neglect": {
                "positive": ["self-neglect", "self neglect", "poor hygiene", "not eating", "refusing food", "weight loss"],
                "negative": ["no self-neglect", "good hygiene", "eating well"],
            },
            "sexual": {
                "positive": ["rape", "sexual assault", "sexual offence", "indecent", "sexual.*inapprop"],
                "negative": ["no sexual", "nil sexual concerns"],
            },
            "exploitation": {
                "positive": ["exploit", "vulnerab", "taken advantage", "cuckooing", "county lines"],
                "negative": ["no exploit", "not vulnerable to"],
            },
            "substance": {
                "positive": ["substance", "drug", "cannabis", "cocaine", "heroin", "class a", "intoxicat", "alcohol"],
                "negative": ["no substance", "no drug", "abstinent", "negative drug test"],
            },
            "stalking": {
                "positive": ["stalk", "harass", "follow.*girl", "follow.*woman", "obsess"],
                "negative": ["no stalk", "no harass"],
            },
            "deterioration": {
                "positive": ["deteriorat", "relapse", "decompens", "worsening", "psychotic", "paranoi"],
                "negative": ["stable", "no deteriorat", "mental state stable", "settled"],
            },
            "non_compliance": {
                "positive": ["non-complia", "not complia", "refused medication", "disengag", "lack of engagement", "not engaging", "abscond"],
                "negative": ["complia", "engaging well", "good engagement"],
            },
        }

        # Look for historical section in document
        historical_section_titles = [
            "index offence", "forensic history", "previous conviction",
            "offending history", "criminal history", "past history", "background"
        ]

        historical_text = ""
        for title in historical_section_titles:
            pattern = rf'{title}[:\s]*([^§]+?)(?=\n\n\d+\.|\Z)'
            match = re.search(pattern, doc_lower, re.IGNORECASE | re.DOTALL)
            if match:
                historical_text += match.group(1) + " "

        # If no sections found, look for index offence pattern
        if not historical_text:
            io_match = re.search(r'index\s+offence.*', doc_lower, re.IGNORECASE | re.DOTALL)
            if io_match:
                historical_text = io_match.group()

        print(f"[MOJ-LEAVE] 4g: Historical text found: {len(historical_text)} chars")

        # Detect historical risks
        historical_risks_from_4e = {}
        if historical_text:
            for risk_key, patterns in RISK_KEYWORD_MAP_4G.items():
                # Check for negative patterns first
                has_negative = False
                for neg_pattern in patterns["negative"]:
                    if re.search(neg_pattern, historical_text):
                        has_negative = True
                        break

                if has_negative:
                    continue

                # Check for positive patterns
                for pos_pattern in patterns["positive"]:
                    neg_context = re.search(rf'no\s+(?:incidents?\s+of\s+)?{pos_pattern}|nil\s+{pos_pattern}|not\s+{pos_pattern}', historical_text)
                    if neg_context:
                        break

                    if re.search(pos_pattern, historical_text):
                        historical_risks_from_4e[risk_key] = "medium"
                        print(f"[MOJ-LEAVE] 4g: HISTORICAL {risk_key} detected (matched: '{pos_pattern}')")
                        break

        # Store for 4E popup to use later
        self._extracted_historical_risks = historical_risks_from_4e
        print(f"[MOJ-LEAVE] 4g: Detected {len(historical_risks_from_4e)} historical risks: {list(historical_risks_from_4e.keys())}")

        # ================================================================
        # 4G SECTION 3: ATTITUDES TO RISK FACTORS
        # ================================================================
        # Use historical risk factors detected above to pre-check
        # Then search for understanding level keywords
        # Attitude options: ["Avoids", "Limited understanding", "Some understanding", "Good understanding", "Fully understands"]
        # Default: "Some understanding" (index 2)

        print(f"\n[MOJ-LEAVE] === 4G SECTION 3: ATTITUDES TO RISK FACTORS ===")

        extracted_risk_attitudes = {}  # key -> {"checked": bool, "attitude": int}

        # Risk factor display names for pattern matching
        RISK_DISPLAY_NAMES = {
            "violence_others": ["violence", "violence to others", "violent behaviour", "aggression", "harm to others"],
            "violence_property": ["violence to property", "property damage", "criminal damage", "arson"],
            "self_harm": ["self-harm", "self harm", "self-injury", "self-injurious behaviour"],
            "suicide": ["suicide", "suicidal behaviour", "self-harm with intent", "ending his life"],
            "self_neglect": ["self-neglect", "self neglect", "personal care", "hygiene"],
            "sexual": ["sexual offending", "sexual behaviour", "sexual risk", "inappropriate sexual behaviour"],
            "exploitation": ["vulnerability", "exploitation", "being exploited", "safeguarding"],
            "substance": ["substance misuse", "drug use", "alcohol use", "addiction", "substance use"],
            "stalking": ["stalking", "harassment", "harassing behaviour", "obsessive behaviour"],
            "deterioration": ["mental health deterioration", "relapse", "deterioration", "mental state"],
            "non_compliance": ["non-compliance", "disengagement", "medication refusal", "treatment compliance"],
        }

        # Understanding level patterns - slider values 0-4
        # 4 = Fully understands, 3 = Good understanding, 2 = Some understanding, 1 = Limited understanding, 0 = Avoids
        UNDERSTANDING_PATTERNS = {
            4: [  # Fully understands
                "full understanding of", "fully understands", "complete understanding of",
                "excellent understanding of", "comprehensive understanding of", "fully appreciates",
                "thorough understanding of", "full insight into", "complete insight into",
                "excellent insight into", "fully aware of", "complete awareness of"
            ],
            3: [  # Good understanding
                "good understanding of", "demonstrates understanding of", "shows good awareness of",
                "reasonable understanding of", "adequate understanding of", "understands the impact of",
                "good insight into", "demonstrates insight into", "shows insight into",
                "aware of", "recognises", "acknowledges", "appreciates the risk of",
                "good knowledge of", "understands his risk of", "understands her risk of"
            ],
            2: [  # Some understanding
                "some understanding of", "developing understanding of", "emerging awareness of",
                "beginning to understand", "partial understanding of", "growing understanding of",
                "some insight into", "developing insight into", "emerging insight into",
                "some awareness of", "partial awareness of", "some knowledge of",
                "starting to understand", "beginning to recognise"
            ],
            1: [  # Limited understanding
                "limited understanding of", "poor understanding of", "little understanding of",
                "minimal understanding of", "struggles to understand", "superficial understanding of",
                "limited insight into", "poor insight into", "little insight into",
                "minimal insight into", "lacks understanding of", "limited awareness of",
                "little awareness of", "limited knowledge of", "poor knowledge of"
            ],
            0: [  # Avoids
                "avoids discussion of", "refuses to discuss", "denies any", "deflects from",
                "unwilling to engage with", "dismisses", "no insight into", "lacks any insight into",
                "no understanding of", "refuses to acknowledge", "denies", "avoids",
                "will not discuss", "refuses to engage with", "no awareness of"
            ]
        }

        # Check each risk factor from historical detection
        for rf_key in historical_risks_from_4e.keys():
            # Default to "Some understanding" (2)
            attitude_level = 2
            found_match = False

            # Get display names for this risk factor
            risk_names = RISK_DISPLAY_NAMES.get(rf_key, [rf_key])

            # Search for understanding patterns specific to this risk factor
            # e.g., "good understanding of his violence", "some insight into self-neglect"
            for level, patterns in sorted(UNDERSTANDING_PATTERNS.items(), reverse=True):
                if found_match:
                    break
                for pattern in patterns:
                    if found_match:
                        break
                    for risk_name in risk_names:
                        # Build regex: "pattern + risk_name" or "pattern + his/her + risk_name"
                        # e.g., "good understanding of his violence"
                        regex1 = rf'{re.escape(pattern)}\s+(?:his|her|their|the)?\s*{re.escape(risk_name)}'
                        regex2 = rf'{re.escape(pattern)}\s+{re.escape(risk_name)}'
                        # Also check reversed: "risk_name + pattern" context
                        regex3 = rf'{re.escape(risk_name)}[^.]*{re.escape(pattern)}'

                        if re.search(regex1, section2_search, re.IGNORECASE) or \
                           re.search(regex2, section2_search, re.IGNORECASE) or \
                           re.search(regex3, section2_search, re.IGNORECASE):
                            attitude_level = level
                            found_match = True
                            print(f"[MOJ-LEAVE] 4g-s3: {rf_key} = {['Avoids', 'Limited', 'Some', 'Good', 'Full'][level]} (matched: '{pattern}' + '{risk_name}')")
                            break

            if not found_match:
                print(f"[MOJ-LEAVE] 4g-s3: {rf_key} = SOME UNDERSTANDING (default)")

            extracted_risk_attitudes[rf_key] = {"checked": True, "attitude": attitude_level}

        print(f"[MOJ-LEAVE] 4g-s3: Extracted {len(extracted_risk_attitudes)} risk factor attitudes")

        # ================================================================
        # 4G SECTION 4: TREATMENT FOR RISK FACTORS
        # ================================================================
        # Treatment types: medication, psych_1to1, psych_groups, nursing, ot_support, social_work
        # Effectiveness: ["Nil", "Minimal", "Some", "Reasonable", "Good", "Very Good", "Excellent"] (0-6)
        # Logic:
        #   - Check if psychiatric medication present in 4f and patient is compliant
        #   - Check current risks from 4e to determine effectiveness
        #   - If NOT in current risks → Very Good (5)
        #   - If current risk HIGH → Minimal (1)
        #   - If current risk MEDIUM → Some (2)
        #   - If current risk LOW → Good (4)
        #   - Default for medication/psychology if compliant: Reasonable (3)
        #   - Only Nil (0) if evidence of non-compliance

        print(f"\n[MOJ-LEAVE] === 4G SECTION 4: TREATMENT FOR RISK FACTORS ===")

        extracted_treatments = {}  # risk_key -> {treatment_key -> {"checked": bool, "effectiveness": int}}

        # Get current risks from 4E
        current_risks_4e = {}
        if hasattr(self, '_extracted_current_risks') and self._extracted_current_risks:
            current_risks_4e = self._extracted_current_risks
            print(f"[MOJ-LEAVE] 4g-s4: Current risks from 4E: {current_risks_4e}")

        # Check if psychiatric medication is present (search document for medication keywords)
        PSYCHIATRIC_MEDICATION_KEYWORDS = [
            "clozapine", "olanzapine", "risperidone", "aripiprazole", "quetiapine",
            "haloperidol", "chlorpromazine", "amisulpride", "paliperidone", "zuclopenthixol",
            "flupentixol", "depot", "antipsychotic", "mood stabili", "lithium",
            "valproate", "carbamazepine", "lamotrigine", "prescribed medication",
            "current medication", "medication list", "regular medication"
        ]
        has_psychiatric_medication = any(_short_kw_matches(kw, doc_lower) for kw in PSYCHIATRIC_MEDICATION_KEYWORDS)
        print(f"[MOJ-LEAVE] 4g-s4: Psychiatric medication present: {has_psychiatric_medication}")

        # Check compliance status - detect separately from non-compliance
        # Compliance keywords (positive)
        COMPLIANCE_POSITIVE = [
            "compliant with medication", "good compliance", "excellent compliance",
            "full compliance", "medication compliant", "takes medication as prescribed",
            "adherent to medication", "medication adherence", "complies with",
            "taking medication regularly", "consistent with medication"
        ]
        # Non-compliance keywords (negative)
        NON_COMPLIANCE_KEYWORDS = [
            "non-compliant", "non compliant", "not compliant", "poor compliance",
            "refused medication", "refusing medication", "not taking medication",
            "medication refusal", "non-adherent", "not adherent", "stops medication",
            "stopped taking", "ceased medication", "discontinued medication"
        ]

        is_compliant = False
        is_non_compliant = False

        # Check for non-compliance first (more specific)
        for kw in NON_COMPLIANCE_KEYWORDS:
            if _short_kw_matches(kw, doc_lower):
                is_non_compliant = True
                print(f"[MOJ-LEAVE] 4g-s4: NON-COMPLIANCE detected ('{kw}')")
                break

        # Check for compliance (only if not non-compliant)
        if not is_non_compliant:
            for kw in COMPLIANCE_POSITIVE:
                if _short_kw_matches(kw, doc_lower):
                    is_compliant = True
                    print(f"[MOJ-LEAVE] 4g-s4: COMPLIANCE detected ('{kw}')")
                    break
            # Default to compliant if medication present and no non-compliance found
            if not is_compliant and has_psychiatric_medication:
                is_compliant = True
                print(f"[MOJ-LEAVE] 4g-s4: Defaulting to COMPLIANT (medication present, no non-compliance)")

        # Check if engaging in psychology
        is_engaging_psychology = False
        PSYCHOLOGY_ENGAGEMENT_KW = [
            "engaging with psychology", "engaged in psychology", "attending psychology",
            "psychology sessions", "working with psychology", "1-1 psychology",
            "individual psychology", "psychological work", "psychology input"
        ]
        for kw in PSYCHOLOGY_ENGAGEMENT_KW:
            if _short_kw_matches(kw, doc_lower):
                is_engaging_psychology = True
                print(f"[MOJ-LEAVE] 4g-s4: Psychology engagement detected ('{kw}')")
                break

        # Treatment search keywords
        TREATMENT_KEYWORDS = {
            "medication": ["medication", "pharmacolog", "antipsychotic", "depot", "clozapine", "olanzapine", "aripiprazole", "risperidone"],
            "psych_1to1": ["1-1", "1:1", "one-to-one", "individual therapy", "individual psychology", "psychology sessions"],
            "psych_groups": ["group work", "group therapy", "psychology group", "therapeutic group", "groups"],
            "nursing": ["nursing", "nurse", "primary nurse", "nursing support", "ward staff", "nursing intervention"],
            "ot_support": ["occupational therap", "o.t.", " ot ", "ot support", "activity", "vocational"],
            "social_work": ["social work", "social worker", "sw ", "care coordinator", "care co-ordinator"],
        }

        # Risk-specific treatment keywords for psychology work
        RISK_PSYCHOLOGY_KEYWORDS = {
            "violence_others": ["violence work", "aggression work", "anger management", "violence reduction", "managing violence"],
            "violence_property": ["property damage work", "arson work", "fire setting work"],
            "self_harm": ["self-harm work", "self harm work", "dbt", "dialectical", "managing self-harm"],
            "suicide": ["suicide prevention", "safety planning", "crisis work"],
            "self_neglect": ["self-care work", "personal hygiene", "self neglect work"],
            "sexual": ["sexual offending work", "sotp", "sex offender treatment", "healthy relationships", "sexual risk work"],
            "exploitation": ["vulnerability work", "safeguarding work", "exploitation awareness"],
            "substance": ["substance misuse work", "drug and alcohol", "addiction work", "relapse prevention"],
            "stalking": ["stalking work", "harassment work", "boundary work", "healthy relationships"],
            "deterioration": ["relapse prevention", "early warning signs", "wellness recovery", "mental health management"],
            "non_compliance": ["compliance work", "engagement work", "medication adherence", "psychoeducation"],
        }

        # Check if engaging in Index Offence work (from Section 1)
        # Values: 0=None, 1=Considering, 2=Starting, 3=Engaging, 4=Well Engaged, 5=Almost Complete, 6=Complete
        is_engaging_io_work = extracted_index_offence_work >= 3  # Engaging or better
        print(f"[MOJ-LEAVE] 4g-s4: Index Offence work level: {extracted_index_offence_work} (engaging: {is_engaging_io_work})")

        # Map Section 3 attitude to Section 4 effectiveness
        # Section 3: Avoids(0), Limited(1), Some(2), Good(3), Fully(4)
        # Section 4: Nil(0), Minimal(1), Some(2), Reasonable(3), Good(4), Very Good(5), Excellent(6)
        ATTITUDE_TO_EFFECTIVENESS = {
            0: 0,  # Avoids -> Nil
            1: 1,  # Limited -> Minimal
            2: 2,  # Some understanding -> Some
            3: 4,  # Good understanding -> Good
            4: 6,  # Fully understands -> Excellent
        }

        # ================================================================
        # MAP 4f MEDICATION RESPONSE TO 4g MEDICATION EFFECTIVENESS
        # ================================================================
        # 4f Response: 0=nil, 1=slight, 2=some, 3=moderate, 4=good, 5=excellent
        # 4g Effectiveness: 0=Nil, 1=Minimal, 2=Some, 3=Reasonable, 4=Good, 5=Very Good, 6=Excellent
        # Mapping:
        #   4f nil (0) or slight (1) → 4g Nil (0)
        #   4f some (2) → 4g Some (2)
        #   4f moderate (3) → 4g Reasonable (3)
        #   4f good (4) → 4g Good (4)
        #   4f excellent (5) → 4g Excellent (6)

        MED_RESPONSE_TO_EFFECTIVENESS = {
            0: 0,  # nil → Nil
            1: 0,  # slight → Nil
            2: 2,  # some → Some
            3: 3,  # moderate → Reasonable
            4: 4,  # good → Good
            5: 6,  # excellent → Excellent
        }

        # Get medication response from 4f (if extracted)
        med_response_4f = getattr(self, '_extracted_med_response', 3)  # Default to moderate (3)
        med_effectiveness_from_4f = MED_RESPONSE_TO_EFFECTIVENESS.get(med_response_4f, 3)
        med_response_labels = ["nil", "slight", "some", "moderate", "good", "excellent"]
        eff_labels = ["Nil", "Minimal", "Some", "Reasonable", "Good", "Very Good", "Excellent"]
        print(f"[MOJ-LEAVE] 4g-s4: 4f medication response = {med_response_labels[med_response_4f]} ({med_response_4f}) -> 4g effectiveness = {eff_labels[med_effectiveness_from_4f]} ({med_effectiveness_from_4f})")

        # For each risk factor, determine treatment effectiveness based on attitude score
        for rf_key, rf_data in extracted_risk_attitudes.items():
            rf_treatments = {}
            attitude_level = rf_data.get("attitude", 2)  # Default to Some understanding

            # Get base effectiveness from attitude level (used for psychology, not medication)
            base_effectiveness = ATTITUDE_TO_EFFECTIVENESS.get(attitude_level, 3)
            print(f"[MOJ-LEAVE] 4g-s4: {rf_key} attitude={attitude_level} -> base effectiveness={base_effectiveness}")

            # --- MEDICATION (uses 4f response mapping, not attitude) ---
            if has_psychiatric_medication:
                # Medication effectiveness is derived from 4f response slider, not attitude
                med_effectiveness = med_effectiveness_from_4f
                print(f"[MOJ-LEAVE] 4g-s4: {rf_key}/medication = {eff_labels[med_effectiveness]} (from 4f response)")

                rf_treatments["medication"] = {"checked": True, "effectiveness": med_effectiveness}

            # --- PSYCHOLOGY (1-1) ---
            # Check if this risk factor is linked to Index Offence (from historical risks in 4e)
            # Historical risks are those found in index offence/forensic history
            historical_risks_4e = getattr(self, '_extracted_historical_risks', {})
            is_io_linked = rf_key in historical_risks_4e

            if is_io_linked:
                # ================================================================
                # INDEX OFFENCE LINKED RISK FACTORS: Use 4g1 slider mapping
                # ================================================================
                # 4g1 slider: 0=None, 1=Considering, 2=Starting, 3=Engaging, 4=Well Engaged, 5=Almost Complete, 6=Complete
                # Psychology effectiveness mapping:
                #   None (0) / Considering (1) → Nil (0)
                #   Starting (2) → Some (2)
                #   Engaging (3) → Reasonable (3)
                #   Well Engaged (4) → Good (4)
                #   Almost Complete (5) → Very Good (5)
                #   Complete (6) → Excellent (6)
                IO_WORK_TO_PSYCH_EFFECTIVENESS = {
                    0: 0,  # None → Nil
                    1: 0,  # Considering → Nil
                    2: 2,  # Starting → Some
                    3: 3,  # Engaging → Reasonable
                    4: 4,  # Well Engaged → Good
                    5: 5,  # Almost Complete → Very Good
                    6: 6,  # Complete → Excellent
                }
                psych_effectiveness = IO_WORK_TO_PSYCH_EFFECTIVENESS.get(extracted_index_offence_work, 0)
                io_labels = ["None", "Considering", "Starting", "Engaging", "Well Engaged", "Almost Complete", "Complete"]
                print(f"[MOJ-LEAVE] 4g-s4: {rf_key}/psychology = {eff_labels[psych_effectiveness]} (IO-linked, 4g1={io_labels[extracted_index_offence_work]})")

                rf_treatments["psych_1to1"] = {"checked": True, "effectiveness": psych_effectiveness}

            else:
                # ================================================================
                # NON-INDEX-OFFENCE RISK FACTORS: Only tick if explicit evidence found
                # ================================================================
                # Search for specific psychology work keywords for this risk factor
                rf_psych_keywords = RISK_PSYCHOLOGY_KEYWORDS.get(rf_key, [])
                has_explicit_psych_evidence = any(_short_kw_matches(kw, doc_lower) for kw in rf_psych_keywords)

                if has_explicit_psych_evidence:
                    # Use attitude-based effectiveness for non-IO risks with explicit evidence
                    if attitude_level == 0:  # Avoids
                        psych_effectiveness = 0  # Nil
                        print(f"[MOJ-LEAVE] 4g-s4: {rf_key}/psychology = Nil (non-IO, avoids discussion)")
                    else:
                        psych_effectiveness = base_effectiveness
                        print(f"[MOJ-LEAVE] 4g-s4: {rf_key}/psychology = {eff_labels[psych_effectiveness]} (non-IO, explicit evidence found)")

                    rf_treatments["psych_1to1"] = {"checked": True, "effectiveness": psych_effectiveness}
                else:
                    # No explicit psychology evidence for this non-IO risk factor - do NOT tick psychology
                    print(f"[MOJ-LEAVE] 4g-s4: {rf_key}/psychology = NOT TICKED (non-IO, no explicit evidence)")

            # --- NURSING, OT, SOCIAL WORK - only if specifically mentioned ---
            for tx_key in ["nursing", "ot_support", "social_work"]:
                tx_keywords = TREATMENT_KEYWORDS[tx_key]
                is_mentioned = any(_short_kw_matches(kw, doc_lower) for kw in tx_keywords)

                if is_mentioned:
                    # Score based on attitude if not avoids, otherwise Reasonable
                    if attitude_level == 0:
                        tx_effectiveness = 0
                    else:
                        tx_effectiveness = base_effectiveness
                    rf_treatments[tx_key] = {"checked": True, "effectiveness": tx_effectiveness}
                    eff_labels = ["Nil", "Minimal", "Some", "Reasonable", "Good", "Very Good", "Excellent"]
                    print(f"[MOJ-LEAVE] 4g-s4: {rf_key}/{tx_key} = {eff_labels[tx_effectiveness]}")

            if rf_treatments:
                extracted_treatments[rf_key] = rf_treatments
                print(f"[MOJ-LEAVE] 4g-s4: {rf_key} has {len(rf_treatments)} treatments")

        # ================================================================
        # 4G SECTION 5: RELAPSE PREVENTION
        # ================================================================
        # Slider: ["Not started", "Just started", "Ongoing", "Significant progression", "Almost completed", "Completed"]
        # Logic:
        #   - If "commenced", "started", "beginning" RP → Just started (unless date > 2 months ago)
        #   - If start date > 2 months from report date → Ongoing
        #   - If "completed", "finished" → Completed
        #   - If ongoing and > 8 sessions mentioned → Significant progression

        print(f"\n[MOJ-LEAVE] === 4G SECTION 5: RELAPSE PREVENTION ===")

        extracted_relapse = 0  # Default to "Not started"

        # Keywords for completion status
        COMPLETED_RELAPSE_KW = [
            "completed relapse prevention", "relapse prevention complete",
            "finished relapse prevention", "completed rp work", "rp completed",
            "has completed his relapse", "has completed her relapse",
            "successfully completed relapse", "completed all relapse"
        ]
        ALMOST_COMPLETED_KW = [
            "nearing completion of relapse", "almost completed relapse",
            "final stages of relapse prevention", "nearly finished relapse"
        ]

        # Keywords for just started (recent commencement)
        JUST_STARTED_KW = [
            "commenced relapse prevention", "started relapse prevention",
            "has started relapse", "has commenced relapse", "began relapse",
            "beginning relapse prevention", "early stages of relapse",
            "recently started relapse", "just started relapse",
            "he commenced", "she commenced", "he started", "she started",
            "he has commenced", "she has commenced", "he has started", "she has started"
        ]

        # Keywords indicating ongoing work
        ONGOING_RELAPSE_KW = [
            "ongoing relapse prevention", "continuing relapse prevention",
            "engaged in relapse prevention", "working on relapse prevention",
            "relapse prevention work", "relapse prevention plan",
            "attending relapse", "receiving relapse", "in relapse prevention"
        ]

        NOT_STARTED_KW = [
            "not started relapse", "no relapse prevention", "yet to start relapse",
            "awaiting relapse prevention", "prior to relapse prevention",
            "has not yet started", "has not commenced"
        ]

        # Try to detect session count for relapse prevention
        session_count = 0
        session_patterns = [
            r'(\d+)\s*(?:relapse\s*prevention\s*)?sessions?\s*(?:of\s*relapse|completed|attended|so\s*far)',
            r'session\s*(\d+)\s*(?:of\s*relapse)?',
            r'attended\s*(\d+)\s*sessions?',
            r'completed\s*(\d+)\s*sessions?',
            r'(\d+)\s*sessions?\s*(?:of\s*rp|of\s*relapse\s*prevention)',
        ]
        for pattern in session_patterns:
            match = re.search(pattern, section2_search, re.IGNORECASE)
            if match:
                try:
                    session_count = max(session_count, int(match.group(1)))
                    print(f"[MOJ-LEAVE] 4g-s5: Detected {session_count} sessions (pattern: {pattern})")
                except ValueError:
                    pass

        # Try to detect start date and compare to report date
        rp_started_recently = False
        rp_started_long_ago = False

        # Get report date for comparison (try from stored data or use today)
        report_date = datetime.today()
        if hasattr(self, '_extracted_patient_details') and self._extracted_patient_details:
            if self._extracted_patient_details.get('report_date'):
                report_date = self._extracted_patient_details['report_date']

        # Search for date patterns near "started" or "commenced" keywords
        start_date_patterns = [
            r'(?:commenced|started|began)\s*(?:relapse\s*prevention\s*)?(?:in|on)?\s*(\d{1,2})[/\-](\d{1,2})[/\-](\d{2,4})',
            r'(\d{1,2})[/\-](\d{1,2})[/\-](\d{2,4})\s*(?:commenced|started|began)',
            r'(?:since|from)\s*(\d{1,2})[/\-](\d{1,2})[/\-](\d{2,4})',
            r'(?:commenced|started)\s*(?:relapse)?[^.]{0,30}(january|february|march|april|may|june|july|august|september|october|november|december)\s*(\d{4})',
        ]

        for pattern in start_date_patterns:
            match = re.search(pattern, section2_search, re.IGNORECASE)
            if match:
                try:
                    groups = match.groups()
                    if len(groups) >= 3 and groups[0].isdigit():
                        # Date format: DD/MM/YYYY or similar
                        day, month = int(groups[0]), int(groups[1])
                        year = int(groups[2])
                        if year < 100:
                            year += 2000
                        start_date = datetime(year, month, day)
                    elif len(groups) == 2:
                        # Month name + year format
                        month_names = ["january", "february", "march", "april", "may", "june",
                                       "july", "august", "september", "october", "november", "december"]
                        month = month_names.index(groups[0].lower()) + 1
                        year = int(groups[1])
                        start_date = datetime(year, month, 1)
                    else:
                        continue

                    # Calculate months difference
                    months_diff = (report_date.year - start_date.year) * 12 + (report_date.month - start_date.month)
                    print(f"[MOJ-LEAVE] 4g-s5: RP start date detected: {start_date.date()}, months ago: {months_diff}")

                    if months_diff <= 2:
                        rp_started_recently = True
                    else:
                        rp_started_long_ago = True
                    break
                except (ValueError, IndexError):
                    pass

        # Determine relapse prevention status
        if any(kw in section2_search for kw in COMPLETED_RELAPSE_KW):
            extracted_relapse = 5  # Completed
            print(f"[MOJ-LEAVE] 4g-s5: Relapse prevention = COMPLETED")
        elif any(kw in section2_search for kw in ALMOST_COMPLETED_KW):
            extracted_relapse = 4  # Almost completed
            print(f"[MOJ-LEAVE] 4g-s5: Relapse prevention = ALMOST COMPLETED")
        elif session_count >= 8 and (rp_started_long_ago or any(kw in section2_search for kw in ONGOING_RELAPSE_KW)):
            extracted_relapse = 3  # Significant progression (>8 sessions and ongoing)
            print(f"[MOJ-LEAVE] 4g-s5: Relapse prevention = SIGNIFICANT PROGRESSION ({session_count} sessions)")
        elif rp_started_long_ago or any(kw in section2_search for kw in ONGOING_RELAPSE_KW):
            extracted_relapse = 2  # Ongoing (started > 2 months ago or ongoing keywords)
            print(f"[MOJ-LEAVE] 4g-s5: Relapse prevention = ONGOING (long-standing or keywords)")
        elif rp_started_recently or any(kw in section2_search for kw in JUST_STARTED_KW):
            extracted_relapse = 1  # Just started
            print(f"[MOJ-LEAVE] 4g-s5: Relapse prevention = JUST STARTED")
        elif any(kw in section2_search for kw in NOT_STARTED_KW):
            extracted_relapse = 0  # Not started
            print(f"[MOJ-LEAVE] 4g-s5: Relapse prevention = NOT STARTED")
        else:
            # Default based on whether any relapse prevention mention exists
            if "relapse" in section2_search and "prevention" in section2_search:
                extracted_relapse = 2  # Ongoing (mentioned but no specific stage)
                print(f"[MOJ-LEAVE] 4g-s5: Relapse prevention mentioned, defaulting to ONGOING")
            elif "relapse" in section2_search:
                extracted_relapse = 1  # Just started if only relapse mentioned
                print(f"[MOJ-LEAVE] 4g-s5: Relapse mentioned (no prevention), defaulting to JUST STARTED")
            else:
                extracted_relapse = 0  # Not started
                print(f"[MOJ-LEAVE] 4g-s5: No relapse prevention mentions, defaulting to NOT STARTED")

        # ================================================================
        # 4G SECTION 6: CURRENT ENGAGEMENT
        # ================================================================
        # Checkboxes: one_to_one, risk, insight, psychoeducation, managing_emotions,
        #             drugs_alcohol, carepathway, discharge_planning, schema_therapy, sotp
        #
        # Priority detection: psychoeducation, managing_emotions, and risk should be
        # auto-detected with broader keywords based on enclosed text patterns

        print(f"\n[MOJ-LEAVE] === 4G SECTION 6: CURRENT ENGAGEMENT ===")

        extracted_engagement = {}  # key -> bool

        # Enhanced keywords with broader detection for key items
        ENGAGEMENT_KEYWORDS = {
            "one_to_one": ["1-1", "1:1", "one-to-one", "individual session", "individual work",
                          "individual psychology", "individual therapy"],
            "risk": ["risk work", "risk management", "addressing risk", "risk assessment work",
                    "managing risk", "understanding risk", "risk awareness", "work on risk",
                    "risk factors", "working on his risk", "working on her risk",
                    "addressing his risk", "addressing her risk"],
            "insight": ["insight work", "developing insight", "gaining insight", "insight into",
                       "building insight", "improving insight"],
            "psychoeducation": ["psychoeducation", "psycho-education", "educational work",
                               "understanding illness", "understanding his illness",
                               "understanding her illness", "illness education",
                               "education about", "learning about his", "learning about her",
                               "understanding diagnosis", "diagnosis education",
                               "mental health education", "condition education"],
            "managing_emotions": ["managing emotions", "emotional regulation", "emotion management",
                                 "coping skills", "dbt", "dialectical", "anger management",
                                 "managing his emotions", "managing her emotions",
                                 "controlling emotions", "emotional control",
                                 "emotional awareness", "managing feelings",
                                 "distress tolerance", "mindfulness", "grounding techniques"],
            "drugs_alcohol": ["drugs and alcohol", "substance work", "addiction work", "drug education",
                             "substance misuse work", "alcohol work"],
            "carepathway": ["care pathway", "carepathway", "treatment pathway", "recovery pathway"],
            "discharge_planning": ["discharge planning", "discharge preparation", "leave planning",
                                  "community transition", "community placement"],
            "schema_therapy": ["schema therapy", "schema work", "schema-focused"],
            "sotp": ["sotp", "sex offender treatment", "sexual offending programme"],
        }

        for eng_key, keywords in ENGAGEMENT_KEYWORDS.items():
            is_engaged = any(kw in section2_search for kw in keywords)
            if is_engaged:
                extracted_engagement[eng_key] = True
                print(f"[MOJ-LEAVE] 4g-s6: Currently engaged in: {eng_key}")

        # Additional detection: If engaging in psychology (Section 1/4), auto-check these
        # based on generic psychology engagement indicators
        if is_engaging_psychology or is_engaging_io_work:
            # If psychology engagement detected, likely doing psychoeducation
            if "psychoeducation" not in extracted_engagement:
                # Check for any education/understanding work
                edu_patterns = ["education", "understanding", "awareness", "learning about"]
                if any(p in section2_search for p in edu_patterns):
                    extracted_engagement["psychoeducation"] = True
                    print(f"[MOJ-LEAVE] 4g-s6: Auto-detected psychoeducation (psychology + education context)")

            # If psychology engagement, likely doing emotion/risk work
            if "managing_emotions" not in extracted_engagement:
                emotion_patterns = ["emotion", "feeling", "anger", "anxiety", "mood", "coping"]
                if any(p in section2_search for p in emotion_patterns):
                    extracted_engagement["managing_emotions"] = True
                    print(f"[MOJ-LEAVE] 4g-s6: Auto-detected managing_emotions (psychology + emotion context)")

            if "risk" not in extracted_engagement:
                risk_patterns = ["risk", "offending", "violence", "safety"]
                if any(p in section2_search for p in risk_patterns):
                    extracted_engagement["risk"] = True
                    print(f"[MOJ-LEAVE] 4g-s6: Auto-detected risk (psychology + risk context)")

        print(f"[MOJ-LEAVE] 4g-s6: Found {len(extracted_engagement)} current engagements")

        # ================================================================
        # 4G SECTION 7: OUTSTANDING NEEDS
        # ================================================================
        # Same checkboxes as Section 6 but for work still needed

        print(f"\n[MOJ-LEAVE] === 4G SECTION 7: OUTSTANDING NEEDS ===")

        extracted_outstanding = {}  # key -> bool

        OUTSTANDING_KEYWORDS = {
            "one_to_one": ["requires 1-1", "needs individual", "further 1-1", "more 1:1"],
            "risk": ["further risk work", "ongoing risk", "needs risk work", "more work on risk"],
            "insight": ["needs more insight", "further insight work", "insight remains limited", "requires insight"],
            "psychoeducation": ["further psychoeducation", "needs psychoeducation", "more education needed"],
            "managing_emotions": ["needs emotion work", "further emotional regulation", "coping skills needed"],
            "drugs_alcohol": ["further substance work", "needs drugs and alcohol", "ongoing addiction work"],
            "carepathway": ["further pathway work", "needs care pathway", "pathway not complete"],
            "discharge_planning": ["needs discharge planning", "further discharge work", "discharge planning outstanding"],
            "schema_therapy": ["needs schema work", "further schema therapy", "schema work outstanding"],
            "sotp": ["needs sotp", "sotp outstanding", "requires sex offender treatment"],
        }

        # Also: items NOT in current engagement may be outstanding needs
        for eng_key, keywords in OUTSTANDING_KEYWORDS.items():
            is_outstanding = any(kw in section2_search for kw in keywords)
            # If not currently engaged but the topic is mentioned as a need
            if not is_outstanding and eng_key not in extracted_engagement:
                # Check if any general keyword for this work type appears with "need" or "require"
                for base_kw in ENGAGEMENT_KEYWORDS.get(eng_key, [])[:2]:  # Check first 2 keywords
                    if re.search(rf'(?:need|require|outstanding|further|more)[^.]*{re.escape(base_kw)}', section2_search):
                        is_outstanding = True
                        break
            if is_outstanding:
                extracted_outstanding[eng_key] = True
                print(f"[MOJ-LEAVE] 4g-s7: Outstanding need: {eng_key}")

        # DEFAULT: Discharge planning should always be checked on import
        # (patients in forensic settings always have discharge planning as an outstanding need)
        if "discharge_planning" not in extracted_outstanding:
            extracted_outstanding["discharge_planning"] = True
            print(f"[MOJ-LEAVE] 4g-s7: DEFAULT - Discharge planning checked (always outstanding)")

        print(f"[MOJ-LEAVE] 4g-s7: Found {len(extracted_outstanding)} outstanding needs")

        # ================================================================
        # FORM TEMPLATE EXCLUSIONS
        # ================================================================
        # These phrases appear in form templates/questions and should NOT be
        # matched as clinical data. They appear in:
        # - ASR form questions and prompts
        # - Tribunal report questions
        # - Leave form questions
        # - Generated output from these forms

        FORM_TEMPLATE_EXCLUSIONS = [
            # Fitness to plead template questions
            "do you consider that the patient is now fit to plead",
            "fit to plead at court for the offence which led",
            "has this patient been found unfit to plead on sentencing",
            "is patient now fit to plead",
            "the patient is now considered fit to plead",
            "the patient remains unfit to plead",
            "no fitness to plead information entered",

            # Extremism template questions
            "describe any extremism concerns",
            "any concerns about extremism",
            "are there any concerns regarding extremism",

            # AWOL template questions
            "has the patient been absent without leave",
            "failed to return from granted leave",
            "history of absconding",
            "any incidents of awol",

            # MAPPA template questions
            "is the patient known to any mappa meeting",
            "is the patient known to mappa",
            "mappa notification submitted",
            "has mappa been notified",
            "offender manager has been notified",
            "offender manager has not been notified",

            # Transferred prisoners template questions
            "complete this section if patient is a s47",
            "transferred prisoner",
            "offender manager (probation officer)",
            "has offender manager been notified of this application",
            "response to leave proposal",
            "prognosis of when patient will be returned to prison",
            "factors meaning remission is not appropriate",
            "if considered that patient is unlikely to be returned",

            # Tribunal report template questions
            "are there any factors that may affect",
            "are there any adjustments that the tribunal",
            "do you have any recommendations to the tribunal",
            "is the patient now suffering from a mental disorder",

            # ASR form template prompts
            "please describe the patient's attitude and behaviour",
            "including any incidents",

            # Common form labels/headings
            "imported data -",
            "matched:",
            "0 entries",
            "entries found",
            "no extremism-related entries",
            "no awol",
            "no mappa",
            "no offender manager",
            "no fitness to plead entries",
        ]

        def is_form_template_text(context_text):
            """Check if context contains form template phrases (should be excluded)."""
            if not context_text:
                return False
            context_lower = context_text.lower()
            for template_phrase in FORM_TEMPLATE_EXCLUSIONS:
                if template_phrase in context_lower:
                    return True
            return False

        def _short_kw_matches(kw, text_lower):
            """Check if keyword matches in text, using word boundaries for short keywords (<=5 chars)."""
            if len(kw) <= 5:
                return bool(re.search(r'(?<!\w)' + re.escape(kw) + r'(?!\w)', text_lower, re.IGNORECASE))
            return kw in text_lower

        # ================================================================
        # 4H: EXTREMISM DETECTION
        # ================================================================
        # Search for extremism and synonyms - if not found, set to N/A
        # Also extract matching entries with context for imported data display

        print(f"\n[MOJ-LEAVE] === 4H EXTREMISM DETECTION ===")

        extracted_extremism_concern = False  # Default: N/A (no concern found)
        extracted_extremism_entries = []  # List of {text, keyword, source, date}

        EXTREMISM_KEYWORDS = [
            # Core extremism terms
            "extremism", "extremist", "radicalisation", "radicalization",
            "radicalised", "radicalized", "de-radicalisation", "de-radicalization",
            # Terrorism (but not "terror" alone - too broad)
            "terrorism", "terrorist", "terror-related", "terror offence",
            # UK Prevent programme - must be specific phrases
            "prevent programme", "prevent program", "prevent referral", "prevent strategy",
            "prevent duty", "referred to prevent", "prevent team",
            # Channel programme (part of Prevent)
            "channel programme", "channel program", "channel referral", "channel panel",
            "referred to channel",
            # Counter-terrorism
            "counter-terrorism", "counter terrorism", "ct police", "ctiru",
            # Specific ideologies
            "far-right", "far right", "right-wing extremism", "left-wing extremism",
            "islamist", "jihadist", "salafist", "white supremacist", "white nationalist",
            "neo-nazi", "neo nazi", "nationalist extremism",
            # Other specific terms
            "hate group", "extremist ideology", "violent extremism",
            "domestic extremism", "international terrorism",
            "radicalising", "radicalizing", "extremist views", "extremist material"
        ]

        # Helper to extract context around keyword
        def extract_context(text, keyword, chars_before=100, chars_after=150):
            text_lower = text.lower()
            idx = text_lower.find(keyword.lower())
            if idx == -1:
                return None
            start = max(0, idx - chars_before)
            end = min(len(text), idx + len(keyword) + chars_after)
            context = text[start:end].strip()
            # Clean up to sentence boundaries if possible
            if start > 0:
                context = "..." + context
            if end < len(text):
                context = context + "..."
            return context

        # Search document text for extremism keywords
        if document_text:
            for kw in EXTREMISM_KEYWORDS:
                if _short_kw_matches(kw, doc_lower):
                    context = extract_context(document_text, kw)
                    if context and not is_form_template_text(context):
                        extracted_extremism_entries.append({
                            "text": context,
                            "keyword": kw,
                            "source": "Document",
                            "date": ""
                        })
                        extracted_extremism_concern = True
                        print(f"[MOJ-LEAVE] 4h: Found '{kw}' in document")
                    elif context:
                        print(f"[MOJ-LEAVE] 4h: Skipped '{kw}' - form template text")

        # Search raw notes for extremism keywords
        if hasattr(self, '_extracted_raw_notes') and self._extracted_raw_notes:
            seen_contexts = set()
            for note in self._extracted_raw_notes:
                note_text = note.get('content') or note.get('text') or note.get('preview') or ''
                note_text_lower = note_text.lower()
                note_date = note.get('date') or note.get('datetime') or ''
                if isinstance(note_date, datetime):
                    note_date = note_date.strftime("%d/%m/%Y")

                for kw in EXTREMISM_KEYWORDS:
                    if _short_kw_matches(kw, note_text_lower):
                        context = extract_context(note_text, kw)
                        if context and context[:50] not in seen_contexts and not is_form_template_text(context):
                            seen_contexts.add(context[:50])
                            extracted_extremism_entries.append({
                                "text": context,
                                "keyword": kw,
                                "source": "Clinical Notes",
                                "date": str(note_date)
                            })
                            extracted_extremism_concern = True
                            print(f"[MOJ-LEAVE] 4h: Found '{kw}' in note dated {note_date}")
                        elif context and is_form_template_text(context):
                            print(f"[MOJ-LEAVE] 4h: Skipped '{kw}' in note - form template text")

        if extracted_extremism_concern:
            print(f"[MOJ-LEAVE] 4h: Extremism concern = YES ({len(extracted_extremism_entries)} entries found)")
        else:
            print(f"[MOJ-LEAVE] 4h: Extremism concern = N/A (no keywords found)")

        # ================================================================
        # 4I: AWOL/ABSCONDING DETECTION (12-month lookback)
        # ================================================================
        # Search for AWOL incidents within 12 months of:
        #   - Most recent note (if notes import)
        #   - Report date (if report import)
        # Also extract matching entries with context for imported data display

        print(f"\n[MOJ-LEAVE] === 4I AWOL DETECTION ===")

        extracted_awol = False  # Default: No
        awol_details = []
        extracted_awol_entries = []  # List of {text, keyword, source, date, within_12_months}

        AWOL_KEYWORDS = [
            "awol", "absent without leave", "absconded", "absconding",
            "abscond", "failed to return", "did not return", "didn't return",
            "failure to return", "went missing", "went awol", "was awol",
            "returned late", "late return", "unauthorised absence",
            "unauthorized absence", "missing from ward", "missing from leave",
            "failed to return from leave", "did not return from leave"
        ]

        # Determine the reference date for 12-month lookback
        reference_date = datetime.today()

        # Try to get report date if available
        if hasattr(self, '_extracted_patient_details') and self._extracted_patient_details:
            if self._extracted_patient_details.get('report_date'):
                reference_date = self._extracted_patient_details['report_date']
                print(f"[MOJ-LEAVE] 4i: Using report date for AWOL lookback: {reference_date.date()}")

        # If raw notes available, find most recent date
        if hasattr(self, '_extracted_raw_notes') and self._extracted_raw_notes:
            note_dates = []
            for note in self._extracted_raw_notes:
                note_date = note.get('date') or note.get('datetime')
                if note_date:
                    if isinstance(note_date, datetime):
                        note_dates.append(note_date)
                    elif isinstance(note_date, str):
                        for fmt in ["%Y-%m-%d", "%d/%m/%Y", "%d-%m-%Y"]:
                            try:
                                note_dates.append(datetime.strptime(note_date.split()[0], fmt))
                                break
                            except ValueError:
                                pass
            if note_dates:
                most_recent_note = max(note_dates)
                reference_date = most_recent_note
                print(f"[MOJ-LEAVE] 4i: Using most recent note date for AWOL lookback: {reference_date.date()}")

        # Calculate 12 months before reference date
        twelve_months_ago = datetime(reference_date.year - 1, reference_date.month, reference_date.day) if reference_date.month <= 12 else reference_date
        print(f"[MOJ-LEAVE] 4i: 12-month lookback from {reference_date.date()} to {twelve_months_ago.date()}")

        # Search for AWOL in document text (for reports)
        if document_text:
            for kw in AWOL_KEYWORDS:
                if _short_kw_matches(kw, doc_lower):
                    context = extract_context(document_text, kw)
                    if context and not is_form_template_text(context):
                        extracted_awol_entries.append({
                            "text": context,
                            "keyword": kw,
                            "source": "Document",
                            "date": "",
                            "within_12_months": True  # Reports are current
                        })
                        extracted_awol = True
                        print(f"[MOJ-LEAVE] 4i: Found '{kw}' in document")
                    elif context:
                        print(f"[MOJ-LEAVE] 4i: Skipped '{kw}' - form template text")

        # Search raw notes with date filtering
        if hasattr(self, '_extracted_raw_notes') and self._extracted_raw_notes:
            seen_contexts = set()
            for note in self._extracted_raw_notes:
                note_text = note.get('content') or note.get('text') or note.get('preview') or ''
                note_text_lower = note_text.lower()
                note_date = note.get('date') or note.get('datetime')

                # Parse note date
                parsed_date = None
                if note_date:
                    if isinstance(note_date, datetime):
                        parsed_date = note_date
                    elif isinstance(note_date, str):
                        for fmt in ["%Y-%m-%d", "%d/%m/%Y", "%d-%m-%Y"]:
                            try:
                                parsed_date = datetime.strptime(note_date.split()[0], fmt)
                                break
                            except ValueError:
                                pass

                # Check if within 12 months
                within_12_months = True
                if parsed_date and parsed_date < twelve_months_ago:
                    within_12_months = False

                date_str = parsed_date.strftime("%d/%m/%Y") if parsed_date else ""

                # Check for AWOL keywords
                for kw in AWOL_KEYWORDS:
                    if _short_kw_matches(kw, note_text_lower):
                        context = extract_context(note_text, kw)
                        if context and context[:50] not in seen_contexts and not is_form_template_text(context):
                            seen_contexts.add(context[:50])
                            extracted_awol_entries.append({
                                "text": context,
                                "keyword": kw,
                                "source": "Clinical Notes",
                                "date": date_str,
                                "within_12_months": within_12_months
                            })
                            if within_12_months:
                                extracted_awol = True
                                awol_details.append(f"{date_str}: {kw}")
                            print(f"[MOJ-LEAVE] 4i: Found '{kw}' in note dated {date_str} (within 12 months: {within_12_months})")
                        elif context and is_form_template_text(context):
                            print(f"[MOJ-LEAVE] 4i: Skipped '{kw}' in note - form template text")

        if extracted_awol:
            print(f"[MOJ-LEAVE] 4i: AWOL = YES ({len([e for e in extracted_awol_entries if e.get('within_12_months')])} entries in 12-month window)")
        else:
            print(f"[MOJ-LEAVE] 4i: AWOL = NO (no incidents found in 12-month window)")

        # ================================================================
        # 5: MAPPA DETECTION
        # ================================================================
        # Search for MAPPA references and extract coordinator, category, level

        print(f"\n[MOJ-LEAVE] === 5 MAPPA DETECTION ===")

        extracted_mappa_eligible = False
        extracted_mappa_coordinator = ""
        extracted_mappa_category = None  # 1, 2, 3, or 4
        extracted_mappa_level = None  # 1, 2, or 3
        extracted_mappa_entries = []

        MAPPA_KEYWORDS = [
            "mappa", "multi-agency public protection", "multi agency public protection",
            "mappa category", "mappa level", "mappa coordinator", "mappa meeting",
            "mappa referral", "mappa panel", "mappa notification",
            "registered sex offender", "violent offender",
            "schedule 15", "other dangerous offender",
            "shpo", "sexual harm prevention order"
        ]

        # Search document text for MAPPA keywords
        if document_text:
            for kw in MAPPA_KEYWORDS:
                if _short_kw_matches(kw, doc_lower):
                    context = extract_context(document_text, kw)
                    if context and not is_form_template_text(context):
                        extracted_mappa_entries.append({
                            "text": context,
                            "keyword": kw,
                            "source": "Document",
                            "date": ""
                        })
                        extracted_mappa_eligible = True
                        print(f"[MOJ-LEAVE] 5: Found '{kw}' in document")
                    elif context:
                        print(f"[MOJ-LEAVE] 5: Skipped '{kw}' - form template text")

        # Search raw notes for MAPPA keywords
        if hasattr(self, '_extracted_raw_notes') and self._extracted_raw_notes:
            seen_contexts = set()
            for note in self._extracted_raw_notes:
                note_text = note.get('content') or note.get('text') or note.get('preview') or ''
                note_text_lower = note_text.lower()
                note_date = note.get('date') or note.get('datetime') or ''
                if isinstance(note_date, datetime):
                    note_date = note_date.strftime("%d/%m/%Y")

                for kw in MAPPA_KEYWORDS:
                    if _short_kw_matches(kw, note_text_lower):
                        context = extract_context(note_text, kw)
                        if context and context[:50] not in seen_contexts and not is_form_template_text(context):
                            seen_contexts.add(context[:50])
                            extracted_mappa_entries.append({
                                "text": context,
                                "keyword": kw,
                                "source": "Clinical Notes",
                                "date": str(note_date)
                            })
                            extracted_mappa_eligible = True
                            print(f"[MOJ-LEAVE] 5: Found '{kw}' in note dated {note_date}")
                        elif context and is_form_template_text(context):
                            print(f"[MOJ-LEAVE] 5: Skipped '{kw}' in note - form template text")

        # Extract MAPPA Category (1, 2, 3, or 4)
        category_patterns = [
            r'mappa\s*category\s*(\d)',
            r'category\s*(\d)\s*(?:offender|mappa)',
            r'cat(?:egory)?\s*(\d)\s*mappa',
            r'mappa\s*cat(?:egory)?\s*(\d)',
        ]
        for pattern in category_patterns:
            match = re.search(pattern, doc_lower)
            if match:
                try:
                    cat = int(match.group(1))
                    if 1 <= cat <= 4:
                        extracted_mappa_category = cat
                        print(f"[MOJ-LEAVE] 5: Detected MAPPA Category {cat}")
                        break
                except ValueError:
                    pass

        # If no explicit category found, infer from index offence / forensic history
        if extracted_mappa_category is None:
            # Gather all forensic/offence text for category detection
            offence_text_parts = []
            if hasattr(self, '_extracted_forensic_items') and self._extracted_forensic_items:
                for item in self._extracted_forensic_items:
                    text = item.get('text', '') or item.get('body', '')
                    if text:
                        offence_text_parts.append(text.lower())
            # Also check document text
            if doc_lower:
                offence_text_parts.append(doc_lower)

            offence_combined = " ".join(offence_text_parts)

            # Sexual offence keywords → Category 1
            SEXUAL_OFFENCE_KEYWORDS = [
                "sexual offence", "sexual offense", "sex offence", "sex offense",
                "rape", "sexual assault", "indecent assault", "indecent exposure",
                "child abuse", "child sexual", "paedophil", "pedophil",
                "sexual exploitation", "grooming", "indecent images",
                "voyeurism", "sexual harassment", "sexual abuse",
                "sexual touching", "incest", "buggery",
                "registered sex offender", "shpo", "sexual harm prevention"
            ]

            # Violent offence keywords → Category 2
            VIOLENT_OFFENCE_KEYWORDS = [
                "murder", "manslaughter", "attempted murder", "gbh",
                "grievous bodily harm", "abh", "actual bodily harm",
                "wounding", "assault occasioning", "violent disorder",
                "affray", "robbery", "armed robbery", "aggravated assault",
                "kidnapping", "false imprisonment", "hostage",
                "arson", "attempted arson", "arson with intent",
                "threat to kill", "threats to kill",
                "possession of offensive weapon", "possession of firearm",
                "knife crime", "stabbing", "shooting"
            ]

            # Extremism/terrorism keywords → Category 3
            EXTREMISM_OFFENCE_KEYWORDS = [
                "terrorism", "terrorist", "terror offence", "terror-related",
                "extremism", "extremist", "radicalisation", "radicalization",
                "proscribed organisation", "proscribed organization",
                "dissemination of terrorist", "encouragement of terrorism",
                "preparation of terrorist", "terrorist publication"
            ]

            # Check in order of priority (sexual first, then violent, then extremism)
            for kw in SEXUAL_OFFENCE_KEYWORDS:
                if kw in offence_combined:
                    extracted_mappa_category = 1
                    extracted_mappa_eligible = True
                    print(f"[MOJ-LEAVE] 5: Inferred Category 1 (Sexual) from offence keyword '{kw}'")
                    break

            if extracted_mappa_category is None:
                for kw in VIOLENT_OFFENCE_KEYWORDS:
                    if kw in offence_combined:
                        extracted_mappa_category = 2
                        extracted_mappa_eligible = True
                        print(f"[MOJ-LEAVE] 5: Inferred Category 2 (Violent) from offence keyword '{kw}'")
                        break

            if extracted_mappa_category is None:
                for kw in EXTREMISM_OFFENCE_KEYWORDS:
                    if kw in offence_combined:
                        extracted_mappa_category = 3
                        extracted_mappa_eligible = True
                        print(f"[MOJ-LEAVE] 5: Inferred Category 3 (Other Dangerous - Extremism) from offence keyword '{kw}'")
                        break

        # Extract MAPPA Level (1, 2, or 3)
        level_patterns = [
            r'mappa\s*level\s*(\d)',
            r'level\s*(\d)\s*mappa',
            r'managed\s*at\s*level\s*(\d)',
        ]
        for pattern in level_patterns:
            match = re.search(pattern, doc_lower)
            if match:
                try:
                    lvl = int(match.group(1))
                    if 1 <= lvl <= 3:
                        extracted_mappa_level = lvl
                        print(f"[MOJ-LEAVE] 5: Detected MAPPA Level {lvl}")
                        break
                except ValueError:
                    pass

        # Extract MAPPA Coordinator
        coord_patterns = [
            r'mappa\s*coordinator[:\s]+([A-Z][a-zA-Z\s]+?)(?:\.|,|\n|$)',
            r'coordinator[:\s]+([A-Z][a-zA-Z\s]+?)(?:\.|,|\n|$)',
            r'mappa\s*contact[:\s]+([A-Z][a-zA-Z\s]+?)(?:\.|,|\n|$)',
        ]
        for pattern in coord_patterns:
            match = re.search(pattern, document_text or '', re.IGNORECASE)
            if match:
                coord = match.group(1).strip()
                if len(coord) > 3 and len(coord) < 50:  # Reasonable name length
                    extracted_mappa_coordinator = coord
                    print(f"[MOJ-LEAVE] 5: Detected MAPPA Coordinator: {coord}")
                    break

        if extracted_mappa_eligible:
            print(f"[MOJ-LEAVE] 5: MAPPA = YES ({len(extracted_mappa_entries)} entries found)")
            # Default to Level 1 if no level was explicitly found
            if extracted_mappa_level is None:
                extracted_mappa_level = 1
                print(f"[MOJ-LEAVE] 5: Defaulting to MAPPA Level 1")
        else:
            print(f"[MOJ-LEAVE] 5: MAPPA = NO (no references found)")

        # ================================================================
        # 7: TRANSFERRED PRISONERS DETECTION
        # ================================================================
        # Check if patient is a transferred prisoner (s47/48/49 or s45A)
        # Search for offender manager/probation officer and remission details

        print(f"\n[MOJ-LEAVE] === 7 TRANSFERRED PRISONERS DETECTION ===")

        extracted_is_transferred = False
        extracted_om_contact = ""
        extracted_om_response = ""
        extracted_remission_prognosis = ""
        extracted_remission_factors = ""
        extracted_prisoners_entries = []

        # Check MHA section to determine if transferred prisoner
        TRANSFERRED_PRISONER_SECTIONS = ["47/49", "48/49", "45a", "s47", "s48", "s49", "s45a", "47", "48", "49"]
        if extracted_mha:
            mha_lower = extracted_mha.lower().replace(" ", "").replace("-", "")
            for section in TRANSFERRED_PRISONER_SECTIONS:
                if section.lower().replace(" ", "") in mha_lower:
                    extracted_is_transferred = True
                    print(f"[MOJ-LEAVE] 7: Patient is transferred prisoner (MHA Section: {extracted_mha})")
                    break

        # Also search document/notes for explicit transferred prisoner mentions
        if not extracted_is_transferred and document_text:
            transferred_keywords = ["transferred prisoner", "prison transfer", "s47", "s48", "s45a", "hospital direction"]
            for kw in transferred_keywords:
                if kw.lower() in doc_lower:
                    extracted_is_transferred = True
                    print(f"[MOJ-LEAVE] 7: Found '{kw}' in document - marking as transferred prisoner")
                    break

        # If transferred prisoner, search for offender manager / probation officer details
        if extracted_is_transferred:
            # Specific keywords for offender manager (NOT broad terms)
            OFFENDER_MANAGER_KEYWORDS = [
                "offender manager", "probation officer", "community offender manager",
                "nps officer", "national probation service", "probation service",
                "om contact", "probation contact", "offender manager contact",
                "supervising officer", "probation supervisor"
            ]

            # Remission to prison keywords
            REMISSION_KEYWORDS = [
                "remission to prison", "remission back to prison", "return to prison",
                "returned to prison", "prison return", "remit to prison",
                "remitted to prison", "transfer back to prison", "prison transfer",
                "earliest release date", "erd", "conditional release date", "crd",
                "sentence expiry", "parole", "licence conditions"
            ]

            # Search document for offender manager details
            if document_text:
                for kw in OFFENDER_MANAGER_KEYWORDS:
                    if _short_kw_matches(kw, doc_lower):
                        context = extract_context(document_text, kw, chars_before=50, chars_after=200)
                        if context and not is_form_template_text(context):
                            extracted_prisoners_entries.append({
                                "text": context,
                                "keyword": kw,
                                "category": "offender_manager",
                                "source": "Document",
                                "date": ""
                            })
                            print(f"[MOJ-LEAVE] 7: Found '{kw}' in document")

                            # Try to extract OM name/contact from context
                            if not extracted_om_contact:
                                # Look for name patterns after "offender manager" or "probation officer"
                                om_patterns = [
                                    r'offender\s*manager[:\s]+([A-Z][a-zA-Z\s\-]+?)(?:\.|,|\n|Tel|Email|$)',
                                    r'probation\s*officer[:\s]+([A-Z][a-zA-Z\s\-]+?)(?:\.|,|\n|Tel|Email|$)',
                                    r'om[:\s]+([A-Z][a-zA-Z\s\-]+?)(?:\.|,|\n|Tel|Email|$)',
                                ]
                                for pattern in om_patterns:
                                    match = re.search(pattern, context, re.IGNORECASE)
                                    if match:
                                        name = match.group(1).strip()
                                        if len(name) > 3 and len(name) < 50:
                                            extracted_om_contact = name
                                            print(f"[MOJ-LEAVE] 7a: Extracted OM name: {name}")
                                            break
                        elif context:
                            print(f"[MOJ-LEAVE] 7: Skipped '{kw}' - form template text")

                # Search for remission keywords in document
                for kw in REMISSION_KEYWORDS:
                    if _short_kw_matches(kw, doc_lower):
                        context = extract_context(document_text, kw, chars_before=50, chars_after=200)
                        if context and not is_form_template_text(context):
                            extracted_prisoners_entries.append({
                                "text": context,
                                "keyword": kw,
                                "category": "remission",
                                "source": "Document",
                                "date": ""
                            })
                            print(f"[MOJ-LEAVE] 7d: Found '{kw}' in document")
                        elif context:
                            print(f"[MOJ-LEAVE] 7d: Skipped '{kw}' - form template text")

            # Search notes for offender manager and remission details
            if hasattr(self, '_extracted_raw_notes') and self._extracted_raw_notes:
                seen_contexts = set()
                for note in self._extracted_raw_notes:
                    note_text = note.get('content') or note.get('text') or note.get('preview') or ''
                    note_text_lower = note_text.lower()
                    note_date = note.get('date') or note.get('datetime') or ''
                    if isinstance(note_date, datetime):
                        note_date = note_date.strftime("%d/%m/%Y")

                    # Search for offender manager keywords
                    for kw in OFFENDER_MANAGER_KEYWORDS:
                        if _short_kw_matches(kw, note_text_lower):
                            context = extract_context(note_text, kw, chars_before=50, chars_after=200)
                            if context and context[:50] not in seen_contexts and not is_form_template_text(context):
                                seen_contexts.add(context[:50])
                                extracted_prisoners_entries.append({
                                    "text": context,
                                    "keyword": kw,
                                    "category": "offender_manager",
                                    "source": "Clinical Notes",
                                    "date": str(note_date)
                                })
                                print(f"[MOJ-LEAVE] 7: Found '{kw}' in note dated {note_date}")
                            elif context and is_form_template_text(context):
                                print(f"[MOJ-LEAVE] 7: Skipped '{kw}' in note - form template text")

                    # Search for remission keywords
                    for kw in REMISSION_KEYWORDS:
                        if _short_kw_matches(kw, note_text_lower):
                            context = extract_context(note_text, kw, chars_before=50, chars_after=200)
                            if context and context[:50] not in seen_contexts and not is_form_template_text(context):
                                seen_contexts.add(context[:50])
                                extracted_prisoners_entries.append({
                                    "text": context,
                                    "keyword": kw,
                                    "category": "remission",
                                    "source": "Clinical Notes",
                                    "date": str(note_date)
                                })
                                print(f"[MOJ-LEAVE] 7d: Found '{kw}' in note dated {note_date}")
                            elif context and is_form_template_text(context):
                                print(f"[MOJ-LEAVE] 7d: Skipped '{kw}' in note - form template text")

            print(f"[MOJ-LEAVE] 7: Transferred prisoner = YES, {len(extracted_prisoners_entries)} entries found")
        else:
            print(f"[MOJ-LEAVE] 7: Not a transferred prisoner (MHA section not s47/48/49 or s45A)")

        # ================================================================
        # 8: FITNESS TO PLEAD DETECTION
        # ================================================================
        # Check if patient was found unfit to plead (CPIA, etc.)
        # Search for current fitness status

        print(f"\n[MOJ-LEAVE] === 8 FITNESS TO PLEAD DETECTION ===")

        extracted_was_unfit = False
        extracted_is_now_fit = None  # None = unknown, True = fit, False = still unfit
        extracted_fitness_details = ""
        extracted_fitness_entries = []

        # Keywords indicating patient was found unfit to plead
        UNFIT_TO_PLEAD_KEYWORDS = [
            "unfit to plead", "found unfit", "cpia", "criminal procedure insanity act",
            "criminal procedure (insanity) act", "insanity act",
            "section 4 finding", "section 4a finding", "s4 finding", "s4a finding",
            "disability in relation to trial", "under disability",
            "unfit to stand trial", "insanity verdict", "special verdict",
            "not guilty by reason of insanity", "ngri",
            "hospital order without conviction", "supervision order without conviction",
            "finding of unfitness", "trial of the facts"
        ]

        # Keywords indicating current fitness status
        NOW_FIT_KEYWORDS = [
            "now fit to plead", "fit to plead", "regained capacity", "fitness restored",
            "no longer unfit", "is now fit", "considered fit to plead",
            "capacity to plead", "able to plead", "fit for trial",
            "fit to stand trial", "fitness to plead assessment positive"
        ]

        STILL_UNFIT_KEYWORDS = [
            "remains unfit", "still unfit", "continues to be unfit",
            "not fit to plead", "unfit to plead remains", "lacks capacity to plead",
            "unable to plead", "fitness to plead assessment negative",
            "not considered fit", "not yet fit"
        ]

        # Search document for unfit to plead indicators
        if document_text:
            for kw in UNFIT_TO_PLEAD_KEYWORDS:
                if _short_kw_matches(kw, doc_lower):
                    context = extract_context(document_text, kw, chars_before=50, chars_after=200)
                    if context and not is_form_template_text(context):
                        extracted_fitness_entries.append({
                            "text": context,
                            "keyword": kw,
                            "category": "unfit",
                            "source": "Document",
                            "date": ""
                        })
                        extracted_was_unfit = True
                        print(f"[MOJ-LEAVE] 8: Found '{kw}' in document - patient was unfit to plead")
                    elif context:
                        print(f"[MOJ-LEAVE] 8: Skipped '{kw}' - form template text")

            # Check for current fitness status in document
            for kw in NOW_FIT_KEYWORDS:
                if _short_kw_matches(kw, doc_lower):
                    context = extract_context(document_text, kw, chars_before=50, chars_after=200)
                    if context and not is_form_template_text(context):
                        extracted_fitness_entries.append({
                            "text": context,
                            "keyword": kw,
                            "category": "now_fit",
                            "source": "Document",
                            "date": ""
                        })
                        extracted_is_now_fit = True
                        print(f"[MOJ-LEAVE] 8: Found '{kw}' in document - patient is now fit to plead")
                    elif context:
                        print(f"[MOJ-LEAVE] 8: Skipped '{kw}' - form template text")

            for kw in STILL_UNFIT_KEYWORDS:
                if _short_kw_matches(kw, doc_lower):
                    context = extract_context(document_text, kw, chars_before=50, chars_after=200)
                    if context and not is_form_template_text(context):
                        extracted_fitness_entries.append({
                            "text": context,
                            "keyword": kw,
                            "category": "unfit",
                            "source": "Document",
                            "date": ""
                        })
                        if extracted_is_now_fit is None:  # Don't override if already set to fit
                            extracted_is_now_fit = False
                        print(f"[MOJ-LEAVE] 8: Found '{kw}' in document - patient still unfit")
                    elif context:
                        print(f"[MOJ-LEAVE] 8: Skipped '{kw}' - form template text")

        # Search notes for fitness to plead
        if hasattr(self, '_extracted_raw_notes') and self._extracted_raw_notes:
            seen_contexts = set()
            for note in self._extracted_raw_notes:
                note_text = note.get('content') or note.get('text') or note.get('preview') or ''
                note_text_lower = note_text.lower()
                note_date = note.get('date') or note.get('datetime') or ''
                if isinstance(note_date, datetime):
                    note_date = note_date.strftime("%d/%m/%Y")

                # Search for unfit keywords
                for kw in UNFIT_TO_PLEAD_KEYWORDS:
                    if _short_kw_matches(kw, note_text_lower):
                        context = extract_context(note_text, kw, chars_before=50, chars_after=200)
                        if context and context[:50] not in seen_contexts and not is_form_template_text(context):
                            seen_contexts.add(context[:50])
                            extracted_fitness_entries.append({
                                "text": context,
                                "keyword": kw,
                                "category": "unfit",
                                "source": "Clinical Notes",
                                "date": str(note_date)
                            })
                            extracted_was_unfit = True
                            print(f"[MOJ-LEAVE] 8: Found '{kw}' in note dated {note_date}")
                        elif context and is_form_template_text(context):
                            print(f"[MOJ-LEAVE] 8: Skipped '{kw}' in note - form template text")

                # Search for current fitness status
                for kw in NOW_FIT_KEYWORDS:
                    if _short_kw_matches(kw, note_text_lower):
                        context = extract_context(note_text, kw, chars_before=50, chars_after=200)
                        if context and context[:50] not in seen_contexts and not is_form_template_text(context):
                            seen_contexts.add(context[:50])
                            extracted_fitness_entries.append({
                                "text": context,
                                "keyword": kw,
                                "category": "now_fit",
                                "source": "Clinical Notes",
                                "date": str(note_date)
                            })
                            extracted_is_now_fit = True
                            print(f"[MOJ-LEAVE] 8: Found '{kw}' in note dated {note_date}")
                        elif context and is_form_template_text(context):
                            print(f"[MOJ-LEAVE] 8: Skipped '{kw}' in note - form template text")

                for kw in STILL_UNFIT_KEYWORDS:
                    if _short_kw_matches(kw, note_text_lower):
                        context = extract_context(note_text, kw, chars_before=50, chars_after=200)
                        if context and context[:50] not in seen_contexts and not is_form_template_text(context):
                            seen_contexts.add(context[:50])
                            extracted_fitness_entries.append({
                                "text": context,
                                "keyword": kw,
                                "category": "unfit",
                                "source": "Clinical Notes",
                                "date": str(note_date)
                            })
                            if extracted_is_now_fit is None:
                                extracted_is_now_fit = False
                            print(f"[MOJ-LEAVE] 8: Found '{kw}' in note dated {note_date}")
                        elif context and is_form_template_text(context):
                            print(f"[MOJ-LEAVE] 8: Skipped '{kw}' in note - form template text")

        if extracted_was_unfit:
            status = "unknown"
            if extracted_is_now_fit is True:
                status = "now fit"
            elif extracted_is_now_fit is False:
                status = "still unfit"
            print(f"[MOJ-LEAVE] 8: Patient was unfit to plead = YES, current status: {status}, {len(extracted_fitness_entries)} entries found")
        else:
            print(f"[MOJ-LEAVE] 8: No unfit to plead indicators found")

        # ================================================================
        # STORE EXTRACTED PATIENT DETAILS (for lazy popup creation)
        # ================================================================
        self._extracted_patient_details = {
            "name": extracted_name,
            "dob": extracted_dob,
            "nhs_number": extracted_nhs,
            "hospital": extracted_hospital,
            "ward": extracted_ward,
            "mha_section": extracted_mha,
            "gender": extracted_gender,
            "age": extracted_age,
            "ethnicity": extracted_ethnicity,
            "diagnoses": extracted_diagnoses,
            "factors": extracted_factors,
            "mental_state": extracted_mental_state,
            "insight": extracted_insight,
            "mental_state_findings": mental_state_findings,  # For debug/review
            "observation_level": extracted_observation,
            "phys_impact": extracted_phys_impact,
            "attitude": extracted_attitude,
            "attitude_evidence": attitude_evidence,
            "index_offence_work": extracted_index_offence_work,  # 4G Section 1 slider value
            "offend_insight": extracted_offend_insight,  # 4G Section 2 - Insight into offending
            "responsibility": extracted_responsibility,  # 4G Section 2 - Accepts responsibility
            "victim_empathy": extracted_empathy,  # 4G Section 2 - Victim empathy
            "risk_attitudes": extracted_risk_attitudes,  # 4G Section 3 - Attitudes to risk factors
            "treatments": extracted_treatments,  # 4G Section 4 - Treatment for risk factors
            "relapse_prevention": extracted_relapse,  # 4G Section 5 - Relapse prevention slider
            "current_engagement": extracted_engagement,  # 4G Section 6 - Current engagement checkboxes
            "outstanding_needs": extracted_outstanding,  # 4G Section 7 - Outstanding needs checkboxes
            "extremism_concern": extracted_extremism_concern,  # 4H - Extremism (True=Yes, False=N/A)
            "extremism_entries": extracted_extremism_entries,  # 4H - Extremism matching entries
            "awol": extracted_awol,  # 4I - AWOL (True=Yes, False=No)
            "awol_details": awol_details,  # 4I - AWOL incident details
            "awol_entries": extracted_awol_entries,  # 4I - AWOL matching entries with context
            "mappa_eligible": extracted_mappa_eligible,  # 5 - MAPPA eligible (True=Yes, False=No)
            "mappa_coordinator": extracted_mappa_coordinator,  # 5a - MAPPA coordinator name
            "mappa_category": extracted_mappa_category,  # 5b - MAPPA category (1-4)
            "mappa_level": extracted_mappa_level,  # 5c - MAPPA level (1-3)
            "mappa_entries": extracted_mappa_entries,  # 5 - MAPPA matching entries with context
            "is_transferred_prisoner": extracted_is_transferred,  # 7 - Transferred prisoner (True=Yes, False=N/A)
            "offender_manager_contact": extracted_om_contact,  # 7a - Offender Manager contact
            "offender_manager_response": extracted_om_response,  # 7c - Offender Manager response
            "remission_prognosis": extracted_remission_prognosis,  # 7d - Remission prognosis
            "remission_factors": extracted_remission_factors,  # 7d - Factors against remission
            "prisoners_entries": extracted_prisoners_entries,  # 7 - Offender manager/remission entries
            "was_unfit_to_plead": extracted_was_unfit,  # 8 - Was unfit to plead (True=Yes, False=No)
            "is_now_fit_to_plead": extracted_is_now_fit,  # 8 - Now fit to plead (True/False/None)
            "fitness_details": extracted_fitness_details,  # 8 - Fitness details text
            "fitness_entries": extracted_fitness_entries,  # 8 - Fitness to plead entries
        }
        print(f"[MOJ-LEAVE] Stored patient details for prefill")

        # Push patient info to shared store for other forms
        from shared_data_store import get_shared_store
        patient_info = {
            "name": extracted_name,
            "dob": extracted_dob,
            "nhs_number": extracted_nhs,
            "gender": extracted_gender,
            "age": extracted_age,
            "ethnicity": extracted_ethnicity,
        }
        if any(patient_info.values()):
            shared_store = get_shared_store()
            shared_store.set_patient_info(patient_info, source="moj_leave")
            print(f"[MOJ-LEAVE] Pushed patient details to SharedDataStore: {list(k for k,v in patient_info.items() if v)}")

        # Try to populate now if widgets exist, otherwise will be done when popup is created
        self._apply_extracted_patient_details()

    def _apply_extracted_patient_details(self):
        """Apply stored patient details to form fields (called when popup is created or on extraction)."""
        if not hasattr(self, '_extracted_patient_details') or not self._extracted_patient_details:
            return

        from PySide6.QtCore import QDate
        details = self._extracted_patient_details

        # Patient Name
        if details.get("name") and hasattr(self, 'patient_name') and self.patient_name:
            if not self.patient_name.text().strip():
                self.patient_name.setText(details["name"])
                print(f"[MOJ-LEAVE] Set patient name: {details['name']}")

        # Date of Birth
        if details.get("dob") and hasattr(self, 'patient_dob') and self.patient_dob:
            dob = details["dob"]
            qdate = QDate(dob.year, dob.month, dob.day)
            current_dob = self.patient_dob.date()
            default_dates = [
                QDate.currentDate(),
                QDate(2000, 1, 1),
                QDate(1900, 1, 1),
            ]
            is_default = current_dob in default_dates or current_dob.year() == QDate.currentDate().year()
            if is_default:
                self.patient_dob.setDate(qdate)
                print(f"[MOJ-LEAVE] Set patient DOB: {qdate.toString('dd/MM/yyyy')}")

        # NHS/Hospital Number
        if details.get("nhs_number") and hasattr(self, 'hospital_number') and self.hospital_number:
            if not self.hospital_number.text().strip():
                self.hospital_number.setText(details["nhs_number"])
                print(f"[MOJ-LEAVE] Set hospital number: {details['nhs_number']}")

        # Hospital Name
        if details.get("hospital") and hasattr(self, 'hospital_name') and self.hospital_name:
            if not self.hospital_name.text().strip():
                self.hospital_name.setText(details["hospital"])
                print(f"[MOJ-LEAVE] Set hospital name: {details['hospital']}")

        # Ward
        if details.get("ward") and hasattr(self, 'ward') and self.ward:
            if not self.ward.text().strip():
                self.ward.setText(details["ward"])
                print(f"[MOJ-LEAVE] Set ward: {details['ward']}")

        # MHA Section
        if details.get("mha_section") and hasattr(self, 'mha_section') and self.mha_section:
            if not self.mha_section.currentText().strip():
                mha = details["mha_section"]
                idx = self.mha_section.findText(mha)
                if idx >= 0:
                    self.mha_section.setCurrentIndex(idx)
                else:
                    self.mha_section.setCurrentText(mha)
                print(f"[MOJ-LEAVE] Set MHA section: {mha}")

        # Gender
        if details.get("gender") and hasattr(self, 'gender_male') and self.gender_male:
            if not (self.gender_male.isChecked() or self.gender_female.isChecked() or self.gender_other.isChecked()):
                if details["gender"] == "Male":
                    self.gender_male.setChecked(True)
                elif details["gender"] == "Female":
                    self.gender_female.setChecked(True)
                print(f"[MOJ-LEAVE] Set gender: {details['gender']}")

                # IMPORTANT: Manually trigger all preview updates since setChecked doesn't emit buttonClicked
                self._update_all_previews_for_gender()
        elif details.get("gender"):
            # Gender was already set, but still update previews
            self._update_all_previews_for_gender()

        # ICD-10 Diagnoses (in mental disorder popup)
        if details.get("diagnoses") and hasattr(self, 'popup_dx_combos') and self.popup_dx_combos:
            diagnoses = details["diagnoses"]
            for i, combo in enumerate(self.popup_dx_combos):
                if i < len(diagnoses) and not combo.currentText().strip():
                    diag = diagnoses[i]
                    # Try to find exact match in combo items
                    idx = combo.findText(diag, Qt.MatchFlag.MatchExactly)
                    if idx >= 0:
                        combo.setCurrentIndex(idx)
                    else:
                        # Try partial match
                        idx = combo.findText(diag, Qt.MatchFlag.MatchContains)
                        if idx >= 0:
                            combo.setCurrentIndex(idx)
                        else:
                            combo.setCurrentText(diag)
                    print(f"[MOJ-LEAVE] Set diagnosis {i+1}: {diag}")

        # Exacerbating Factors (in mental disorder popup)
        if details.get("factors") and hasattr(self, 'exacerbating_factors') and self.exacerbating_factors:
            factors = details["factors"]
            for factor_name, checkbox in self.exacerbating_factors.items():
                if factor_name in factors:
                    checkbox.setChecked(True)
                    print(f"[MOJ-LEAVE] Checked factor: {factor_name}")

        # Mental State Slider (in mental disorder popup)
        if details.get("mental_state") is not None and hasattr(self, 'mental_state_slider') and self.mental_state_slider:
            ms_value = details["mental_state"]
            self.mental_state_slider.setValue(ms_value)
            ms_options = getattr(self, 'mental_state_options', ["Stable", "Minor", "Moderate", "Significant", "Severe"])
            ms_label = ms_options[ms_value] if 0 <= ms_value < len(ms_options) else str(ms_value)
            print(f"[MOJ-LEAVE] Set mental state slider: {ms_value} ({ms_label})")

        # Insight Slider (in mental disorder popup)
        if details.get("insight") is not None and hasattr(self, 'insight_slider') and self.insight_slider:
            insight_value = details["insight"]
            self.insight_slider.setValue(insight_value)
            insight_options = getattr(self, 'insight_options', ["Nil", "Some", "Partial", "Moderate", "Good", "Full"])
            insight_label = insight_options[insight_value] if 0 <= insight_value < len(insight_options) else str(insight_value)
            print(f"[MOJ-LEAVE] Set insight slider: {insight_value} ({insight_label})")

        # Observation Level Dropdown (in mental disorder popup)
        if details.get("observation_level") and hasattr(self, 'observations_dropdown') and self.observations_dropdown:
            obs_level = details["observation_level"]
            idx = self.observations_dropdown.findText(obs_level)
            if idx >= 0:
                self.observations_dropdown.setCurrentIndex(idx)
                print(f"[MOJ-LEAVE] Set observation level: {obs_level}")
            else:
                print(f"[MOJ-LEAVE] Observation level '{obs_level}' not found in dropdown")

        # Physical Health Impact Slider (in mental disorder popup)
        if details.get("phys_impact") is not None and hasattr(self, 'phys_impact_slider') and self.phys_impact_slider:
            phys_value = details["phys_impact"]
            self.phys_impact_slider.setValue(phys_value)
            phys_options = getattr(self, 'phys_impact_options', ["Minimal", "Mild", "Some", "Moderate", "Significant", "High"])
            phys_label = phys_options[phys_value] if 0 <= phys_value < len(phys_options) else str(phys_value)
            print(f"[MOJ-LEAVE] Set physical health impact slider: {phys_value} ({phys_label})")

        # 4d Attitude & Behaviour fields
        attitude = details.get("attitude", {})
        if attitude:
            # Ward rules dropdown
            if attitude.get("ward_rules") and hasattr(self, 'ward_rules_combo') and self.ward_rules_combo:
                idx = self.ward_rules_combo.findText(attitude["ward_rules"])
                if idx >= 0:
                    self.ward_rules_combo.setCurrentIndex(idx)
                    print(f"[MOJ-LEAVE] Set ward rules: {attitude['ward_rules']}")

            # Conflict dropdown
            if attitude.get("conflict") and hasattr(self, 'conflict_combo') and self.conflict_combo:
                idx = self.conflict_combo.findText(attitude["conflict"])
                if idx >= 0:
                    self.conflict_combo.setCurrentIndex(idx)
                    print(f"[MOJ-LEAVE] Set conflict: {attitude['conflict']}")

            # Staff relationship slider
            if attitude.get("staff_relationship") is not None and hasattr(self, 'relationship_levels'):
                self.relationship_levels["staff"] = attitude["staff_relationship"]
                # Update slider if staff is currently selected
                if hasattr(self, 'rel_radios') and self.rel_radios.get("staff", {}).isChecked():
                    if hasattr(self, 'rel_level_slider'):
                        self.rel_level_slider.setValue(attitude["staff_relationship"])
                print(f"[MOJ-LEAVE] Set staff relationship: {attitude['staff_relationship']}")

            # Peers relationship slider
            if attitude.get("peers_relationship") is not None and hasattr(self, 'relationship_levels'):
                self.relationship_levels["peers"] = attitude["peers_relationship"]
                print(f"[MOJ-LEAVE] Set peers relationship: {attitude['peers_relationship']}")

            # OT engagement slider
            if attitude.get("ot_engagement") is not None and hasattr(self, 'eng_ot_slider') and self.eng_ot_slider:
                self.eng_ot_slider.setValue(attitude["ot_engagement"])
                print(f"[MOJ-LEAVE] Set OT engagement: {attitude['ot_engagement']}")

            # Psychology engagement slider
            if attitude.get("psych_engagement") is not None and hasattr(self, 'eng_psych_slider') and self.eng_psych_slider:
                self.eng_psych_slider.setValue(attitude["psych_engagement"])
                print(f"[MOJ-LEAVE] Set psychology engagement: {attitude['psych_engagement']}")

            # OT groups checkboxes
            ot_groups = attitude.get("ot_groups", [])
            if ot_groups and hasattr(self, 'eng_ot_checkboxes') and self.eng_ot_checkboxes:
                for group_key in ot_groups:
                    if group_key in self.eng_ot_checkboxes:
                        self.eng_ot_checkboxes[group_key].setChecked(True)
                        print(f"[MOJ-LEAVE] Checked OT group: {group_key}")

            # Psychology session checkboxes
            psych_sessions = attitude.get("psych_sessions", [])
            if psych_sessions and hasattr(self, 'eng_psych_checkboxes') and self.eng_psych_checkboxes:
                for session_key in psych_sessions:
                    if session_key in self.eng_psych_checkboxes:
                        self.eng_psych_checkboxes[session_key].setChecked(True)
                        print(f"[MOJ-LEAVE] Checked psychology session: {session_key}")

            # Behaviour items (Yes/No radio buttons)
            behaviour_keys = [
                "verbal_physical", "substance_abuse", "self_harm", "fire_setting",
                "intimidation", "secretive", "subversive", "sexually_disinhibited",
                "extremist", "seclusion"
            ]
            if hasattr(self, 'behaviour_items') and self.behaviour_items:
                for bkey in behaviour_keys:
                    value = attitude.get(bkey)
                    if value is not None and bkey in self.behaviour_items:
                        item = self.behaviour_items[bkey]
                        if value:  # True = Yes
                            item["yes"].setChecked(True)
                        else:  # False = No
                            item["no"].setChecked(True)
                        print(f"[MOJ-LEAVE] Set behaviour '{bkey}': {'Yes' if value else 'No'}")

            # Understanding (apply to ALL treatment rows)
            if attitude.get("understanding") and hasattr(self, 'att_treatments') and self.att_treatments:
                understanding_val = attitude["understanding"]
                for treat_key, treat_widgets in self.att_treatments.items():
                    combo = treat_widgets["understanding"]
                    idx = combo.findText(understanding_val)
                    if idx >= 0:
                        combo.setCurrentIndex(idx)
                print(f"[MOJ-LEAVE] Set understanding for all treatments: {understanding_val}")

            # Compliance (apply to ALL treatment rows)
            if attitude.get("compliance") and hasattr(self, 'att_treatments') and self.att_treatments:
                compliance_val = attitude["compliance"]
                for treat_key, treat_widgets in self.att_treatments.items():
                    combo = treat_widgets["compliance"]
                    idx = combo.findText(compliance_val)
                    if idx >= 0:
                        combo.setCurrentIndex(idx)
                print(f"[MOJ-LEAVE] Set compliance for all treatments: {compliance_val}")

        # Populate 4d Imported Data section with evidence
        # Only populate if no filtered entries already exist (otherwise we'd overwrite the full 1-year data)
        attitude_evidence = details.get("attitude_evidence", [])
        if attitude_evidence and hasattr(self, 'att_import_entries_layout') and self.att_import_entries_layout:
            if not hasattr(self, 'att_import_checkboxes') or not self.att_import_checkboxes:
                self._populate_4d_evidence(attitude_evidence)

        # ================================================================
        # PREFILL STABILISING / DESTABILISING FACTORS FROM SECTION 1 DATA
        # ================================================================
        factors = details.get("factors", [])
        attitude = details.get("attitude", {})

        # Compute stabilising/destabilising and store for later (popup may not exist yet)
        if factors:
            print(f"[MOJ-LEAVE] Prefilling stabilising/destabilising from factors: {factors}")

            # Map historical factors to stab/destab keys
            FACTOR_TO_KEY = {
                "Alcohol": "substance",
                "Substance misuse": "substance",
                "Personal relationships": "relationships",
                "Family stress": "family",
                "Non-compliance": "compliance",
                "Physical health": "physical",
                "Financial": "financial",
            }

            # Historical factors ALWAYS go to destabilising (what caused the index offence)
            # Current status determines if they are NOW also stabilising (managed)
            stabilising = []
            destabilising = []

            for factor in factors:
                key = FACTOR_TO_KEY.get(factor)
                if not key:
                    continue

                # ALL historical factors go to destabilising (they were problematic)
                destabilising.append(key)
                print(f"[MOJ-LEAVE] {factor} → {key}: DESTABILISING (historical factor)")

                # Check current status - if now managed, ALSO add to stabilising
                if key == "substance":
                    if attitude.get("substance_abuse") is False:
                        stabilising.append(key)
                        print(f"[MOJ-LEAVE] {factor} → {key}: ALSO STABILISING (no current abuse)")

                elif key == "compliance":
                    if attitude.get("compliance") == "full":
                        stabilising.append(key)
                        print(f"[MOJ-LEAVE] {factor} → {key}: ALSO STABILISING (full compliance)")

                elif key == "relationships":
                    staff_rel = attitude.get("staff_relationship", 2)
                    peers_rel = attitude.get("peers_relationship", 2)
                    if staff_rel >= 2 and peers_rel >= 2:
                        stabilising.append(key)
                        print(f"[MOJ-LEAVE] {factor} → {key}: ALSO STABILISING (good relationships)")

                elif key == "physical":
                    phys_impact = details.get("phys_impact")
                    if not phys_impact or phys_impact < 3:
                        stabilising.append(key)
                        print(f"[MOJ-LEAVE] {factor} → {key}: ALSO STABILISING (managed)")

                # family and financial stay destabilising only (no current status check)

            # Check MHA provision - if set, it's stabilising
            mha = details.get("mha_section")
            if mha and mha.strip():
                stabilising.append("mha")
                print(f"[MOJ-LEAVE] MHA section ({mha}) → STABILISING")

            # Store computed data for when popup is created
            self._extracted_stab_destab = {
                "stabilising": stabilising,
                "destabilising": destabilising
            }
            print(f"[MOJ-LEAVE] Stored stab/destab: {len(stabilising)} stabilising, {len(destabilising)} destabilising")

            # Apply now if popup exists, otherwise will be applied when popup is created
            self._apply_stab_destab_prefill()

        # Update all previews with correct pronouns after import
        print(f"[MOJ-LEAVE] Updating all previews after import...")
        if hasattr(self, '_update_mha_preview'):
            try:
                self._update_mha_preview()
            except Exception as e:
                print(f"[MOJ-LEAVE] Error updating MHA preview: {e}")
        if hasattr(self, '_update_mental_disorder_preview'):
            try:
                self._update_mental_disorder_preview()
            except Exception as e:
                print(f"[MOJ-LEAVE] Error updating mental disorder preview: {e}")
        if hasattr(self, '_update_attitude_behaviour_preview'):
            try:
                self._update_attitude_behaviour_preview()
            except Exception as e:
                print(f"[MOJ-LEAVE] Error updating attitude preview: {e}")
        if hasattr(self, '_update_risk_preview'):
            try:
                self._update_risk_preview()
            except Exception as e:
                print(f"[MOJ-LEAVE] Error updating risk preview: {e}")
        if hasattr(self, '_update_risk_factors_preview'):
            try:
                self._update_risk_factors_preview()
            except Exception as e:
                print(f"[MOJ-LEAVE] Error updating risk factors preview: {e}")

        # ================================================================
        # 4G: INDEX OFFENCE WORK SLIDER
        # ================================================================
        if details.get("index_offence_work") is not None and hasattr(self, 'psych_index_slider') and self.psych_index_slider:
            io_value = details["index_offence_work"]
            self.psych_index_slider.setValue(io_value)
            io_options = getattr(self, 'psych_index_options', ["None", "Considering", "Starting", "Engaging", "Well Engaged", "Almost Complete", "Complete"])
            io_label = io_options[io_value] if 0 <= io_value < len(io_options) else str(io_value)
            print(f"[MOJ-LEAVE] 4g: Set index offence work slider: {io_value} ({io_label})")

            # Also update the label if it exists
            if hasattr(self, 'psych_index_label') and self.psych_index_label:
                self.psych_index_label.setText(io_label)

            # Update psychology preview
            if hasattr(self, '_update_psychology_preview'):
                try:
                    self._update_psychology_preview()
                except Exception as e:
                    print(f"[MOJ-LEAVE] Error updating psychology preview: {e}")
        else:
            # Store for later when popup is created
            if details.get("index_offence_work") is not None:
                self._extracted_index_offence_work = details["index_offence_work"]
                print(f"[MOJ-LEAVE] 4g: Stored index offence work value for later: {details['index_offence_work']}")

        # ================================================================
        # 4G SECTION 2: INSIGHT, RESPONSIBILITY, EMPATHY SLIDERS
        # ================================================================
        # Insight into offending slider
        if details.get("offend_insight") is not None and hasattr(self, 'psych_offend_insight_slider') and self.psych_offend_insight_slider:
            insight_val = details["offend_insight"]
            self.psych_offend_insight_slider.setValue(insight_val)
            insight_opts = getattr(self, 'psych_offend_insight_options', ["Nil", "Limited", "Partial", "Good", "Full"])
            insight_label = insight_opts[insight_val] if 0 <= insight_val < len(insight_opts) else str(insight_val)
            print(f"[MOJ-LEAVE] 4g-s2: Set insight into offending slider: {insight_val} ({insight_label})")
            if hasattr(self, 'psych_offend_insight_label') and self.psych_offend_insight_label:
                self.psych_offend_insight_label.setText(insight_label)
        else:
            if details.get("offend_insight") is not None:
                self._extracted_offend_insight = details["offend_insight"]
                print(f"[MOJ-LEAVE] 4g-s2: Stored insight into offending value for later: {details['offend_insight']}")

        # Accepts responsibility slider
        if details.get("responsibility") is not None and hasattr(self, 'psych_responsibility_slider') and self.psych_responsibility_slider:
            resp_val = details["responsibility"]
            self.psych_responsibility_slider.setValue(resp_val)
            resp_opts = getattr(self, 'psych_responsibility_options', ["Denies", "Minimises", "Partial", "Mostly", "Full"])
            resp_label = resp_opts[resp_val] if 0 <= resp_val < len(resp_opts) else str(resp_val)
            print(f"[MOJ-LEAVE] 4g-s2: Set responsibility slider: {resp_val} ({resp_label})")
            if hasattr(self, 'psych_responsibility_label') and self.psych_responsibility_label:
                self.psych_responsibility_label.setText(resp_label)
        else:
            if details.get("responsibility") is not None:
                self._extracted_responsibility = details["responsibility"]
                print(f"[MOJ-LEAVE] 4g-s2: Stored responsibility value for later: {details['responsibility']}")

        # Victim empathy slider
        if details.get("victim_empathy") is not None and hasattr(self, 'psych_empathy_slider') and self.psych_empathy_slider:
            empathy_val = details["victim_empathy"]
            self.psych_empathy_slider.setValue(empathy_val)
            empathy_opts = getattr(self, 'psych_empathy_options', ["Nil", "Limited", "Developing", "Good", "Full"])
            empathy_label = empathy_opts[empathy_val] if 0 <= empathy_val < len(empathy_opts) else str(empathy_val)
            print(f"[MOJ-LEAVE] 4g-s2: Set victim empathy slider: {empathy_val} ({empathy_label})")
            if hasattr(self, 'psych_empathy_label') and self.psych_empathy_label:
                self.psych_empathy_label.setText(empathy_label)
        else:
            if details.get("victim_empathy") is not None:
                self._extracted_victim_empathy = details["victim_empathy"]
                print(f"[MOJ-LEAVE] 4g-s2: Stored victim empathy value for later: {details['victim_empathy']}")

        # Update psychology preview if any Section 2 values were set
        if any(details.get(k) is not None for k in ["offend_insight", "responsibility", "victim_empathy"]):
            if hasattr(self, '_update_psychology_preview'):
                try:
                    self._update_psychology_preview()
                except Exception as e:
                    print(f"[MOJ-LEAVE] Error updating psychology preview after Section 2: {e}")

        # ================================================================
        # 4G SECTION 3: ATTITUDES TO RISK FACTORS
        # ================================================================
        risk_attitudes = details.get("risk_attitudes", {})
        if risk_attitudes and hasattr(self, 'psych_risk_factors') and self.psych_risk_factors:
            attitude_options = ["Avoids", "Limited understanding", "Some understanding", "Good understanding", "Fully understands"]
            for rf_key, rf_data in risk_attitudes.items():
                if rf_key in self.psych_risk_factors:
                    rf_widgets = self.psych_risk_factors[rf_key]
                    # Check the checkbox
                    if rf_data.get("checked"):
                        rf_widgets["checkbox"].setChecked(True)
                    # Set the slider value
                    attitude_val = rf_data.get("attitude", 2)
                    rf_widgets["slider"].setValue(attitude_val)
                    rf_widgets["slider_label"].setText(attitude_options[attitude_val] if 0 <= attitude_val < len(attitude_options) else str(attitude_val))
                    print(f"[MOJ-LEAVE] 4g-s3: Set {rf_key} checkbox and attitude slider: {attitude_val}")
        else:
            if risk_attitudes:
                self._extracted_risk_attitudes = risk_attitudes
                print(f"[MOJ-LEAVE] 4g-s3: Stored {len(risk_attitudes)} risk attitudes for later")

        # ================================================================
        # 4G SECTION 4: TREATMENT FOR RISK FACTORS
        # ================================================================
        treatments = details.get("treatments", {})
        if treatments:
            self._extracted_treatments = treatments
            print(f"[MOJ-LEAVE] 4g-s4: Stored treatments for later application")
            # Note: Treatment widgets are per-risk and dynamic, applied when popup opens

        # ================================================================
        # 4G SECTION 5: RELAPSE PREVENTION SLIDER
        # ================================================================
        if details.get("relapse_prevention") is not None and hasattr(self, 'psych_relapse_slider') and self.psych_relapse_slider:
            relapse_val = details["relapse_prevention"]
            self.psych_relapse_slider.setValue(relapse_val)
            relapse_opts = getattr(self, 'psych_relapse_options', ["Not started", "Just started", "Ongoing", "Significant progression", "Almost completed", "Completed"])
            relapse_label = relapse_opts[relapse_val] if 0 <= relapse_val < len(relapse_opts) else str(relapse_val)
            print(f"[MOJ-LEAVE] 4g-s5: Set relapse prevention slider: {relapse_val} ({relapse_label})")
            if hasattr(self, 'psych_relapse_label') and self.psych_relapse_label:
                self.psych_relapse_label.setText(relapse_label)
        else:
            if details.get("relapse_prevention") is not None:
                self._extracted_relapse = details["relapse_prevention"]
                print(f"[MOJ-LEAVE] 4g-s5: Stored relapse prevention value for later: {details['relapse_prevention']}")

        # ================================================================
        # 4G SECTION 6: CURRENT ENGAGEMENT CHECKBOXES
        # ================================================================
        current_engagement = details.get("current_engagement", {})
        if current_engagement and hasattr(self, 'psych_engagement_checkboxes') and self.psych_engagement_checkboxes:
            for eng_key, is_engaged in current_engagement.items():
                if eng_key in self.psych_engagement_checkboxes and is_engaged:
                    self.psych_engagement_checkboxes[eng_key].setChecked(True)
                    print(f"[MOJ-LEAVE] 4g-s6: Checked engagement: {eng_key}")
        else:
            if current_engagement:
                self._extracted_engagement = current_engagement
                print(f"[MOJ-LEAVE] 4g-s6: Stored {len(current_engagement)} engagement items for later")

        # ================================================================
        # 4G SECTION 7: OUTSTANDING NEEDS CHECKBOXES
        # ================================================================
        outstanding_needs = details.get("outstanding_needs", {})
        if outstanding_needs and hasattr(self, 'psych_outstanding_checkboxes') and self.psych_outstanding_checkboxes:
            for need_key, is_needed in outstanding_needs.items():
                if need_key in self.psych_outstanding_checkboxes and is_needed:
                    self.psych_outstanding_checkboxes[need_key].setChecked(True)
                    print(f"[MOJ-LEAVE] 4g-s7: Checked outstanding need: {need_key}")
        else:
            if outstanding_needs:
                self._extracted_outstanding = outstanding_needs
                print(f"[MOJ-LEAVE] 4g-s7: Stored {len(outstanding_needs)} outstanding needs for later")

        # Update psychology preview if any Section 3-7 values were set
        if any([risk_attitudes, treatments, details.get("relapse_prevention"), current_engagement, outstanding_needs]):
            if hasattr(self, '_update_psychology_preview'):
                try:
                    self._update_psychology_preview()
                except Exception as e:
                    print(f"[MOJ-LEAVE] Error updating psychology preview after Sections 3-7: {e}")

        # ================================================================
        # SECTION 5: MAPPA APPLICATION
        # ================================================================
        # Apply MAPPA data if it was extracted from index offence
        mappa_eligible = details.get("mappa_eligible")
        mappa_category = details.get("mappa_category")
        mappa_level = details.get("mappa_level")

        if mappa_eligible is not None:
            print(f"[MOJ-LEAVE] 5: Applying MAPPA data - eligible={mappa_eligible}, category={mappa_category}, level={mappa_level}")

            # Check if MAPPA popup widgets exist
            if hasattr(self, 'mappa_eligible_yes') and self.mappa_eligible_yes:
                if mappa_eligible:
                    self.mappa_eligible_yes.setChecked(True)
                    print(f"[MOJ-LEAVE] 5: Set MAPPA eligible = Yes")

                    # Show details container
                    if hasattr(self, 'mappa_details_container') and self.mappa_details_container:
                        self.mappa_details_container.setVisible(True)

                    # Apply category
                    if mappa_category and hasattr(self, 'mappa_categories') and self.mappa_categories:
                        cat_key = f"Category {mappa_category}"
                        if cat_key in self.mappa_categories:
                            self.mappa_categories[cat_key].setChecked(True)
                            print(f"[MOJ-LEAVE] 5: Set MAPPA Category {mappa_category}")

                    # Apply level
                    if mappa_level and hasattr(self, 'mappa_levels') and self.mappa_levels:
                        lvl_key = f"Level {mappa_level}"
                        if lvl_key in self.mappa_levels:
                            self.mappa_levels[lvl_key].setChecked(True)
                            print(f"[MOJ-LEAVE] 5: Set MAPPA Level {mappa_level}")

                    # Show appropriate level container
                    if mappa_level == 1:
                        if hasattr(self, 'mappa_level1_container'):
                            self.mappa_level1_container.setVisible(True)
                        if hasattr(self, 'mappa_level23_container'):
                            self.mappa_level23_container.setVisible(False)
                    elif mappa_level in [2, 3]:
                        if hasattr(self, 'mappa_level1_container'):
                            self.mappa_level1_container.setVisible(False)
                        if hasattr(self, 'mappa_level23_container'):
                            self.mappa_level23_container.setVisible(True)
                else:
                    self.mappa_eligible_no.setChecked(True)
                    print(f"[MOJ-LEAVE] 5: Set MAPPA eligible = No")

                # Update MAPPA preview
                if hasattr(self, '_update_mappa_preview'):
                    try:
                        self._update_mappa_preview()
                    except Exception as e:
                        print(f"[MOJ-LEAVE] Error updating MAPPA preview: {e}")
            else:
                print(f"[MOJ-LEAVE] 5: MAPPA widgets not ready, data will be applied when popup is created")

    def _apply_stab_destab_prefill(self):
        """Apply stored stabilising/destabilising data to checkboxes (called when popup exists)."""
        if not hasattr(self, '_extracted_stab_destab') or not self._extracted_stab_destab:
            return

        if not hasattr(self, 'stab_factors_checkboxes') or not self.stab_factors_checkboxes:
            print(f"[MOJ-LEAVE] Stab/destab: checkboxes not ready yet, will apply when popup is created")
            return

        data = self._extracted_stab_destab
        stabilising = data.get("stabilising", [])
        destabilising = data.get("destabilising", [])

        print(f"[MOJ-LEAVE] Applying stab/destab prefill: {len(stabilising)} stabilising, {len(destabilising)} destabilising")

        # Populate destabilising set first (historical factors)
        if destabilising:
            self._destabilising_factors = set()
            for key in destabilising:
                widgets = self.stab_factors_checkboxes.get(key, {})
                if widgets.get("destab_text"):
                    self._destabilising_factors.add(widgets["destab_text"])
                    print(f"[MOJ-LEAVE] Added destabilising: {widgets['destab_text']}")

        # Populate stabilising set (currently managed factors)
        if stabilising:
            self._stabilising_factors = set()
            for key in stabilising:
                widgets = self.stab_factors_checkboxes.get(key, {})
                if widgets.get("stab_text"):
                    self._stabilising_factors.add(widgets["stab_text"])
                    print(f"[MOJ-LEAVE] Added stabilising: {widgets['stab_text']}")

        # Set radio to stabilising if we have any (handler will check boxes from the set)
        if stabilising:
            self.stabilising_radio.setChecked(True)
        elif destabilising:
            self.destabilising_radio.setChecked(True)

        # Update preview
        if hasattr(self, '_update_risk_factors_preview'):
            self._update_risk_factors_preview()

        # Clear stored data to prevent re-application
        self._extracted_stab_destab = None

    def _populate_4d_evidence(self, evidence_items):
        """Populate the 4d attitude imported data section with evidence items (ASR Section 6 style)."""
        if not hasattr(self, 'att_import_entries_layout'):
            return

        # Clear existing entries
        while self.att_import_entries_layout.count():
            item = self.att_import_entries_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        if not evidence_items:
            no_data_label = QLabel("No evidence items found - using defaults")
            no_data_label.setStyleSheet("font-size: 14px; color: #6b7280; font-style: italic;")
            self.att_import_entries_layout.addWidget(no_data_label)
            return

        # Category colors (matching ASR Section 6)
        CATEGORY_COLORS = {
            "Attitude": "#7c3aed",
            "Relationships": "#0891b2",
            "Engagement": "#059669",
            "Behaviour": "#991b1b",
        }

        # Store checkboxes for filtering
        self.att_evidence_checkboxes = []

        def hex_to_light_bg(hex_color):
            """Convert hex color to a lighter background-friendly version (matching ASR Section 6)."""
            hex_color = hex_color.lstrip('#')
            r, g, b = int(hex_color[0:2], 16), int(hex_color[2:4], 16), int(hex_color[4:6], 16)
            # Lighten by mixing with white (70% white, 30% original)
            r = int(r * 0.3 + 255 * 0.7)
            g = int(g * 0.3 + 255 * 0.7)
            b = int(b * 0.3 + 255 * 0.7)
            return f"#{r:02x}{g:02x}{b:02x}"

        def highlight_keyword(text, keyword, category):
            """Highlight keyword in text with category-colored HTML (matching ASR Section 6)."""
            import html
            if not keyword or not text:
                return html.escape(text).replace('\n', '<br>') if text else ""

            # HTML escape the text first
            escaped = html.escape(text)

            # Get category color and lighten it
            color = CATEGORY_COLORS.get(category, "#6b7280")
            light_color = hex_to_light_bg(color)

            # Case-insensitive replacement
            import re
            pattern = re.compile(re.escape(keyword), re.IGNORECASE)
            escaped = pattern.sub(
                lambda m: f'<span style="background-color: {light_color}; font-weight: 600;">{m.group()}</span>',
                escaped
            )

            # Convert newlines to <br> for proper display
            escaped = escaped.replace('\n', '<br>')
            return escaped

        def filter_by_category(cat):
            """Toggle filter entries by category."""
            self._filter_4d_evidence(cat)

        # Track current filter
        self._att_current_filter = None

        # Create entry widgets (4A style - white rounded container, toggle left, checkbox right)
        for item in evidence_items:
            cat = item.get("category", "Other")
            color = CATEGORY_COLORS.get(cat, "#6b7280")
            field = item.get("field", "")
            value = item.get("value", "")
            evidence = item.get("evidence", "")
            keyword = item.get("keyword", "")

            # Create entry frame (4A style)
            entry_frame = QFrame()
            entry_frame.setObjectName("entryFrame")
            entry_frame.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Maximum)
            entry_frame.setStyleSheet("""
                QFrame#entryFrame {
                    background: rgba(255, 255, 255, 0.95);
                    border: 1px solid rgba(180, 150, 50, 0.4);
                    border-radius: 8px;
                    padding: 4px;
                }
            """)
            entry_layout_v = QVBoxLayout(entry_frame)
            entry_layout_v.setContentsMargins(10, 4, 16, 4)
            entry_layout_v.setSpacing(6)

            # Header row: toggle_btn → category tag → field:value → stretch → checkbox
            header_row = QHBoxLayout()
            header_row.setSpacing(8)

            # Toggle button (left side)
            toggle_btn = QPushButton("\u25b8")
            toggle_btn.setFixedSize(22, 22)
            toggle_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            toggle_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(180, 150, 50, 0.2);
                    border: none;
                    border-radius: 4px;
                    font-size: 15px;
                    font-weight: bold;
                    color: #806000;
                }
                QPushButton:hover { background: rgba(180, 150, 50, 0.35); }
            """)
            header_row.addWidget(toggle_btn)

            # Field: Value label (amber) — before tag
            field_lbl = None
            if field or value:
                field_lbl = QLabel(f"{field}: {value}")
                field_lbl.setStyleSheet("font-size: 15px; font-weight: 600; color: #806000; background: transparent; border: none;")
                field_lbl.setCursor(Qt.CursorShape.PointingHandCursor)
                header_row.addWidget(field_lbl)

            # Category tag button (clickable to filter) — after label
            tag = QPushButton(cat)
            tag.setCursor(Qt.CursorShape.PointingHandCursor)
            tag.setStyleSheet(f"""
                QPushButton {{
                    font-size: 14px; font-weight: 600; color: white;
                    background: {color}; padding: 3px 8px; border-radius: 3px; border: none;
                }}
                QPushButton:hover {{ background: {color}; opacity: 0.8; }}
            """)
            tag.clicked.connect(lambda checked, c=cat: filter_by_category(c))
            header_row.addWidget(tag)

            header_row.addStretch()

            # Checkbox (right side, with margin)
            cb = QCheckBox()
            cb.setFixedSize(20, 20)
            cb.setStyleSheet("""
                QCheckBox { background: transparent; margin-right: 4px; }
                QCheckBox::indicator { width: 18px; height: 18px; }
            """)
            cb.stateChanged.connect(self._update_attitude_behaviour_preview)
            header_row.addWidget(cb)

            entry_layout_v.addLayout(header_row)

            # Body text (hidden by default, with keyword highlighting)
            full_highlighted = highlight_keyword(evidence, keyword, cat)
            body_text = QTextEdit()
            body_text.setHtml(full_highlighted)
            body_text.setReadOnly(True)
            body_text.setFrameShape(QFrame.Shape.NoFrame)
            body_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            body_text.setStyleSheet("""
                QTextEdit {
                    font-size: 15px;
                    color: #333;
                    background: rgba(255, 248, 220, 0.5);
                    border: none;
                    padding: 8px;
                    border-radius: 6px;
                }
            """)
            body_text.document().setTextWidth(body_text.viewport().width() if body_text.viewport().width() > 0 else 350)
            doc_height = body_text.document().size().height() + 20
            body_text.setFixedHeight(int(max(doc_height, 60)))
            body_text.setVisible(False)
            entry_layout_v.addWidget(body_text)

            # Store category for filtering
            entry_frame._category = cat

            # Toggle function
            def make_toggle(btn, body, frame):
                def toggle():
                    is_visible = body.isVisible()
                    body.setVisible(not is_visible)
                    btn.setText("\u25be" if not is_visible else "\u25b8")
                    frame.updateGeometry()
                return toggle

            toggle_fn = make_toggle(toggle_btn, body_text, entry_frame)
            toggle_btn.clicked.connect(toggle_fn)
            if field or value:
                field_lbl.mousePressEvent = lambda e, fn=toggle_fn: fn()

            self.att_import_entries_layout.addWidget(entry_frame)
            self.att_evidence_checkboxes.append((cb, entry_frame, item))

        # Expand the imported data section to show evidence
        if hasattr(self, 'att_import_container'):
            self.att_import_container.setVisible(True)
            if hasattr(self, 'att_import_arrow'):
                self.att_import_arrow.setText("▾")

        print(f"[MOJ-LEAVE] Populated 4d evidence section with {len(evidence_items)} items")

    def _filter_4d_evidence(self, category):
        """Toggle filter 4d evidence items by category. Click same category again to show all."""
        if not hasattr(self, 'att_evidence_checkboxes'):
            return

        # Toggle filter: if already filtering by this category, show all
        if hasattr(self, '_att_current_filter') and self._att_current_filter == category:
            # Clear filter - show all
            self._att_current_filter = None
            for cb, frame, item in self.att_evidence_checkboxes:
                frame.setVisible(True)
            print(f"[MOJ-LEAVE] 4d filter cleared - showing all")
        else:
            # Apply filter - show only this category
            self._att_current_filter = category
            for cb, frame, item in self.att_evidence_checkboxes:
                frame.setVisible(item.get("category") == category)
            print(f"[MOJ-LEAVE] 4d filtered to: {category}")

    def _on_data_extracted(self, panel_data: dict):
        """Handle extracted data - insert into text fields and populate import sections."""
        categories = panel_data.get("categories", {})

        # Skip if this exact data was already processed (prevents reprocessing on navigation)
        cat_keys = tuple(sorted(categories.keys())) if categories else ()
        cat_count = sum(len(v.get("items", [])) if isinstance(v, dict) else 0 for v in categories.values())
        content_sig = (cat_keys, cat_count)
        if self._data_processed_id == content_sig:
            print(f"[MOJ-LEAVE] Skipping _on_data_extracted - data already processed ({len(categories)} categories, {cat_count} items)")
            return
        self._data_processed_id = content_sig

        print(f"[MOJ-LEAVE] Processing {len(categories)} categories: {list(categories.keys())}")

        # ================================================================
        # EXTRACT PATIENT NAME AND DOB FROM DOCUMENT TEXT
        # ================================================================
        self._extract_patient_details_from_data()

        # Populate 4a Past Psychiatric History imports from categorized data (like history extractor)
        psych_items = []
        # Match by key OR name - data extractor uses various formats
        PSYCH_MATCHES = {
            "Past Psychiatric History", "Psychiatric History", "PAST_PSYCH",
            "past_psych", "past psychiatric history", "psychiatric history"
        }
        for cat_key, cat_data in categories.items():
            cat_name = cat_data.get("name", "") if isinstance(cat_data, dict) else ""
            # Check both the key and the name field
            key_lower = cat_key.lower() if isinstance(cat_key, str) else ""
            name_lower = cat_name.lower() if isinstance(cat_name, str) else ""

            if (cat_key in PSYCH_MATCHES or cat_name in PSYCH_MATCHES or
                key_lower in {m.lower() for m in PSYCH_MATCHES} or
                name_lower in {m.lower() for m in PSYCH_MATCHES}):
                items = cat_data.get("items", []) if isinstance(cat_data, dict) else []
                for item in items:
                    text = item.get("text", "")
                    if text:
                        psych_items.append({
                            "text": text,
                            "body": text,
                            "date": item.get("date"),
                            "source": item.get("source", {})
                        })
                print(f"[MOJ-LEAVE] Found {len(items)} psych items from key='{cat_key}' name='{cat_name}'")

        # Store psych items for later (in case popup not created yet)
        self._extracted_psych_items = psych_items

        if psych_items:
            # Try to populate if popup exists
            if hasattr(self, 'psych_import_layout') and self.psych_import_layout:
                self._populate_psych_imports_from_categorized(psych_items)
                print(f"[MOJ-LEAVE] Populated 4a psych imports with {len(psych_items)} categorized items")
            else:
                print(f"[MOJ-LEAVE] Stored {len(psych_items)} psych items (popup not created yet)")
        else:
            print(f"[MOJ-LEAVE] No Past Psychiatric History items found in categories")

        # Run 4a timeline analysis if raw notes available
        if hasattr(self, '_extracted_raw_notes') and self._extracted_raw_notes:
            if hasattr(self, '_4a_detected_table'):
                self._run_4a_timeline_analysis(self._extracted_raw_notes)
                print(f"[MOJ-LEAVE] Ran 4a timeline analysis with {len(self._extracted_raw_notes)} raw notes")
            else:
                print(f"[MOJ-LEAVE] 4a popup not created yet - timeline analysis will run when popup opens")

        # Populate 4b Forensic History imports from categorized data
        forensic_items = []
        FORENSIC_MATCHES = {
            "Forensic History", "FORENSIC", "forensic_history", "forensic history",
            "Index Offence", "index offence", "Offending History", "offending history"
        }
        for cat_key, cat_data in categories.items():
            cat_name = cat_data.get("name", "") if isinstance(cat_data, dict) else ""
            key_lower = cat_key.lower() if isinstance(cat_key, str) else ""
            name_lower = cat_name.lower() if isinstance(cat_name, str) else ""

            if (cat_key in FORENSIC_MATCHES or cat_name in FORENSIC_MATCHES or
                key_lower in {m.lower() for m in FORENSIC_MATCHES} or
                name_lower in {m.lower() for m in FORENSIC_MATCHES}):
                items = cat_data.get("items", []) if isinstance(cat_data, dict) else []
                for item in items:
                    text = item.get("text", "")
                    if text:
                        forensic_items.append({
                            "text": text,
                            "body": text,
                            "date": item.get("date"),
                            "source": item.get("source", {})
                        })
                print(f"[MOJ-LEAVE] Found {len(items)} forensic items from key='{cat_key}' name='{cat_name}'")

        # Store forensic items for later (in case popup not created yet)
        self._extracted_forensic_items = forensic_items

        if forensic_items:
            # Try to populate if popup exists
            if hasattr(self, 'forensic_import_layout') and self.forensic_import_layout:
                self._populate_forensic_imports_from_categorized(forensic_items)
                print(f"[MOJ-LEAVE] Populated 4b forensic imports with {len(forensic_items)} categorized items")
            else:
                print(f"[MOJ-LEAVE] Stored {len(forensic_items)} forensic items (popup not created yet)")
        else:
            print(f"[MOJ-LEAVE] No Forensic History items found in categories")

        # Populate 4c Mental Disorder imports from categorized data (HPC, Mental State, Diagnosis)
        # Items containing progress/behaviour/capacity/insight keywords go to 4d instead
        mental_disorder_items = []
        attitude_categorized_items = []  # Items that should go to 4d
        MENTAL_DISORDER_MATCHES = {
            "History of Presenting Complaint", "HPC", "HISTORY_PRESENTING",
            "Mental State", "Mental State Examination", "MENTAL_STATE",
            "Diagnosis", "DIAGNOSIS", "Summary", "SUMMARY"
        }
        # Keywords that indicate item should go to 4d Attitude & Behaviour
        ATTITUDE_KEYWORDS = ["progress", "behaviour", "behavior", "capacity", "insight", "attitude"]

        for cat_key, cat_data in categories.items():
            cat_name = cat_data.get("name", "") if isinstance(cat_data, dict) else ""
            key_lower = cat_key.lower() if isinstance(cat_key, str) else ""
            name_lower = cat_name.lower() if isinstance(cat_name, str) else ""

            if (cat_key in MENTAL_DISORDER_MATCHES or cat_name in MENTAL_DISORDER_MATCHES or
                key_lower in {m.lower() for m in MENTAL_DISORDER_MATCHES} or
                name_lower in {m.lower() for m in MENTAL_DISORDER_MATCHES}):
                items = cat_data.get("items", []) if isinstance(cat_data, dict) else []
                for item in items:
                    text = item.get("text", "")
                    if text:
                        text_lower = text.lower()
                        # Check if this item should go to 4d instead
                        if any(kw in text_lower for kw in ATTITUDE_KEYWORDS):
                            attitude_categorized_items.append({
                                "text": text,
                                "body": text,
                                "date": item.get("date"),
                                "source": item.get("source", {}),
                                "category": "Progress/Behaviour"
                            })
                            print(f"[MOJ-LEAVE] Routing item to 4d (contains attitude keywords): {text[:50]}...")
                        else:
                            mental_disorder_items.append({
                                "text": text,
                                "body": text,
                                "date": item.get("date"),
                                "source": item.get("source", {})
                            })
                print(f"[MOJ-LEAVE] Found {len(items)} items from key='{cat_key}' name='{cat_name}' (4c: {len(mental_disorder_items)}, 4d: {len(attitude_categorized_items)})")

        # Store mental disorder items for later (in case popup not created yet)
        self._extracted_mental_disorder_items = mental_disorder_items

        if mental_disorder_items:
            if hasattr(self, 'mental_disorder_import_layout') and self.mental_disorder_import_layout:
                self._populate_mental_disorder_imports(mental_disorder_items)
                print(f"[MOJ-LEAVE] Populated 4c mental disorder imports with {len(mental_disorder_items)} categorized items")
            else:
                print(f"[MOJ-LEAVE] Stored {len(mental_disorder_items)} mental disorder items (popup not created yet)")
        else:
            print(f"[MOJ-LEAVE] No Mental Disorder items found in categories")

        # Populate 4d Attitude & Behaviour with filtered notes (like ASR Section 6)
        # Also include categorized items routed from 4c (progress/behaviour/capacity/insight)
        raw_notes = []
        if hasattr(self, '_data_extractor') and self._data_extractor:
            raw_notes = getattr(self._data_extractor, 'notes', [])
            if not raw_notes:
                # Try alternate attribute names
                if hasattr(self._data_extractor, '_raw_notes'):
                    raw_notes = self._data_extractor._raw_notes
                elif hasattr(self._data_extractor, '_panel_data_by_dtype'):
                    if self._data_extractor._panel_data_by_dtype.get("notes"):
                        raw_notes = self._data_extractor._panel_data_by_dtype["notes"]

        # Fall back to SharedDataStore if no local notes
        if not raw_notes:
            try:
                from shared_data_store import get_shared_store
                shared_store = get_shared_store()
                if shared_store.has_notes():
                    raw_notes = shared_store.notes
                    print(f"[MOJ-LEAVE] Got {len(raw_notes)} notes from SharedDataStore (global import)")
            except Exception as e:
                print(f"[MOJ-LEAVE] Error getting notes from SharedDataStore: {e}")

        print(f"[MOJ-LEAVE] Raw notes available for 4d Attitude filter: {len(raw_notes)}")
        print(f"[MOJ-LEAVE] Categorized items routed to 4d: {len(attitude_categorized_items)}")
        self._extracted_raw_notes = raw_notes
        self._extracted_attitude_categorized_items = attitude_categorized_items

        if raw_notes or attitude_categorized_items:
            count = self._populate_attitude_filtered_data(raw_notes, attitude_categorized_items)
            print(f"[MOJ-LEAVE] Populated 4d attitude imports with {count} entries")
            # Auto-expand import section if entries found
            if count > 0 and hasattr(self, 'att_import_container'):
                self.att_import_container.setVisible(True)
                if hasattr(self, 'att_import_arrow'):
                    self.att_import_arrow.setText("▾")
        else:
            print(f"[MOJ-LEAVE] No data available for 4d attitude filtering")

        # Populate 4f Medication imports from categorized data or search raw notes
        medication_items = []
        MEDICATION_MATCHES = {
            "Medication", "Medication History", "MEDICATION", "medication_history",
            "Current Medication", "current_medication", "Medications"
        }
        for cat_key, cat_data in categories.items():
            cat_name = cat_data.get("name", "") if isinstance(cat_data, dict) else ""
            key_lower = cat_key.lower() if isinstance(cat_key, str) else ""
            name_lower = cat_name.lower() if isinstance(cat_name, str) else ""

            if (cat_key in MEDICATION_MATCHES or cat_name in MEDICATION_MATCHES or
                key_lower in {m.lower() for m in MEDICATION_MATCHES} or
                name_lower in {m.lower() for m in MEDICATION_MATCHES}):
                items = cat_data.get("items", []) if isinstance(cat_data, dict) else []
                for item in items:
                    text = item.get("text", "")
                    if text:
                        medication_items.append({
                            "text": text,
                            "body": text,
                            "date": item.get("date"),
                            "source": item.get("source", {})
                        })
                print(f"[MOJ-LEAVE] Found {len(items)} medication items from key='{cat_key}' name='{cat_name}'")

        self._extracted_medication_items = medication_items
        print(f"[MOJ-LEAVE] Categorized medication items: {len(medication_items)}, raw notes: {len(raw_notes)}")

        # Build document_text FIRST (before _populate_medication_imports call)
        # CRITICAL: Get the FULL document text from extractor notes (same as _extract_patient_details_from_data)
        # Section 15 ("What is the patient's understanding of...") is in the FULL document, not in categories
        medication_text_parts = []

        # FIRST: Get FULL document text from extractor notes - this is where Section 15 lives
        if hasattr(self, '_data_extractor') and self._data_extractor:
            extractor_notes = getattr(self._data_extractor, 'notes', [])
            if not extractor_notes and hasattr(self._data_extractor, '_raw_notes'):
                extractor_notes = self._data_extractor._raw_notes

            for note in extractor_notes:
                text = note.get("text", "") or note.get("body", "") or note.get("content", "")
                if text:
                    medication_text_parts.append(text)
                    # Log if this contains Section 15
                    if "what is the patient's understanding of" in text.lower():
                        print(f"[MOJ-LEAVE] Found Section 15 in extractor note: {text[:150]}...")

            print(f"[MOJ-LEAVE] Added {len(extractor_notes)} full document notes for Section 15 search")

        # ALSO search categories for medication-specific content
        for cat_key, cat_data in categories.items():
            cat_name = cat_data.get("name", "") if isinstance(cat_data, dict) else ""
            key_lower = cat_key.lower() if isinstance(cat_key, str) else ""
            name_lower = cat_name.lower() if isinstance(cat_name, str) else ""

            # Include Medication-related categories
            include_category = (
                "medication" in key_lower or "medication" in name_lower or
                "insight" in key_lower or "insight" in name_lower or
                "treatment" in key_lower or "treatment" in name_lower or
                "compliance" in key_lower or "compliance" in name_lower or
                "capacity" in key_lower or "capacity" in name_lower
            )

            if include_category:
                if isinstance(cat_data, dict):
                    for item in cat_data.get("items", []):
                        text = item.get("text", "")
                        if text and text not in medication_text_parts:
                            medication_text_parts.append(text)

        document_text = "\n".join(medication_text_parts)
        print(f"[MOJ-LEAVE] Built document text for Section 15 search: {len(document_text)} chars")

        # Check if Section 15 was found
        if "what is the patient's understanding of" in document_text.lower():
            print(f"[MOJ-LEAVE] Section 15 question found in document text!")
        else:
            print(f"[MOJ-LEAVE] WARNING: Section 15 question NOT found in document text")

        # Populate medication imports - NOW with document_text available
        if raw_notes or medication_items:
            count = self._populate_medication_imports(raw_notes, medication_items, document_text)
            print(f"[MOJ-LEAVE] Populated 4f medication imports with {count} entries")
            if count > 0 and hasattr(self, 'med_import_container'):
                self.med_import_container.setVisible(True)
                if hasattr(self, 'med_import_arrow'):
                    self.med_import_arrow.setText("▾")
        else:
            print(f"[MOJ-LEAVE] No data available for 4f medication imports")

        # DEFAULT: Set capacity dropdown to "Has capacity" on import
        # Most patients have capacity unless specifically documented otherwise (T3/Section 58)
        if hasattr(self, 'med_capacity_combo'):
            idx = self.med_capacity_combo.findText("Has capacity")
            if idx >= 0:
                self.med_capacity_combo.setCurrentIndex(idx)
                print(f"[MOJ-LEAVE] 4f: Set capacity dropdown to default 'Has capacity'")
        else:
            # Store for later when popup is created
            self._default_capacity = "Has capacity"

        # Store data for later prefill when popup is created
        self._extracted_document_text = document_text
        self._extracted_raw_notes_for_meds = raw_notes

        if raw_notes or document_text:
            # Try to prefill now if UI exists, otherwise it will be called when popup is created
            if hasattr(self, '_med_entries') and hasattr(self, 'med_entries_layout'):
                self._prefill_medications_from_notes(raw_notes, document_text)
            else:
                print(f"[MOJ-LEAVE] Medication UI not ready - will prefill when popup is opened")
        else:
            print(f"[MOJ-LEAVE] No data available for medication prefill")

        # Update medication preview with current gender pronouns
        if hasattr(self, '_update_medication_preview'):
            self._update_medication_preview()
            print(f"[MOJ-LEAVE] 4f: Updated medication preview with current gender")

        # Populate 4e Risk imports from Risk category (like ASR Section 10)
        risk_items = []
        RISK_MATCHES = {"Risk", "RISK", "risk", "Risk Assessment", "risk_assessment"}
        for cat_key, cat_data in categories.items():
            cat_name = cat_data.get("name", "") if isinstance(cat_data, dict) else ""
            key_lower = cat_key.lower() if isinstance(cat_key, str) else ""
            name_lower = cat_name.lower() if isinstance(cat_name, str) else ""

            if (cat_key in RISK_MATCHES or cat_name in RISK_MATCHES or
                "risk" in key_lower or "risk" in name_lower):
                items = cat_data.get("items", []) if isinstance(cat_data, dict) else []
                for item in items:
                    text = item.get("text", "")
                    if text:
                        risk_items.append({
                            "text": text,
                            "body": text,
                            "date": item.get("date"),
                            "source": item.get("source", {})
                        })
                print(f"[MOJ-LEAVE] Found {len(items)} risk items from key='{cat_key}' name='{cat_name}'")

        # Also include raw_notes for risk searching (like ASR Section 10)
        if raw_notes:
            for note in raw_notes:
                text = note.get("content", "") or note.get("text", "") or note.get("body", "")
                if text:
                    risk_items.append({
                        "text": text,
                        "date": note.get("date") or note.get("datetime"),
                    })

        self._extracted_risk_items = risk_items
        print(f"[MOJ-LEAVE] Total risk items for 4e: {len(risk_items)}")

        if risk_items:
            self._populate_risk_imports(risk_items)
        else:
            print(f"[MOJ-LEAVE] No risk items found for 4e import")

        # ================================================================
        # POPULATE 3g LEAVE REPORT IMPORTS FROM RAW NOTES (last 2 years)
        # ================================================================
        # Store raw notes for leave imports
        self._extracted_raw_notes = raw_notes or []

        if raw_notes:
            print(f"[MOJ-LEAVE] Populating 3g leave report imports from {len(raw_notes)} notes")
            # Ensure leave_report popup is created so widgets exist
            if "leave_report" not in self.popups:
                popup = self._create_popup("leave_report")
                if popup:
                    self.popups["leave_report"] = popup
                    self.popup_stack.addWidget(popup)
                    print(f"[MOJ-LEAVE] Created leave_report popup for leave imports")

            # Now populate leave imports
            self._populate_leave_imports(raw_notes)

            # Show the section
            if hasattr(self, 'leave_import_section'):
                self.leave_import_section.setVisible(True)
        else:
            print(f"[MOJ-LEAVE] No raw notes available for 3g leave imports")

        # Map category names to text widgets
        # NOTE: leave_report_preview is NOT included - it should only be populated
        # from user input fields, not auto-filled from imported data
        CATEGORY_MAP = {
            "Past Psychiatric History": "hospital_admissions",
            "Medication History": "hospital_admissions",
            "Forensic History": "index_offence",
        }

        # Insert extracted data into appropriate text fields
        for cat_key, payload in categories.items():
            if not isinstance(payload, dict):
                continue

            cat_name = payload.get("name", "")
            widget_name = CATEGORY_MAP.get(cat_name)
            if not widget_name:
                continue

            items = payload.get("items", [])
            if not items:
                continue

            # Get the target text widget
            text_widget = getattr(self, widget_name, None)
            if not text_widget:
                continue

            # Check if widget has insertPlainText method (QTextEdit/QPlainTextEdit)
            if not hasattr(text_widget, 'insertPlainText'):
                print(f"[MOJ-LEAVE] Widget '{widget_name}' does not support insertPlainText, skipping")
                continue

            try:
                for item in items:
                    text = (item.get("text") or "").strip()
                    if text:
                        date = item.get("date")
                        if date:
                            if hasattr(date, "strftime"):
                                date_str = date.strftime("%d %b %Y")
                            else:
                                date_str = str(date)
                            text_widget.insertPlainText(f"[{date_str}]\n{text}\n\n")
                        else:
                            text_widget.insertPlainText(text + "\n\n")

                print(f"[MOJ-LEAVE] Inserted {len(items)} items from '{cat_name}'")
            except RuntimeError:
                print(f"[MOJ-LEAVE] Widget '{widget_name}' was deleted, skipping")

        # ================================================================
        # TRIGGER CARD 1 CLICK TO APPLY GENDER PRONOUNS TO ALL SECTIONS
        # ================================================================
        # Click card 1 (patient_details) to ensure gender is applied to all previews
        from PySide6.QtCore import QTimer

        def apply_gender_from_card1():
            print(f"[MOJ-LEAVE] Opening card 1 to apply gender pronouns to all sections")
            # Click on patient_details card to ensure it's created and gender is loaded
            self._on_card_clicked("patient_details")
            # Then update all previews with the gender
            QTimer.singleShot(200, self._update_all_previews_for_gender)

        QTimer.singleShot(300, apply_gender_from_card1)

        # End auto-fill phase after all timers complete (fallback for manual import).
        # Auto-import flow sets _auto_fill_phase=False earlier via _auto_select_imports_and_send_to_card.
        def _end_auto_fill_fallback():
            if self._auto_fill_phase:
                self._auto_fill_phase = False
                print(f"[MOJ-LEAVE] Auto-fill phase complete (fallback timer) — cards locked")
        QTimer.singleShot(6000, _end_auto_fill_fallback)

    # ================================================================
    # EXPORT / CLEAR
    # ================================================================

    def _export_docx(self):
        """Export form to DOCX using original MHCS form as template - fills in answer cells only."""
        try:
            from docx import Document
            import shutil
            import os
        except ImportError:
            QMessageBox.warning(self, "Export Error", "Required modules not available.")
            return

        # Debug: Check card contents before export
        print("[MOJ-LEAVE] Export: Checking card contents...")
        for key, card in self.cards.items():
            text = card.editor.toPlainText()
            print(f"[MOJ-LEAVE] Card '{key}': {len(text)} chars")

        # Path to the template
        template_path = resource_path('templates', 'MHCS_Leave_Application_template.docx')
        if not os.path.exists(template_path):
            QMessageBox.warning(self, "Export Error", f"Template not found at:\n{template_path}")
            return

        # Build default filename: "Patient Name, Date, Time by Author.docx"
        from datetime import datetime
        now = datetime.now()
        date_str = now.strftime("%d-%m-%Y")
        time_str = now.strftime("%H%M")

        # Get patient name
        patient_name = ""
        if hasattr(self, 'patient_name') and self.patient_name:
            patient_name = self.patient_name.text().strip()
        if not patient_name:
            patient_name = "Patient"

        # Get author name (RC name or from my_details)
        author_name = ""
        if hasattr(self, 'rc_name') and self.rc_name:
            author_name = self.rc_name.text().strip()
        if not author_name and hasattr(self, '_my_details') and self._my_details:
            author_name = self._my_details.get("full_name", "")
        if not author_name:
            author_name = "Author"

        # Clean names for filename (remove invalid characters)
        def clean_filename(name):
            invalid_chars = '<>:"/\\|?*'
            for c in invalid_chars:
                name = name.replace(c, '')
            return name.strip()

        patient_name = clean_filename(patient_name)
        author_name = clean_filename(author_name)

        default_filename = f"{patient_name}, {date_str}, {time_str} by {author_name}.docx"

        file_path, _ = QFileDialog.getSaveFileName(
            self, "Export MOJ Leave Form", default_filename, "Word Document (*.docx)"
        )
        if not file_path:
            return

        # Copy template to destination
        shutil.copy(template_path, file_path)

        # Open the copy and fill in the data
        doc = Document(file_path)
        tables = doc.tables
        print(f"[MOJ-LEAVE] Export: Template has {len(tables)} tables")

        # Helper to safely get text from widget
        def get_text(attr_name, is_combo=False, is_date=False, is_textedit=False):
            obj = getattr(self, attr_name, None)
            if obj is None:
                return ""
            if is_combo:
                return obj.currentText()
            if is_date:
                return obj.date().toString("dd/MM/yyyy")
            if is_textedit:
                return obj.toPlainText()
            return obj.text()

        def get_card_text(key):
            content = self.cards.get(key, None)
            text = content.editor.toPlainText() if content else ""
            print(f"[MOJ-LEAVE] get_card_text('{key}'): {len(text)} chars")
            return text

        # Helper to check Word form checkboxes
        def check_checkbox(para, cb_index, check=True):
            """Check or uncheck a checkbox in a paragraph."""
            from docx.oxml.ns import qn
            from docx.oxml import OxmlElement
            checkboxes = para._element.findall('.//' + qn('w:checkBox'))
            if cb_index < len(checkboxes):
                cb = checkboxes[cb_index]
                # Remove existing checked element if present
                for checked_elem in cb.findall(qn('w:checked')):
                    cb.remove(checked_elem)
                # Set default value
                default = cb.find(qn('w:default'))
                if default is not None:
                    default.set(qn('w:val'), '1' if check else '0')
                # Also add checked element for compatibility
                if check:
                    checked_elem = OxmlElement('w:checked')
                    checked_elem.set(qn('w:val'), '1')
                    cb.insert(0, checked_elem)

        # Mark leave type checkboxes in paragraphs 19, 21, 23
        # Structure: Para 19 = Compassionate (day, overnight)
        #           Para 21 = Escorted (day, overnight)
        #           Para 23 = Unescorted (day, overnight)
        leave_cbs = getattr(self, 'leave_type_checkboxes', {})
        if len(doc.paragraphs) > 23:
            # Compassionate - Para 19
            check_checkbox(doc.paragraphs[19], 0, leave_cbs.get('compassionate_day') and leave_cbs['compassionate_day'].isChecked())
            check_checkbox(doc.paragraphs[19], 1, leave_cbs.get('compassionate_overnight') and leave_cbs['compassionate_overnight'].isChecked())
            # Escorted - Para 21
            check_checkbox(doc.paragraphs[21], 0, leave_cbs.get('escorted_day') and leave_cbs['escorted_day'].isChecked())
            check_checkbox(doc.paragraphs[21], 1, leave_cbs.get('escorted_overnight') and leave_cbs['escorted_overnight'].isChecked())
            # Unescorted - Para 23
            check_checkbox(doc.paragraphs[23], 0, leave_cbs.get('unescorted_day') and leave_cbs['unescorted_day'].isChecked())
            check_checkbox(doc.paragraphs[23], 1, leave_cbs.get('unescorted_overnight') and leave_cbs['unescorted_overnight'].isChecked())

        # Fill in tables based on index (0-based)
        # Table 4 [0,1]: Patient name
        if len(tables) > 3:
            patient_name_text = get_text('patient_name')
            print(f"[MOJ-LEAVE] Setting patient name: '{patient_name_text}'")
            tables[3].cell(0, 1).text = patient_name_text

        # Table 5 [0,1]: DOB
        if len(tables) > 4:
            tables[4].cell(0, 1).text = get_text('patient_dob', is_date=True)

        # Table 6 [0,1]: MHCS reference
        if len(tables) > 5:
            tables[5].cell(0, 1).text = get_text('moj_reference')

        # Table 7 [0,1]: Hospital name
        if len(tables) > 6:
            tables[6].cell(0, 1).text = get_text('hospital_name')

        # Table 8 [0,1]: RC details (name, phone, email)
        if len(tables) > 7:
            rc_name = get_text('rc_name')
            rc_phone = get_text('rc_phone')
            rc_email = get_text('rc_email')
            tables[7].cell(0, 1).text = f"{rc_name}\n\n{rc_phone}\n\n{rc_email}"

        # Table 10 [0,1]: Documents reviewed
        if len(tables) > 9:
            doc_cbs = getattr(self, 'documents_checkboxes', {})
            docs = []
            doc_labels = {
                'cpa_minutes': 'CPA Minutes',
                'psychology_reports': 'Psychology Reports',
                'hcr20': 'HCR-20',
                'sara': 'SARA',
                'other_risk_tools': 'Other Risk Assessment Tools',
                'previous_reports': 'Previous Reports',
                'current_reports': 'Current Reports',
                'previous_notes': 'Previous Notes',
                'current_notes': 'Current Notes',
            }
            for key, label in doc_labels.items():
                if doc_cbs.get(key) and doc_cbs[key].isChecked():
                    docs.append(label)
            # Add other documents if specified
            other_docs = getattr(self, 'other_documents', None)
            if other_docs and other_docs.text().strip():
                docs.append(other_docs.text().strip())
            tables[9].cell(0, 1).text = ", ".join(docs)

        # Table 11 [0,1]: Purpose of leave
        if len(tables) > 10:
            tables[10].cell(0, 1).text = get_card_text('purpose')

        # Table 12 [0,1]: Overnight leave
        if len(tables) > 11:
            tables[11].cell(0, 1).text = get_card_text('overnight')

        # Table 13 [0,1]: Escorted overnight
        if len(tables) > 12:
            tables[12].cell(0, 1).text = get_card_text('escorted_overnight')

        # Table 14 [0,1]: Compassionate
        if len(tables) > 13:
            tables[13].cell(0, 1).text = get_card_text('compassionate')

        # Table 15 [0,1]: Leave report
        if len(tables) > 14:
            tables[14].cell(0, 1).text = get_card_text('leave_report')

        # Table 16 [0,1]: Procedures
        if len(tables) > 15:
            tables[15].cell(0, 1).text = get_card_text('procedures')

        # Table 18 [0,1]: Hospital admissions
        if len(tables) > 17:
            tables[17].cell(0, 1).text = get_card_text('hospital_admissions')

        # Table 19 [0,1]: Index offence
        if len(tables) > 18:
            tables[18].cell(0, 1).text = get_card_text('index_offence')

        # Table 20 [0,1]: Mental disorder
        if len(tables) > 19:
            tables[19].cell(0, 1).text = get_card_text('mental_disorder')

        # Table 21 [0,1]: Attitude/behaviour
        if len(tables) > 20:
            tables[20].cell(0, 1).text = get_card_text('attitude_behaviour')

        # Table 22 [0,1]: Risk factors
        if len(tables) > 21:
            tables[21].cell(0, 1).text = get_card_text('risk_factors')

        # Table 23 [0,1]: Medication
        if len(tables) > 22:
            tables[22].cell(0, 1).text = get_card_text('medication')

        # Table 24 [0,1]: Psychology
        if len(tables) > 23:
            tables[23].cell(0, 1).text = get_card_text('psychology')

        # Table 25 [0,1]: Extremism
        if len(tables) > 24:
            tables[24].cell(0, 1).text = get_card_text('extremism')

        # Table 27 [0,1]: Absconding
        if len(tables) > 26:
            tables[26].cell(0, 1).text = get_card_text('absconding')

        # =============================================
        # SECTION 5: MAPPA - Tick checkboxes in document
        # =============================================
        # Table 29 [0,1]: MAPPA coordinator (5a)
        if len(tables) > 28:
            mappa_coord = getattr(self, 'mappa_coordinator', None)
            tables[28].cell(0, 1).text = mappa_coord.toPlainText() if mappa_coord else ""

        # MAPPA checkboxes in document (search paragraphs for checkbox elements)
        # Find and tick MAPPA checkboxes based on form selections
        from docx.oxml.ns import qn as docx_qn
        from docx.oxml import OxmlElement as docx_OxmlElement

        def tick_docx_checkbox(paragraph, cb_idx, checked=True):
            """Tick a checkbox in a Word document paragraph."""
            try:
                checkboxes = paragraph._element.findall('.//' + docx_qn('w:checkBox'))
                if cb_idx < len(checkboxes):
                    cb = checkboxes[cb_idx]
                    # Remove existing checked element
                    for checked_elem in cb.findall(docx_qn('w:checked')):
                        cb.remove(checked_elem)
                    # Set default value
                    default = cb.find(docx_qn('w:default'))
                    if default is not None:
                        default.set(docx_qn('w:val'), '1' if checked else '0')
                    # Add checked element
                    if checked:
                        checked_elem = docx_OxmlElement('w:checked')
                        checked_elem.set(docx_qn('w:val'), '1')
                        cb.insert(0, checked_elem)
            except Exception:
                pass

        # Search paragraphs for MAPPA section checkboxes and tick based on form state
        # MAPPA Category checkboxes (Cat 1, Cat 2, Cat 3)
        mappa_cat_selected = None
        if hasattr(self, 'mappa_categories'):
            for cat_name, rb in self.mappa_categories.items():
                if rb.isChecked():
                    if "1" in cat_name:
                        mappa_cat_selected = 1
                    elif "2" in cat_name:
                        mappa_cat_selected = 2
                    elif "3" in cat_name:
                        mappa_cat_selected = 3
                    break

        # MAPPA Level checkboxes (Level 1, 2, 3)
        mappa_level_selected = None
        if hasattr(self, 'mappa_levels'):
            for lvl_name, rb in self.mappa_levels.items():
                if rb.isChecked():
                    if "1" in lvl_name:
                        mappa_level_selected = 1
                    elif "2" in lvl_name:
                        mappa_level_selected = 2
                    elif "3" in lvl_name:
                        mappa_level_selected = 3
                    break

        # Find paragraphs containing MAPPA checkbox text and tick them
        for para in doc.paragraphs:
            para_text = para.text.lower()

            # 5b Category checkboxes
            if 'category' in para_text or 'cat 1' in para_text or 'cat 2' in para_text or 'cat 3' in para_text:
                if mappa_cat_selected == 1 and ('cat 1' in para_text or 'category 1' in para_text):
                    tick_docx_checkbox(para, 0, True)
                elif mappa_cat_selected == 2 and ('cat 2' in para_text or 'category 2' in para_text):
                    tick_docx_checkbox(para, 0, True)
                elif mappa_cat_selected == 3 and ('cat 3' in para_text or 'category 3' in para_text):
                    tick_docx_checkbox(para, 0, True)

            # 5c Level checkboxes
            if 'level' in para_text:
                if mappa_level_selected == 1 and 'level 1' in para_text:
                    tick_docx_checkbox(para, 0, True)
                elif mappa_level_selected == 2 and 'level 2' in para_text:
                    tick_docx_checkbox(para, 0, True)
                elif mappa_level_selected == 3 and 'level 3' in para_text:
                    tick_docx_checkbox(para, 0, True)

        # Table 30 [0,1]: MAPPA additional notes (5d/5e/5f - any prose that needs to be included)
        if len(tables) > 29:
            # Build MAPPA prose for any additional info (coordinator, notification status, etc.)
            mappa_prose = []
            if hasattr(self, 'mappa_eligible_no') and self.mappa_eligible_no.isChecked():
                mappa_prose.append("Not convicted of MAPPA eligible offence.")
            else:
                # Notification status
                if hasattr(self, 'mappa_l1_notif_yes') and self.mappa_l1_notif_yes.isChecked():
                    mappa_prose.append("MAPPA I notification has been submitted.")
                elif hasattr(self, 'mappa_l1_notif_no') and self.mappa_l1_notif_no.isChecked():
                    if hasattr(self, 'mappa_l1_will_yes') and self.mappa_l1_will_yes.isChecked():
                        mappa_prose.append("MAPPA I notification will be submitted prior to leave.")
                if hasattr(self, 'mappa_l23_notif_yes') and self.mappa_l23_notif_yes.isChecked():
                    mappa_prose.append("MAPPA notification submitted and response received.")
                elif hasattr(self, 'mappa_l23_notif_no') and self.mappa_l23_notif_no.isChecked():
                    mappa_prose.append("MAPPA response NOT yet received.")
                # Level reason
                if hasattr(self, 'mappa_level_reason'):
                    reason = self.mappa_level_reason.toPlainText().strip()
                    if reason:
                        mappa_prose.append(reason)
            tables[29].cell(0, 1).text = " ".join(mappa_prose)

        # =============================================
        # SECTION 6: Victims/VLO - Map to correct tables
        # Template structure:
        #   Table 31: "The name and contact details of the Victim Liaison..."
        #   Table 32: "When did the VLO/s reply?"
        #   Table 33: "Details of any conditions requested..."
        #   Table 34: "If there is no VLO or victim contact..."
        #   Table 35: HEADER (1x1) - skip
        # =============================================
        # Table 31 [0,1]: VLO contact details
        if len(tables) > 31:
            vlo_contact = ""
            if hasattr(self, 'victims_vlo_contact'):
                vlo_contact = self.victims_vlo_contact.toPlainText().strip()
            if not vlo_contact:
                vlo_contact = "VLO: Not available"
            tables[31].cell(0, 1).text = vlo_contact

        # Table 32 [0,1]: VLO reply date
        if len(tables) > 32:
            reply_text = ""
            if hasattr(self, 'victims_reply_date'):
                reply_text = self.victims_reply_date.text().strip()
            tables[32].cell(0, 1).text = reply_text

        # Table 33 [0,1]: Victim conditions requested
        if len(tables) > 33:
            conditions = ""
            if hasattr(self, 'victims_conditions'):
                conditions = self.victims_conditions.toPlainText().strip()
            tables[33].cell(0, 1).text = conditions

        # Table 34 [0,1]: Risk assessment if no VLO
        if len(tables) > 34:
            risk_text = ""
            if hasattr(self, 'victims_risk_assessment'):
                risk_text = self.victims_risk_assessment.toPlainText().strip()
            if hasattr(self, 'victims_clinical'):
                clinical = self.victims_clinical.toPlainText().strip()
                if clinical:
                    risk_text += f"\n\nClinical considerations: {clinical}" if risk_text else clinical
            tables[34].cell(0, 1).text = risk_text

        # =============================================
        # SECTION 7: Transferred Prisoners - Map correctly
        # Table 35 is a HEADER (1x1) - skip it
        # =============================================
        # Check if "Not applicable" is selected
        is_not_applicable = hasattr(self, 'prisoners_applicable_na') and self.prisoners_applicable_na.isChecked()

        # Table 36 [0,1]: 7a - Offender Manager details
        if len(tables) > 36:
            if is_not_applicable:
                tables[36].cell(0, 1).text = "Not applicable"
            else:
                # If applicable, put OM details here
                om_contact = ""
                if hasattr(self, 'prisoners_om_contact'):
                    om_contact = self.prisoners_om_contact.toPlainText().strip()
                tables[36].cell(0, 1).text = om_contact

        # Table 37 [0,1]: 7b - OM response to leave proposal
        if len(tables) > 37:
            if is_not_applicable:
                tables[37].cell(0, 1).text = ""
            else:
                response_text = ""
                if hasattr(self, 'prisoners_response'):
                    response_text = self.prisoners_response.toPlainText().strip()
                tables[37].cell(0, 1).text = response_text

        # Table 38 [0,1]: 7c - Remission to prison considered
        if len(tables) > 38:
            if is_not_applicable:
                tables[38].cell(0, 1).text = ""
            else:
                remission_parts = []
                if hasattr(self, 'prisoners_response'):
                    response = self.prisoners_response.toPlainText().strip()
                    if response:
                        remission_parts.append(response)
                if hasattr(self, 'prisoners_prognosis'):
                    prognosis = self.prisoners_prognosis.toPlainText().strip()
                    if prognosis:
                        remission_parts.append(f"Return prognosis: {prognosis}")
                if hasattr(self, 'prisoners_factors'):
                    factors = self.prisoners_factors.toPlainText().strip()
                    if factors:
                        remission_parts.append(f"Factors against remission: {factors}")
                if hasattr(self, 'prisoners_timeframe'):
                    timeframe = self.prisoners_timeframe.toPlainText().strip()
                    if timeframe:
                        remission_parts.append(f"Timeframe: {timeframe}")
                if hasattr(self, 'prisoners_unlikely'):
                    unlikely = self.prisoners_unlikely.toPlainText().strip()
                    if unlikely:
                        remission_parts.append(f"Clinical view: {unlikely}")
                tables[38].cell(0, 1).text = "\n".join(remission_parts)

        # =============================================
        # SECTION 8: Fitness to Plead
        # Template: Table 39 = "For patients whose s37/41 order..."
        # Table 40 is a 1x1 HEADER - skip
        # =============================================
        if len(tables) > 39:
            tables[39].cell(0, 1).text = get_card_text('fitness_to_plead')

        # =============================================
        # SECTION 9: Additional Comments - Split 9a and 9b
        # Template: Table 40 = HEADER (1x1) - skip
        #           Table 41 = "Please detail any other information..."
        #           Table 42 = "Confirm that this application has been discussed..."
        # =============================================
        # Table 41 [0,1]: Additional comments
        if len(tables) > 41:
            text_9a = ""
            if hasattr(self, 'additional_comments_text'):
                text_9a = self.additional_comments_text.toPlainText().strip()
            tables[41].cell(0, 1).text = text_9a if text_9a else "Nil"

        # Table 42 [0,1]: Patient discussion
        if len(tables) > 42:
            section_9b_parts = []
            if hasattr(self, 'comments_discussed_yes') and self.comments_discussed_yes.isChecked():
                section_9b_parts.append("This has been discussed with the patient.")
                # Check for issues
                if hasattr(self, 'comments_issues_yes') and self.comments_issues_yes.isChecked():
                    details = ""
                    if hasattr(self, 'comments_issues_details'):
                        details = self.comments_issues_details.toPlainText().strip()
                    if details:
                        section_9b_parts.append(f"Issues of concern: {details}")
                    else:
                        section_9b_parts.append("Issues of concern were raised.")
                elif hasattr(self, 'comments_issues_no') and self.comments_issues_no.isChecked():
                    section_9b_parts.append("No issues of concern.")
            elif hasattr(self, 'comments_discussed_no') and self.comments_discussed_no.isChecked():
                section_9b_parts.append("This has not been discussed with the patient.")
            tables[42].cell(0, 1).text = " ".join(section_9b_parts)

        # =============================================
        # SIGNATURE TABLE
        # Template: Table 43 = signature (2x4)
        # =============================================
        if len(tables) > 43:
            sig_line = getattr(self, 'sig_line', None)
            sig_name = getattr(self, 'sig_name', None)
            sig_date = getattr(self, 'sig_date', None)

            sig_text = ""
            if sig_line and sig_line.text():
                sig_text = sig_line.text()
            if sig_name and sig_name.text():
                sig_text += f"\n\nPrint name: {sig_name.text()}"

            # Row 1 is index 1
            if len(tables[43].rows) > 1:
                tables[43].cell(1, 1).text = sig_text
                # Fix date - clear any placeholder text and set the date
                if sig_date:
                    date_cell = tables[43].cell(1, 3)
                    # Clear any placeholder text first
                    date_cell.text = sig_date.date().toString("dd/MM/yyyy")

        # Table 46 [0,1]: Annex - patient progress
        if len(tables) > 45:
            annex_progress = getattr(self, 'annex_progress', None)
            tables[45].cell(0, 1).text = annex_progress.toPlainText() if annex_progress else ""

        # Table 47 [0,1]: Annex - patient wishes
        if len(tables) > 46:
            annex_wishes = getattr(self, 'annex_wishes', None)
            tables[46].cell(0, 1).text = annex_wishes.toPlainText() if annex_wishes else ""

        # Table 48 [0,1]: Annex - RC confirmation
        if len(tables) > 47:
            annex_confirm = getattr(self, 'annex_confirm', None)
            tables[47].cell(0, 1).text = annex_confirm.toPlainText() if annex_confirm else ""

        try:
            doc.save(file_path)
            QMessageBox.information(self, "Export Complete", f"Form exported to:\n{file_path}")
        except Exception as e:
            QMessageBox.warning(self, "Export Error", f"Failed to save document:\n{str(e)}")
            print(f"[MOJ-LEAVE] Export error: {e}")

    def _clear_form(self):
        """Clear all form fields, imported data, and internal data stores.
        Preserves only 'my details' fields (RC name/email/phone, signature name/role).
        """
        reply = QMessageBox.question(
            self,
            "Clear Form",
            "Are you sure you want to clear all form data?\n\nThis will remove all imported data and reset the form.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        if reply != QMessageBox.StandardButton.Yes:
            return

        # Fields to preserve (my details / clinician info)
        PRESERVE_FIELDS = {"rc_name", "rc_email", "rc_phone", "sig_name", "sig_role"}
        preserved_values = {}
        for field_name in PRESERVE_FIELDS:
            obj = getattr(self, field_name, None)
            if obj and isinstance(obj, QLineEdit):
                preserved_values[field_name] = obj.text()

        # ================================================================
        # 1. CLEAR ALL CARDS AND DESTROY POPUPS
        # ================================================================
        for card in self.cards.values():
            card.editor.clear()

        # Destroy all popups and remove from stack
        for key, popup in list(self.popups.items()):
            if hasattr(self, 'popup_stack'):
                self.popup_stack.removeWidget(popup)
            popup.deleteLater()
        self.popups.clear()

        # ================================================================
        # 2. CLEAR ALL EXTRACTED DATA STORES
        # ================================================================
        self._extracted_raw_notes = []
        self._extracted_categories = {}
        self._last_generated_text = {}

        # Reset processing guards so new data will be accepted
        self._data_processed_id = None
        self._notes_processed_id = None
        self._auto_fill_phase = True  # Re-enable auto-fill for next import

        # Clear all self._extracted_* attributes
        extracted_attrs = [
            '_extracted_psych_items', '_extracted_forensic_items',
            '_extracted_mental_disorder_items', '_extracted_risk_items',
            '_extracted_historical_risks', '_extracted_current_risks',
            '_extracted_med_import_entries', '_extracted_med_response',
            '_extracted_medication_items', '_extracted_patient_details',
            '_extracted_stab_destab', '_extracted_index_offence_work',
            '_extracted_offend_insight', '_extracted_responsibility',
            '_extracted_victim_empathy', '_extracted_risk_attitudes',
            '_extracted_treatments', '_extracted_relapse',
            '_extracted_engagement', '_extracted_outstanding',
            '_extracted_attitude_categorized_items',
            '_extracted_document_text', '_extracted_raw_notes_for_meds',
        ]
        for attr in extracted_attrs:
            if hasattr(self, attr):
                val = getattr(self, attr)
                if isinstance(val, dict):
                    setattr(self, attr, {})
                elif isinstance(val, list):
                    setattr(self, attr, [])
                elif isinstance(val, str):
                    setattr(self, attr, "")
                else:
                    setattr(self, attr, None)

        # Clear data extractor reference
        if hasattr(self, '_data_extractor'):
            self._data_extractor = None

        # ================================================================
        # 3. CLEAR ALL IMPORT CHECKBOX LISTS AND IMPORTED ENTRIES
        # ================================================================
        checkbox_attrs = [
            'leave_import_checkboxes', 'psych_import_checkboxes',
            'forensic_import_checkboxes', 'mental_disorder_import_checkboxes',
            'att_import_checkboxes', 'risk_import_checkboxes',
            'med_import_checkboxes', 'extremism_import_checkboxes',
            'awol_import_checkboxes', 'mappa_import_checkboxes',
            'prisoners_import_checkboxes', 'fitness_import_checkboxes',
        ]
        for attr in checkbox_attrs:
            if hasattr(self, attr):
                setattr(self, attr, [])

        entry_attrs = [
            'leave_imported_entries', 'psych_imported_entries',
            'forensic_imported_entries', 'extremism_imported_entries',
            'absconding_imported_entries', 'mappa_imported_entries',
            'prisoners_imported_entries', 'fitness_imported_entries',
        ]
        for attr in entry_attrs:
            if hasattr(self, attr):
                setattr(self, attr, [])

        # ================================================================
        # 4. CLEAR ALL IMPORT LAYOUT WIDGETS (remove child widgets)
        # ================================================================
        layout_attrs = [
            'leave_import_layout', 'psych_import_layout',
            'forensic_import_layout', 'mental_disorder_import_layout',
            'risk_import_layout', 'med_import_layout',
            'absconding_import_layout', 'mappa_import_layout',
            'prisoners_import_layout', 'fitness_import_layout',
            'att_import_entries_layout',
        ]
        for attr in layout_attrs:
            layout = getattr(self, attr, None)
            if layout:
                while layout.count():
                    item = layout.takeAt(0)
                    if item.widget():
                        item.widget().deleteLater()

        # ================================================================
        # 5. RESET IMPORT SUBTITLES
        # ================================================================
        subtitle_attrs = [
            'leave_import_subtitle', 'forensic_import_subtitle',
            'mental_disorder_import_subtitle', 'risk_import_subtitle',
        ]
        for attr in subtitle_attrs:
            lbl = getattr(self, attr, None)
            if lbl and isinstance(lbl, QLabel):
                lbl.setText("")

        # ================================================================
        # 6. CLEAR ALL POPUP FIELDS (except preserved my-details fields)
        # ================================================================
        for attr in dir(self):
            if attr.startswith('_'):
                continue
            if attr in PRESERVE_FIELDS:
                continue
            obj = getattr(self, attr, None)
            if isinstance(obj, QTextEdit):
                obj.clear()
            elif isinstance(obj, QLineEdit):
                obj.clear()
            elif isinstance(obj, QCheckBox):
                obj.setChecked(False)
            elif isinstance(obj, QComboBox):
                obj.setCurrentIndex(0)
            elif isinstance(obj, QSlider):
                obj.setValue(obj.minimum())
            elif isinstance(obj, QRadioButton):
                obj.setAutoExclusive(False)
                obj.setChecked(False)
                obj.setAutoExclusive(True)

        # Catch any nested child widgets missed by dir(self) (e.g. inside dicts)
        for widget in self.findChildren(QSlider):
            widget.setValue(widget.minimum())
        for widget in self.findChildren(QCheckBox):
            widget.setChecked(False)

        # ================================================================
        # 7. RESTORE PRESERVED MY-DETAILS FIELDS
        # ================================================================
        for field_name, value in preserved_values.items():
            obj = getattr(self, field_name, None)
            if obj and isinstance(obj, QLineEdit):
                obj.setText(value)

        print("[MOJ-LEAVE] Form cleared - all imported data and fields reset (my details preserved)")

    # ================================================================
    # STATE MANAGEMENT
    # ================================================================

    def get_state(self) -> dict:
        """Get current form state for saving."""
        state = {"cards": {}}

        for key, card in self.cards.items():
            state["cards"][key] = card.editor.toPlainText()

        # Save popup field values
        state["fields"] = {}
        for attr in ["patient_name", "hospital_number", "hospital_name", "ward", "mha_section", "moj_reference",
                     "rc_name", "rc_email", "rc_phone", "sig_name", "sig_role"]:
            if hasattr(self, attr):
                obj = getattr(self, attr)
                if isinstance(obj, QLineEdit):
                    state["fields"][attr] = obj.text()

        return state

    def set_state(self, state: dict):
        """Restore form state."""
        if "cards" in state:
            for key, text in state["cards"].items():
                if key in self.cards:
                    self.cards[key].editor.setPlainText(text)

        if "fields" in state:
            for attr, value in state["fields"].items():
                if hasattr(self, attr):
                    obj = getattr(self, attr)
                    if isinstance(obj, QLineEdit):
                        obj.setText(value)

    def _fill_patient_details(self, patient_info: dict):
        """Fill patient details from extracted demographics - only if fields are empty."""
        if not patient_info:
            return
        if patient_info.get("name") and hasattr(self, 'patient_name') and self.patient_name:
            if not self.patient_name.text().strip():
                self.patient_name.setText(patient_info["name"])
                print(f"[MOJLeaveForm] Set patient name: {patient_info['name']}")
        # Set gender if not already selected
        if patient_info.get("gender") and hasattr(self, 'gender_male') and hasattr(self, 'gender_female'):
            gender = patient_info["gender"].lower()
            if not self.gender_male.isChecked() and not self.gender_female.isChecked():
                if gender == "male":
                    self.gender_male.setChecked(True)
                elif gender == "female":
                    self.gender_female.setChecked(True)
                print(f"[MOJLeaveForm] Set gender: {gender}")
                if hasattr(self, '_update_all_previews_for_gender'):
                    self._update_all_previews_for_gender()
